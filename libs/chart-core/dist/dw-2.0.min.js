(function () {
    'use strict';

    function guessDelimiterFromLocale(numeral) {
      try {
        if (numeral.localeData().delimiters.decimal === ',') {
          return ';';
        }
      } catch (e) {// invalid locale data
      }

      return ',';
    }

    function escapeDelimitedValue(value, delimiter, quoteChar) {
      if (value === null || value === undefined || typeof value === 'number' && !Number.isFinite(value)) {
        return '';
      }

      const s = String(value);

      if (s.indexOf(quoteChar) !== -1) {
        // A double-quote appearing inside a field MUST be escaped by preceding it with another
        // double quote, and the field itself MUST be enclosed in double quotes.
        // See paragraph 8 at https://csv-spec.org/#csv-format-specification
        return quoteChar + s.replace(new RegExp(quoteChar, 'g'), quoteChar + quoteChar) + quoteChar;
      }

      if (new RegExp(`[\n\r${delimiter}]`).test(s)) {
        // Fields containing line breaks (CRLF, LF, or CR), double quotes, or the delimiter
        // character (normally a comma) MUST be enclosed in double-quotes.
        // See paragraph 7 at https://csv-spec.org/#csv-format-specification
        return quoteChar + s + quoteChar;
      }

      return s;
    }

    function formatDelimited(rows) {
      let {
        delimiter = ',',
        quoteChar = '"',
        lineTerminator = '\n'
      } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return rows.map(row => row.map(value => escapeDelimitedValue(value, delimiter, quoteChar)).join(delimiter)).join(lineTerminator);
    }
    var delimited$1 = {
      formatDelimited,
      guessDelimiterFromLocale
    };

    // Current version.
    var VERSION = '1.13.4';

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root$9 = (typeof self == 'object' && self.self === self && self) ||
              (typeof global == 'object' && global.global === global && global) ||
              Function('return this')() ||
              {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    // Create quick reference variables for speed access to core prototypes.
    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty$a = ObjProto.hasOwnProperty;

    // Modern feature detection.
    var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
        supportsDataView = typeof DataView !== 'undefined';

    // All **ECMAScript 5+** native function implementations that we hope to use
    // are declared here.
    var nativeIsArray = Array.isArray,
        nativeKeys$2 = Object.keys,
        nativeCreate$5 = Object.create,
        nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

    // Create references to these builtin functions because we override them.
    var _isNaN = isNaN,
        _isFinite = isFinite;

    // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    // The largest integer that can be represented exactly.
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

    // Some functions take a variable number of arguments, or a few expected
    // arguments at the beginning and then a variable number of values to operate
    // on. This helper accumulates all remaining arguments past the function’s
    // argument length (or an explicit `startIndex`), into an array that becomes
    // the last argument. Similar to ES6’s "rest parameter".
    function restArguments(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0),
            rest = Array(length),
            index = 0;
        for (; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, arguments[0], rest);
          case 2: return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
      };
    }

    // Is a given variable an object?
    function isObject$3(obj) {
      var type = typeof obj;
      return type === 'function' || (type === 'object' && !!obj);
    }

    // Is a given value equal to null?
    function isNull(obj) {
      return obj === null;
    }

    // Is a given variable undefined?
    function isUndefined(obj) {
      return obj === void 0;
    }

    // Is a given value a boolean?
    function isBoolean(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    }

    // Is a given value a DOM element?
    function isElement(obj) {
      return !!(obj && obj.nodeType === 1);
    }

    // Internal function for creating a `toString`-based type tester.
    function tagTester(name) {
      var tag = '[object ' + name + ']';
      return function(obj) {
        return toString.call(obj) === tag;
      };
    }

    var isString = tagTester('String');

    var isNumber = tagTester('Number');

    var isDate = tagTester('Date');

    var isRegExp = tagTester('RegExp');

    var isError = tagTester('Error');

    var isSymbol = tagTester('Symbol');

    var isArrayBuffer = tagTester('ArrayBuffer');

    var isFunction$3 = tagTester('Function');

    // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
    // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
    var nodelist = root$9.document && root$9.document.childNodes;
    if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
      isFunction$3 = function(obj) {
        return typeof obj == 'function' || false;
      };
    }

    var isFunction$4 = isFunction$3;

    var hasObjectTag = tagTester('Object');

    // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
    // In IE 11, the most common among them, this problem also applies to
    // `Map`, `WeakMap` and `Set`.
    var hasStringTagBug = (
          supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))
        ),
        isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));

    var isDataView = tagTester('DataView');

    // In IE 10 - Edge 13, we need a different heuristic
    // to determine whether an object is a `DataView`.
    function ie10IsDataView(obj) {
      return obj != null && isFunction$4(obj.getInt8) && isArrayBuffer(obj.buffer);
    }

    var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);

    // Is a given value an array?
    // Delegates to ECMA5's native `Array.isArray`.
    var isArray$5 = nativeIsArray || tagTester('Array');

    // Internal function to check whether `key` is an own property name of `obj`.
    function has$1(obj, key) {
      return obj != null && hasOwnProperty$a.call(obj, key);
    }

    var isArguments$2 = tagTester('Arguments');

    // Define a fallback version of the method in browsers (ahem, IE < 9), where
    // there isn't any inspectable "Arguments" type.
    (function() {
      if (!isArguments$2(arguments)) {
        isArguments$2 = function(obj) {
          return has$1(obj, 'callee');
        };
      }
    }());

    var isArguments$3 = isArguments$2;

    // Is a given object a finite number?
    function isFinite$1(obj) {
      return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
    }

    // Is the given value `NaN`?
    function isNaN$1(obj) {
      return isNumber(obj) && _isNaN(obj);
    }

    // Predicate-generating function. Often useful outside of Underscore.
    function constant(value) {
      return function() {
        return value;
      };
    }

    // Common internal logic for `isArrayLike` and `isBufferLike`.
    function createSizePropertyCheck(getSizeProperty) {
      return function(collection) {
        var sizeProperty = getSizeProperty(collection);
        return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
      }
    }

    // Internal helper to generate a function to obtain property `key` from `obj`.
    function shallowProperty(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    }

    // Internal helper to obtain the `byteLength` property of an object.
    var getByteLength = shallowProperty('byteLength');

    // Internal helper to determine whether we should spend extensive checks against
    // `ArrayBuffer` et al.
    var isBufferLike = createSizePropertyCheck(getByteLength);

    // Is a given value a typed array?
    var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    function isTypedArray$3(obj) {
      // `ArrayBuffer.isView` is the most future-proof, so use it when available.
      // Otherwise, fall back on the above regular expression.
      return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :
                    isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
    }

    var isTypedArray$4 = supportsArrayBuffer ? isTypedArray$3 : constant(false);

    // Internal helper to obtain the `length` property of an object.
    var getLength = shallowProperty('length');

    // Internal helper to create a simple lookup structure.
    // `collectNonEnumProps` used to depend on `_.contains`, but this led to
    // circular imports. `emulatedSet` is a one-off solution that only works for
    // arrays of strings.
    function emulatedSet(keys) {
      var hash = {};
      for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
      return {
        contains: function(key) { return hash[key] === true; },
        push: function(key) {
          hash[key] = true;
          return keys.push(key);
        }
      };
    }

    // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
    // be iterated by `for key in ...` and thus missed. Extends `keys` in place if
    // needed.
    function collectNonEnumProps(obj, keys) {
      keys = emulatedSet(keys);
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = (isFunction$4(constructor) && constructor.prototype) || ObjProto;

      // Constructor is a special case.
      var prop = 'constructor';
      if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);

      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
          keys.push(prop);
        }
      }
    }

    // Retrieve the names of an object's own properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`.
    function keys$2(obj) {
      if (!isObject$3(obj)) return [];
      if (nativeKeys$2) return nativeKeys$2(obj);
      var keys = [];
      for (var key in obj) if (has$1(obj, key)) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    }

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    function isEmpty(obj) {
      if (obj == null) return true;
      // Skip the more expensive `toString`-based type checks if `obj` has no
      // `.length`.
      var length = getLength(obj);
      if (typeof length == 'number' && (
        isArray$5(obj) || isString(obj) || isArguments$3(obj)
      )) return length === 0;
      return getLength(keys$2(obj)) === 0;
    }

    // Returns whether an object has a given set of `key:value` pairs.
    function isMatch(object, attrs) {
      var _keys = keys$2(attrs), length = _keys.length;
      if (object == null) return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = _keys[i];
        if (attrs[key] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    }

    // If Underscore is called as a function, it returns a wrapped object that can
    // be used OO-style. This wrapper holds altered versions of all functions added
    // through `_.mixin`. Wrapped objects may be chained.
    function _$1(obj) {
      if (obj instanceof _$1) return obj;
      if (!(this instanceof _$1)) return new _$1(obj);
      this._wrapped = obj;
    }

    _$1.VERSION = VERSION;

    // Extracts the result from a wrapped and chained object.
    _$1.prototype.value = function() {
      return this._wrapped;
    };

    // Provide unwrapping proxies for some methods used in engine operations
    // such as arithmetic and JSON stringification.
    _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;

    _$1.prototype.toString = function() {
      return String(this._wrapped);
    };

    // Internal function to wrap or shallow-copy an ArrayBuffer,
    // typed array or DataView to a new view, reusing the buffer.
    function toBufferView(bufferSource) {
      return new Uint8Array(
        bufferSource.buffer || bufferSource,
        bufferSource.byteOffset || 0,
        getByteLength(bufferSource)
      );
    }

    // We use this string twice, so give it a name for minification.
    var tagDataView = '[object DataView]';

    // Internal recursive comparison function for `_.isEqual`.
    function eq$3(a, b, aStack, bStack) {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
      if (a === b) return a !== 0 || 1 / a === 1 / b;
      // `null` or `undefined` only equal to itself (strict comparison).
      if (a == null || b == null) return false;
      // `NaN`s are equivalent, but non-reflexive.
      if (a !== a) return b !== b;
      // Exhaust primitive checks
      var type = typeof a;
      if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
      return deepEq(a, b, aStack, bStack);
    }

    // Internal recursive comparison function for `_.isEqual`.
    function deepEq(a, b, aStack, bStack) {
      // Unwrap any wrapped objects.
      if (a instanceof _$1) a = a._wrapped;
      if (b instanceof _$1) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className !== toString.call(b)) return false;
      // Work around a bug in IE 10 - Edge 13.
      if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {
        if (!isDataView$1(b)) return false;
        className = tagDataView;
      }
      switch (className) {
        // These types are compared by value.
        case '[object RegExp]':
          // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return '' + a === '' + b;
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive.
          // Object(NaN) is equivalent to NaN.
          if (+a !== +a) return +b !== +b;
          // An `egal` comparison is performed for other numeric values.
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a === +b;
        case '[object Symbol]':
          return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
        case '[object ArrayBuffer]':
        case tagDataView:
          // Coerce to typed array so we can fall through.
          return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
      }

      var areArrays = className === '[object Array]';
      if (!areArrays && isTypedArray$4(a)) {
          var byteLength = getByteLength(a);
          if (byteLength !== getByteLength(b)) return false;
          if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
          areArrays = true;
      }
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object') return false;

        // Objects with different constructors are not equivalent, but `Object`s or `Array`s
        // from different frames are.
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && !(isFunction$4(aCtor) && aCtor instanceof aCtor &&
                                 isFunction$4(bCtor) && bCtor instanceof bCtor)
                            && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

      // Initializing stack of traversed objects.
      // It's done here since we only need them for objects and arrays comparison.
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] === a) return bStack[length] === b;
      }

      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);

      // Recursively compare objects and arrays.
      if (areArrays) {
        // Compare array lengths to determine if a deep comparison is necessary.
        length = a.length;
        if (length !== b.length) return false;
        // Deep compare the contents, ignoring non-numeric properties.
        while (length--) {
          if (!eq$3(a[length], b[length], aStack, bStack)) return false;
        }
      } else {
        // Deep compare objects.
        var _keys = keys$2(a), key;
        length = _keys.length;
        // Ensure that both objects contain the same number of properties before comparing deep equality.
        if (keys$2(b).length !== length) return false;
        while (length--) {
          // Deep compare each member
          key = _keys[length];
          if (!(has$1(b, key) && eq$3(a[key], b[key], aStack, bStack))) return false;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return true;
    }

    // Perform a deep comparison to check if two objects are equal.
    function isEqual$1(a, b) {
      return eq$3(a, b);
    }

    // Retrieve all the enumerable property names of an object.
    function allKeys(obj) {
      if (!isObject$3(obj)) return [];
      var keys = [];
      for (var key in obj) keys.push(key);
      // Ahem, IE < 9.
      if (hasEnumBug) collectNonEnumProps(obj, keys);
      return keys;
    }

    // Since the regular `Object.prototype.toString` type tests don't work for
    // some types in IE 11, we use a fingerprinting heuristic instead, based
    // on the methods. It's not great, but it's the best we got.
    // The fingerprint method lists are defined below.
    function ie11fingerprint(methods) {
      var length = getLength(methods);
      return function(obj) {
        if (obj == null) return false;
        // `Map`, `WeakMap` and `Set` have no enumerable keys.
        var keys = allKeys(obj);
        if (getLength(keys)) return false;
        for (var i = 0; i < length; i++) {
          if (!isFunction$4(obj[methods[i]])) return false;
        }
        // If we are testing against `WeakMap`, we need to ensure that
        // `obj` doesn't have a `forEach` method in order to distinguish
        // it from a regular `Map`.
        return methods !== weakMapMethods || !isFunction$4(obj[forEachName]);
      };
    }

    // In the interest of compact minification, we write
    // each string in the fingerprints only once.
    var forEachName = 'forEach',
        hasName = 'has',
        commonInit = ['clear', 'delete'],
        mapTail = ['get', hasName, 'set'];

    // `Map`, `WeakMap` and `Set` each have slightly different
    // combinations of the above sublists.
    var mapMethods = commonInit.concat(forEachName, mapTail),
        weakMapMethods = commonInit.concat(mapTail),
        setMethods = ['add'].concat(commonInit, forEachName, hasName);

    var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

    var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

    var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

    var isWeakSet = tagTester('WeakSet');

    // Retrieve the values of an object's properties.
    function values(obj) {
      var _keys = keys$2(obj);
      var length = _keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[_keys[i]];
      }
      return values;
    }

    // Convert an object into a list of `[key, value]` pairs.
    // The opposite of `_.object` with one argument.
    function pairs(obj) {
      var _keys = keys$2(obj);
      var length = _keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [_keys[i], obj[_keys[i]]];
      }
      return pairs;
    }

    // Invert the keys and values of an object. The values must be serializable.
    function invert(obj) {
      var result = {};
      var _keys = keys$2(obj);
      for (var i = 0, length = _keys.length; i < length; i++) {
        result[obj[_keys[i]]] = _keys[i];
      }
      return result;
    }

    // Return a sorted list of the function names available on the object.
    function functions(obj) {
      var names = [];
      for (var key in obj) {
        if (isFunction$4(obj[key])) names.push(key);
      }
      return names.sort();
    }

    // An internal function for creating assigner functions.
    function createAssigner(keysFunc, defaults) {
      return function(obj) {
        var length = arguments.length;
        if (defaults) obj = Object(obj);
        if (length < 2 || obj == null) return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!defaults || obj[key] === void 0) obj[key] = source[key];
          }
        }
        return obj;
      };
    }

    // Extend a given object with all the properties in passed-in object(s).
    var extend = createAssigner(allKeys);

    // Assigns a given object with all the own properties in the passed-in
    // object(s).
    // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    var extendOwn = createAssigner(keys$2);

    // Fill in a given object with default properties.
    var defaults = createAssigner(allKeys, true);

    // Create a naked function reference for surrogate-prototype-swapping.
    function ctor() {
      return function(){};
    }

    // An internal function for creating a new object that inherits from another.
    function baseCreate(prototype) {
      if (!isObject$3(prototype)) return {};
      if (nativeCreate$5) return nativeCreate$5(prototype);
      var Ctor = ctor();
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    }

    // Creates an object that inherits from the given prototype object.
    // If additional properties are provided then they will be added to the
    // created object.
    function create(prototype, props) {
      var result = baseCreate(prototype);
      if (props) extendOwn(result, props);
      return result;
    }

    // Create a (shallow-cloned) duplicate of an object.
    function clone$1(obj) {
      if (!isObject$3(obj)) return obj;
      return isArray$5(obj) ? obj.slice() : extend({}, obj);
    }

    // Invokes `interceptor` with the `obj` and then returns `obj`.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    function tap(obj, interceptor) {
      interceptor(obj);
      return obj;
    }

    // Normalize a (deep) property `path` to array.
    // Like `_.iteratee`, this function can be customized.
    function toPath$1(path) {
      return isArray$5(path) ? path : [path];
    }
    _$1.toPath = toPath$1;

    // Internal wrapper for `_.toPath` to enable minification.
    // Similar to `cb` for `_.iteratee`.
    function toPath(path) {
      return _$1.toPath(path);
    }

    // Internal function to obtain a nested property in `obj` along `path`.
    function deepGet(obj, path) {
      var length = path.length;
      for (var i = 0; i < length; i++) {
        if (obj == null) return void 0;
        obj = obj[path[i]];
      }
      return length ? obj : void 0;
    }

    // Get the value of the (deep) property on `path` from `object`.
    // If any property in `path` does not exist or if the value is
    // `undefined`, return `defaultValue` instead.
    // The `path` is normalized through `_.toPath`.
    function get$1(object, path, defaultValue) {
      var value = deepGet(object, toPath(path));
      return isUndefined(value) ? defaultValue : value;
    }

    // Shortcut function for checking if an object has a given property directly on
    // itself (in other words, not on a prototype). Unlike the internal `has`
    // function, this public version can also traverse nested properties.
    function has(obj, path) {
      path = toPath(path);
      var length = path.length;
      for (var i = 0; i < length; i++) {
        var key = path[i];
        if (!has$1(obj, key)) return false;
        obj = obj[key];
      }
      return !!length;
    }

    // Keep the identity function around for default iteratees.
    function identity(value) {
      return value;
    }

    // Returns a predicate for checking whether an object has a given set of
    // `key:value` pairs.
    function matcher(attrs) {
      attrs = extendOwn({}, attrs);
      return function(obj) {
        return isMatch(obj, attrs);
      };
    }

    // Creates a function that, when passed an object, will traverse that object’s
    // properties down the given `path`, specified as an array of keys or indices.
    function property(path) {
      path = toPath(path);
      return function(obj) {
        return deepGet(obj, path);
      };
    }

    // Internal function that returns an efficient (for current engines) version
    // of the passed-in callback, to be repeatedly applied in other Underscore
    // functions.
    function optimizeCb(func, context, argCount) {
      if (context === void 0) return func;
      switch (argCount == null ? 3 : argCount) {
        case 1: return function(value) {
          return func.call(context, value);
        };
        // The 2-argument case is omitted because we’re not using it.
        case 3: return function(value, index, collection) {
          return func.call(context, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
      }
      return function() {
        return func.apply(context, arguments);
      };
    }

    // An internal function to generate callbacks that can be applied to each
    // element in a collection, returning the desired result — either `_.identity`,
    // an arbitrary callback, a property matcher, or a property accessor.
    function baseIteratee(value, context, argCount) {
      if (value == null) return identity;
      if (isFunction$4(value)) return optimizeCb(value, context, argCount);
      if (isObject$3(value) && !isArray$5(value)) return matcher(value);
      return property(value);
    }

    // External wrapper for our callback generator. Users may customize
    // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
    // This abstraction hides the internal-only `argCount` argument.
    function iteratee(value, context) {
      return baseIteratee(value, context, Infinity);
    }
    _$1.iteratee = iteratee;

    // The function we call internally to generate a callback. It invokes
    // `_.iteratee` if overridden, otherwise `baseIteratee`.
    function cb(value, context, argCount) {
      if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
      return baseIteratee(value, context, argCount);
    }

    // Returns the results of applying the `iteratee` to each element of `obj`.
    // In contrast to `_.map` it returns an object.
    function mapObject(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var _keys = keys$2(obj),
          length = _keys.length,
          results = {};
      for (var index = 0; index < length; index++) {
        var currentKey = _keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    }

    // Predicate-generating function. Often useful outside of Underscore.
    function noop(){}

    // Generates a function for a given object that returns a given property.
    function propertyOf(obj) {
      if (obj == null) return noop;
      return function(path) {
        return get$1(obj, path);
      };
    }

    // Run a function **n** times.
    function times(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++) accum[i] = iteratee(i);
      return accum;
    }

    // Return a random integer between `min` and `max` (inclusive).
    function random$1(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    }

    // A (possibly faster) way to get the current timestamp as an integer.
    var now = Date.now || function() {
      return new Date().getTime();
    };

    // Internal helper to generate functions for escaping and unescaping strings
    // to/from HTML interpolation.
    function createEscaper(map) {
      var escaper = function(match) {
        return map[match];
      };
      // Regexes for identifying a key that needs to be escaped.
      var source = '(?:' + keys$2(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    }

    // Internal list of HTML entities for escaping.
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };

    // Function for escaping strings to HTML interpolation.
    var escape = createEscaper(escapeMap);

    // Internal list of HTML entities for unescaping.
    var unescapeMap = invert(escapeMap);

    // Function for unescaping strings from HTML interpolation.
    var unescape = createEscaper(unescapeMap);

    // By default, Underscore uses ERB-style template delimiters. Change the
    // following template settings to use alternative delimiters.
    var templateSettings = _$1.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `_.templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

    function escapeChar(match) {
      return '\\' + escapes[match];
    }

    // In order to prevent third-party code injection through
    // `_.templateSettings.variable`, we test it against the following regular
    // expression. It is intentionally a bit more liberal than just matching valid
    // identifiers, but still prevents possible loopholes through defaults or
    // destructuring assignment.
    var bareIdentifier = /^\s*(\w|\$)+\s*$/;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    // NB: `oldSettings` only exists for backwards compatibility.
    function template(text, settings, oldSettings) {
      if (!settings && oldSettings) settings = oldSettings;
      settings = defaults({}, settings, _$1.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
        index = offset + match.length;

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }

        // Adobe VMs need the match returned to produce the correct offset.
        return match;
      });
      source += "';\n";

      var argument = settings.variable;
      if (argument) {
        // Insure against third-party code injection. (CVE-2021-23358)
        if (!bareIdentifier.test(argument)) throw new Error(
          'variable is not a bare identifier: ' + argument
        );
      } else {
        // If a variable is not specified, place data values in local scope.
        source = 'with(obj||{}){\n' + source + '}\n';
        argument = 'obj';
      }

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + 'return __p;\n';

      var render;
      try {
        render = new Function(argument, '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      var template = function(data) {
        return render.call(this, data, _$1);
      };

      // Provide the compiled source as a convenience for precompilation.
      template.source = 'function(' + argument + '){\n' + source + '}';

      return template;
    }

    // Traverses the children of `obj` along `path`. If a child is a function, it
    // is invoked with its parent as context. Returns the value of the final
    // child, or `fallback` if any child is undefined.
    function result(obj, path, fallback) {
      path = toPath(path);
      var length = path.length;
      if (!length) {
        return isFunction$4(fallback) ? fallback.call(obj) : fallback;
      }
      for (var i = 0; i < length; i++) {
        var prop = obj == null ? void 0 : obj[path[i]];
        if (prop === void 0) {
          prop = fallback;
          i = length; // Ensure we don't continue iterating.
        }
        obj = isFunction$4(prop) ? prop.call(obj) : prop;
      }
      return obj;
    }

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    }

    // Start chaining a wrapped Underscore object.
    function chain(obj) {
      var instance = _$1(obj);
      instance._chain = true;
      return instance;
    }

    // Internal function to execute `sourceFunc` bound to `context` with optional
    // `args`. Determines whether to execute a function as a constructor or as a
    // normal function.
    function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (isObject$3(result)) return result;
      return self;
    }

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context. `_` acts
    // as a placeholder by default, allowing any combination of arguments to be
    // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
    var partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });

    partial.placeholder = _$1;

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally).
    var bind = restArguments(function(func, context, args) {
      if (!isFunction$4(func)) throw new TypeError('Bind must be called on a function');
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });

    // Internal helper for collection methods to determine whether a collection
    // should be iterated as an array or as an object.
    // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    var isArrayLike$2 = createSizePropertyCheck(getLength);

    // Internal implementation of a recursive `flatten` function.
    function flatten$1(input, depth, strict, output) {
      output = output || [];
      if (!depth && depth !== 0) {
        depth = Infinity;
      } else if (depth <= 0) {
        return output.concat(input);
      }
      var idx = output.length;
      for (var i = 0, length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike$2(value) && (isArray$5(value) || isArguments$3(value))) {
          // Flatten current level of array or arguments object.
          if (depth > 1) {
            flatten$1(value, depth - 1, strict, output);
            idx = output.length;
          } else {
            var j = 0, len = value.length;
            while (j < len) output[idx++] = value[j++];
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    }

    // Bind a number of an object's methods to that object. Remaining arguments
    // are the method names to be bound. Useful for ensuring that all callbacks
    // defined on an object belong to it.
    var bindAll = restArguments(function(obj, keys) {
      keys = flatten$1(keys, false, false);
      var index = keys.length;
      if (index < 1) throw new Error('bindAll must be passed function names');
      while (index--) {
        var key = keys[index];
        obj[key] = bind(obj[key], obj);
      }
      return obj;
    });

    // Memoize an expensive function by storing its results.
    function memoize(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    }

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    var delay = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    var defer = partial(delay, _$1, 1);

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time. Normally, the throttled function will run
    // as much as it can, without ever going more than once per `wait` duration;
    // but if you'd like to disable the execution on the leading edge, pass
    // `{leading: false}`. To disable execution on the trailing edge, ditto.
    function throttle(func, wait, options) {
      var timeout, context, args, result;
      var previous = 0;
      if (!options) options = {};

      var later = function() {
        previous = options.leading === false ? 0 : now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      };

      var throttled = function() {
        var _now = now();
        if (!previous && options.leading === false) previous = _now;
        var remaining = wait - (_now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = _now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };

      throttled.cancel = function() {
        clearTimeout(timeout);
        previous = 0;
        timeout = context = args = null;
      };

      return throttled;
    }

    // When a sequence of calls of the returned function ends, the argument
    // function is triggered. The end of a sequence is defined by the `wait`
    // parameter. If `immediate` is passed, the argument function will be
    // triggered at the beginning of the sequence instead of at the end.
    function debounce(func, wait, immediate) {
      var timeout, previous, args, result, context;

      var later = function() {
        var passed = now() - previous;
        if (wait > passed) {
          timeout = setTimeout(later, wait - passed);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
          // This check is needed because `func` can recursively invoke `debounced`.
          if (!timeout) args = context = null;
        }
      };

      var debounced = restArguments(function(_args) {
        context = this;
        args = _args;
        previous = now();
        if (!timeout) {
          timeout = setTimeout(later, wait);
          if (immediate) result = func.apply(context, args);
        }
        return result;
      });

      debounced.cancel = function() {
        clearTimeout(timeout);
        timeout = args = context = null;
      };

      return debounced;
    }

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    function wrap(func, wrapper) {
      return partial(wrapper, func);
    }

    // Returns a negated version of the passed-in predicate.
    function negate(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    function compose() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--) result = args[i].call(this, result);
        return result;
      };
    }

    // Returns a function that will only be executed on and after the Nth call.
    function after(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    // Returns a function that will only be executed up to (but not including) the
    // Nth call.
    function before(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1) func = null;
        return memo;
      };
    }

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    var once = partial(before, 2);

    // Returns the first key on an object that passes a truth test.
    function findKey(obj, predicate, context) {
      predicate = cb(predicate, context);
      var _keys = keys$2(obj), key;
      for (var i = 0, length = _keys.length; i < length; i++) {
        key = _keys[i];
        if (predicate(obj[key], key, obj)) return key;
      }
    }

    // Internal function to generate `_.findIndex` and `_.findLastIndex`.
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array)) return index;
        }
        return -1;
      };
    }

    // Returns the first index on an array-like that passes a truth test.
    var findIndex = createPredicateIndexFinder(1);

    // Returns the last index on an array-like that passes a truth test.
    var findLastIndex = createPredicateIndexFinder(-1);

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    function sortedIndex(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0, high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
      }
      return low;
    }

    // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
    function createIndexFinder(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0, length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), isNaN$1);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item) return idx;
        }
        return -1;
      };
    }

    // Return the position of the first occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    var indexOf = createIndexFinder(1, findIndex, sortedIndex);

    // Return the position of the last occurrence of an item in an array,
    // or -1 if the item is not included in the array.
    var lastIndexOf = createIndexFinder(-1, findLastIndex);

    // Return the first value which passes a truth test.
    function find(obj, predicate, context) {
      var keyFinder = isArrayLike$2(obj) ? findIndex : findKey;
      var key = keyFinder(obj, predicate, context);
      if (key !== void 0 && key !== -1) return obj[key];
    }

    // Convenience version of a common use case of `_.find`: getting the first
    // object containing specific `key:value` pairs.
    function findWhere(obj, attrs) {
      return find(obj, matcher(attrs));
    }

    // The cornerstone for collection functions, an `each`
    // implementation, aka `forEach`.
    // Handles raw objects in addition to array-likes. Treats all
    // sparse array-likes as if they were dense.
    function each(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i, length;
      if (isArrayLike$2(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var _keys = keys$2(obj);
        for (i = 0, length = _keys.length; i < length; i++) {
          iteratee(obj[_keys[i]], _keys[i], obj);
        }
      }
      return obj;
    }

    // Return the results of applying the iteratee to each element.
    function map(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var _keys = !isArrayLike$2(obj) && keys$2(obj),
          length = (_keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = _keys ? _keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    }

    // Internal helper to create a reducing function, iterating left or right.
    function createReduce(dir) {
      // Wrap code that reassigns argument variables in a separate function than
      // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
      var reducer = function(obj, iteratee, memo, initial) {
        var _keys = !isArrayLike$2(obj) && keys$2(obj),
            length = (_keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        if (!initial) {
          memo = obj[_keys ? _keys[index] : index];
          index += dir;
        }
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = _keys ? _keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      };

      return function(obj, iteratee, memo, context) {
        var initial = arguments.length >= 3;
        return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
      };
    }

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`.
    var reduce = createReduce(1);

    // The right-associative version of reduce, also known as `foldr`.
    var reduceRight = createReduce(-1);

    // Return all the elements that pass a truth test.
    function filter(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      each(obj, function(value, index, list) {
        if (predicate(value, index, list)) results.push(value);
      });
      return results;
    }

    // Return all the elements for which a truth test fails.
    function reject(obj, predicate, context) {
      return filter(obj, negate(cb(predicate)), context);
    }

    // Determine whether all of the elements pass a truth test.
    function every(obj, predicate, context) {
      predicate = cb(predicate, context);
      var _keys = !isArrayLike$2(obj) && keys$2(obj),
          length = (_keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = _keys ? _keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj)) return false;
      }
      return true;
    }

    // Determine if at least one element in the object passes a truth test.
    function some(obj, predicate, context) {
      predicate = cb(predicate, context);
      var _keys = !isArrayLike$2(obj) && keys$2(obj),
          length = (_keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = _keys ? _keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj)) return true;
      }
      return false;
    }

    // Determine if the array or object contains a given item (using `===`).
    function contains$1(obj, item, fromIndex, guard) {
      if (!isArrayLike$2(obj)) obj = values(obj);
      if (typeof fromIndex != 'number' || guard) fromIndex = 0;
      return indexOf(obj, item, fromIndex) >= 0;
    }

    // Invoke a method (with arguments) on every item in a collection.
    var invoke = restArguments(function(obj, path, args) {
      var contextPath, func;
      if (isFunction$4(path)) {
        func = path;
      } else {
        path = toPath(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });

    // Convenience version of a common use case of `_.map`: fetching a property.
    function pluck(obj, key) {
      return map(obj, property(key));
    }

    // Convenience version of a common use case of `_.filter`: selecting only
    // objects containing specific `key:value` pairs.
    function where(obj, attrs) {
      return filter(obj, matcher(attrs));
    }

    // Return the maximum element (or element-based computation).
    function max$1(obj, iteratee, context) {
      var result = -Infinity, lastComputed = -Infinity,
          value, computed;
      if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
        obj = isArrayLike$2(obj) ? obj : values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    }

    // Return the minimum element (or element-based computation).
    function min$1(obj, iteratee, context) {
      var result = Infinity, lastComputed = Infinity,
          value, computed;
      if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
        obj = isArrayLike$2(obj) ? obj : values(obj);
        for (var i = 0, length = obj.length; i < length; i++) {
          value = obj[i];
          if (value != null && value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        each(obj, function(v, index, list) {
          computed = iteratee(v, index, list);
          if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
            result = v;
            lastComputed = computed;
          }
        });
      }
      return result;
    }

    // Safely create a real, live array from anything iterable.
    var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    function toArray(obj) {
      if (!obj) return [];
      if (isArray$5(obj)) return slice.call(obj);
      if (isString(obj)) {
        // Keep surrogate pair characters together.
        return obj.match(reStrSymbol);
      }
      if (isArrayLike$2(obj)) return map(obj, identity);
      return values(obj);
    }

    // Sample **n** random values from a collection using the modern version of the
    // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    // If **n** is not specified, returns a single random element.
    // The internal `guard` argument allows it to work with `_.map`.
    function sample(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike$2(obj)) obj = values(obj);
        return obj[random$1(obj.length - 1)];
      }
      var sample = toArray(obj);
      var length = getLength(sample);
      n = Math.max(Math.min(n, length), 0);
      var last = length - 1;
      for (var index = 0; index < n; index++) {
        var rand = random$1(index, last);
        var temp = sample[index];
        sample[index] = sample[rand];
        sample[rand] = temp;
      }
      return sample.slice(0, n);
    }

    // Shuffle a collection.
    function shuffle(obj) {
      return sample(obj, Infinity);
    }

    // Sort the object's values by a criterion produced by an iteratee.
    function sortBy(obj, iteratee, context) {
      var index = 0;
      iteratee = cb(iteratee, context);
      return pluck(map(obj, function(value, key, list) {
        return {
          value: value,
          index: index++,
          criteria: iteratee(value, key, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
      }), 'value');
    }

    // An internal function used for aggregate "group by" operations.
    function group(behavior, partition) {
      return function(obj, iteratee, context) {
        var result = partition ? [[], []] : {};
        iteratee = cb(iteratee, context);
        each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    }

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    var groupBy = group(function(result, value, key) {
      if (has$1(result, key)) result[key].push(value); else result[key] = [value];
    });

    // Indexes the object's values by a criterion, similar to `_.groupBy`, but for
    // when you know that your index values will be unique.
    var indexBy = group(function(result, value, key) {
      result[key] = value;
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    var countBy = group(function(result, value, key) {
      if (has$1(result, key)) result[key]++; else result[key] = 1;
    });

    // Split a collection into two arrays: one whose elements all pass the given
    // truth test, and one whose elements all do not pass the truth test.
    var partition = group(function(result, value, pass) {
      result[pass ? 0 : 1].push(value);
    }, true);

    // Return the number of elements in a collection.
    function size(obj) {
      if (obj == null) return 0;
      return isArrayLike$2(obj) ? obj.length : keys$2(obj).length;
    }

    // Internal `_.pick` helper function to determine whether `key` is an enumerable
    // property name of `obj`.
    function keyInObj(value, key, obj) {
      return key in obj;
    }

    // Return a copy of the object only containing the allowed properties.
    var pick = restArguments(function(obj, keys) {
      var result = {}, iteratee = keys[0];
      if (obj == null) return result;
      if (isFunction$4(iteratee)) {
        if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
        keys = allKeys(obj);
      } else {
        iteratee = keyInObj;
        keys = flatten$1(keys, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
      return result;
    });

    // Return a copy of the object without the disallowed properties.
    var omit = restArguments(function(obj, keys) {
      var iteratee = keys[0], context;
      if (isFunction$4(iteratee)) {
        iteratee = negate(iteratee);
        if (keys.length > 1) context = keys[1];
      } else {
        keys = map(flatten$1(keys, false, false), String);
        iteratee = function(value, key) {
          return !contains$1(keys, key);
        };
      }
      return pick(obj, iteratee, context);
    });

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N.
    function initial(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    }

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. The **guard** check allows it to work with `_.map`.
    function first(array, n, guard) {
      if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
      if (n == null || guard) return array[0];
      return initial(array, array.length - n);
    }

    // Returns everything but the first entry of the `array`. Especially useful on
    // the `arguments` object. Passing an **n** will return the rest N values in the
    // `array`.
    function rest(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    }

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array.
    function last(array, n, guard) {
      if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
      if (n == null || guard) return array[array.length - 1];
      return rest(array, Math.max(0, array.length - n));
    }

    // Trim out all falsy values from an array.
    function compact(array) {
      return filter(array, Boolean);
    }

    // Flatten out an array, either recursively (by default), or up to `depth`.
    // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
    function flatten(array, depth) {
      return flatten$1(array, depth, false);
    }

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    var difference = restArguments(function(array, rest) {
      rest = flatten$1(rest, true, true);
      return filter(array, function(value){
        return !contains$1(rest, value);
      });
    });

    // Return a version of the array that does not contain the specified value(s).
    var without = restArguments(function(array, otherArrays) {
      return difference(array, otherArrays);
    });

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // The faster algorithm will not work with an iteratee if the iteratee
    // is not a one-to-one function, so providing an iteratee will disable
    // the faster algorithm.
    function uniq(array, isSorted, iteratee, context) {
      if (!isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null) iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0, length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted && !iteratee) {
          if (!i || seen !== computed) result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!contains$1(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!contains$1(result, value)) {
          result.push(value);
        }
      }
      return result;
    }

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    var union = restArguments(function(arrays) {
      return uniq(flatten$1(arrays, true, true));
    });

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    function intersection(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0, length = getLength(array); i < length; i++) {
        var item = array[i];
        if (contains$1(result, item)) continue;
        var j;
        for (j = 1; j < argsLength; j++) {
          if (!contains$1(arguments[j], item)) break;
        }
        if (j === argsLength) result.push(item);
      }
      return result;
    }

    // Complement of zip. Unzip accepts an array of arrays and groups
    // each array's elements on shared indices.
    function unzip(array) {
      var length = (array && max$1(array, getLength).length) || 0;
      var result = Array(length);

      for (var index = 0; index < length; index++) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    var zip = restArguments(unzip);

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values. Passing by pairs is the reverse of `_.pairs`.
    function object(list, values) {
      var result = {};
      for (var i = 0, length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    }

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](https://docs.python.org/library/functions.html#range).
    function range(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      if (!step) {
        step = stop < start ? -1 : 1;
      }

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    }

    // Chunk a single array into multiple arrays, each containing `count` or fewer
    // items.
    function chunk(array, count) {
      if (count == null || count < 1) return [];
      var result = [];
      var i = 0, length = array.length;
      while (i < length) {
        result.push(slice.call(array, i, i += count));
      }
      return result;
    }

    // Helper function to continue chaining intermediate results.
    function chainResult(instance, obj) {
      return instance._chain ? _$1(obj).chain() : obj;
    }

    // Add your own custom functions to the Underscore object.
    function mixin(obj) {
      each(functions(obj), function(name) {
        var func = _$1[name] = obj[name];
        _$1.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return chainResult(this, func.apply(_$1, args));
        };
      });
      return _$1;
    }

    // Add all mutator `Array` functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _$1.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === 'shift' || name === 'splice') && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });

    // Add all accessor `Array` functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _$1.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });

    // Named Exports

    var allExports = /*#__PURE__*/Object.freeze({
        __proto__: null,
        VERSION: VERSION,
        restArguments: restArguments,
        isObject: isObject$3,
        isNull: isNull,
        isUndefined: isUndefined,
        isBoolean: isBoolean,
        isElement: isElement,
        isString: isString,
        isNumber: isNumber,
        isDate: isDate,
        isRegExp: isRegExp,
        isError: isError,
        isSymbol: isSymbol,
        isArrayBuffer: isArrayBuffer,
        isDataView: isDataView$1,
        isArray: isArray$5,
        isFunction: isFunction$4,
        isArguments: isArguments$3,
        isFinite: isFinite$1,
        isNaN: isNaN$1,
        isTypedArray: isTypedArray$4,
        isEmpty: isEmpty,
        isMatch: isMatch,
        isEqual: isEqual$1,
        isMap: isMap,
        isWeakMap: isWeakMap,
        isSet: isSet,
        isWeakSet: isWeakSet,
        keys: keys$2,
        allKeys: allKeys,
        values: values,
        pairs: pairs,
        invert: invert,
        functions: functions,
        methods: functions,
        extend: extend,
        extendOwn: extendOwn,
        assign: extendOwn,
        defaults: defaults,
        create: create,
        clone: clone$1,
        tap: tap,
        get: get$1,
        has: has,
        mapObject: mapObject,
        identity: identity,
        constant: constant,
        noop: noop,
        toPath: toPath$1,
        property: property,
        propertyOf: propertyOf,
        matcher: matcher,
        matches: matcher,
        times: times,
        random: random$1,
        now: now,
        escape: escape,
        unescape: unescape,
        templateSettings: templateSettings,
        template: template,
        result: result,
        uniqueId: uniqueId,
        chain: chain,
        iteratee: iteratee,
        partial: partial,
        bind: bind,
        bindAll: bindAll,
        memoize: memoize,
        delay: delay,
        defer: defer,
        throttle: throttle,
        debounce: debounce,
        wrap: wrap,
        negate: negate,
        compose: compose,
        after: after,
        before: before,
        once: once,
        findKey: findKey,
        findIndex: findIndex,
        findLastIndex: findLastIndex,
        sortedIndex: sortedIndex,
        indexOf: indexOf,
        lastIndexOf: lastIndexOf,
        find: find,
        detect: find,
        findWhere: findWhere,
        each: each,
        forEach: each,
        map: map,
        collect: map,
        reduce: reduce,
        foldl: reduce,
        inject: reduce,
        reduceRight: reduceRight,
        foldr: reduceRight,
        filter: filter,
        select: filter,
        reject: reject,
        every: every,
        all: every,
        some: some,
        any: some,
        contains: contains$1,
        includes: contains$1,
        include: contains$1,
        invoke: invoke,
        pluck: pluck,
        where: where,
        max: max$1,
        min: min$1,
        shuffle: shuffle,
        sample: sample,
        sortBy: sortBy,
        groupBy: groupBy,
        indexBy: indexBy,
        countBy: countBy,
        partition: partition,
        toArray: toArray,
        size: size,
        pick: pick,
        omit: omit,
        first: first,
        head: first,
        take: first,
        initial: initial,
        last: last,
        rest: rest,
        tail: rest,
        drop: rest,
        compact: compact,
        flatten: flatten,
        without: without,
        uniq: uniq,
        unique: uniq,
        union: union,
        intersection: intersection,
        difference: difference,
        unzip: unzip,
        transpose: unzip,
        zip: zip,
        object: object,
        range: range,
        chunk: chunk,
        mixin: mixin,
        'default': _$1
    });

    // Default Export

    // Add all of the Underscore functions to the wrapper object.
    var _ = mixin(allExports);
    // Legacy Node.js API.
    _._ = _;

    /*
     * Dataset class
     * @class dw.Dataset
     *
     * @param {dw.Column[]} columns
     */

    function Dataset(columns) {
      // make column names unique
      const columnsByName = {};
      const origColumns = columns.slice(0);
      columns.forEach(col => {
        uniqueName(col);
        columnsByName[col.name()] = col;
      }); // sets a unique name for a column

      function uniqueName(col) {
        const origColName = col.name();
        let baseColName, suffix, colName;

        if (origColName) {
          baseColName = origColName;
          suffix = 0;
          colName = baseColName;
        } else {
          baseColName = 'X';
          suffix = 1;
          colName = `${baseColName}.${suffix}`;
        }

        while (Object.prototype.hasOwnProperty.call(columnsByName, colName)) {
          colName = `${baseColName}.${++suffix}`;
        }

        if (colName !== origColName) {
          col.name(colName, origColName);
        }
      } // public interface


      const dataset = {
        /**
         * returns all columns of the dataset
         * @returns {dw.Column[]}
         */
        columns() {
          return columns;
        },

        /**
         * returns a specific column by name or index
         *
         * @param {string|number} nameOrIndex -- the name or index of the column to return
         * @returns {dw.Column}
         */
        column(nameOrIndex) {
          if (isString(nameOrIndex)) {
            // single column by name
            if (columnsByName[nameOrIndex] !== undefined) return columnsByName[nameOrIndex];
            throw new Error('No column found with that name: "' + nameOrIndex + '"');
          } else {
            if (nameOrIndex < 0) {
              return;
            }
          } // single column by index


          if (columns[nameOrIndex] !== undefined) return columns[nameOrIndex];
          throw new Error('No column found with that name or index: ' + nameOrIndex);
        },

        /**
         * returns the number of columns in the dataset
         * @returns {number}
         */
        numColumns() {
          return columns.length;
        },

        /**
         * returns the number of rows in the dataset
         * @returns {number}
         */
        numRows() {
          return columns.length ? columns[0].length : 0;
        },

        /** calls a function for each column of the dataset */
        eachColumn(func) {
          columns.forEach(func);
        },

        /**
         * tests if a column name or index exists
         *
         * @param {string|number} nameOrIndex -- the name or index of the column
         * @returns {boolean}
         */
        hasColumn(nameOrIndex) {
          return (isString(nameOrIndex) ? columnsByName[nameOrIndex] : columns[nameOrIndex]) !== undefined;
        },

        /**
         * returns the index of a column
         * @param {string} columnName
         * @returns {number}
         */
        indexOf(columnName) {
          if (!dataset.hasColumn(columnName)) return -1;
          return columns.indexOf(columnsByName[columnName]);
        },

        /**
         * returns a D3 friendly list of plain objects
         * @returns {object[]}
         */
        list() {
          return range(columns[0].length).map(dataset.row);
        },

        /**
         * returns an object containing the column values of the row
         * @param {number} index the row index
         * @returns {object}
         */
        row(index) {
          if (index >= columns[0].length) {
            return {};
          }

          const o = {};
          columns.forEach(col => {
            o[col.name()] = col.val(index);
          });
          return o;
        },

        /**
         * returns a CSV string representation of the dataset
         * @param {Object} opt -- options
         * @param {boolean} [opt.includeComputedColumns=true] -- include computed columns in the CSV
         * @param {boolean} [opt.includeHeader=true] -- include header row in the CSV
         * @param {string} [opt.numeral=null] -- format numbers using this Numeral.js instance
         * @returns {string}
         */
        csv() {
          let {
            includeComputedColumns = true,
            includeHeader = true,
            numeral = null,
            ...opts
          } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          const numRows = dataset.numRows();
          const filteredColumns = includeComputedColumns ? columns : columns.filter(col => !col.isComputed);
          const table = filteredColumns.map(col => [...(includeHeader ? [col.title()] : []), ...col.formatted(numeral)]);
          const rows = table[0].map((_, i) => table.map(row => row[i])).slice(0, numRows + 1);

          if (!opts.delimiter && numeral) {
            opts.delimiter = guessDelimiterFromLocale(numeral);
          }

          return formatDelimited(rows, opts);
        },

        /**
         * @alias csv
         * @deprecated
         */
        toCSV() {
          return this.csv(...arguments);
        },

        /**
         * removes ignored columns from dataset
         * @param {object} ignore -- object of column names to ignore
         */
        filterColumns(ignore) {
          columns = columns.filter(c => !ignore[c.name()]);
          each(ignore, (ign, key) => {
            if (ign && columnsByName[key]) delete columnsByName[key];
          });
          return dataset;
        },

        /**
         * executes func for each row of the dataset
         */
        eachRow(func) {
          var i;

          for (i = 0; i < dataset.numRows(); i++) {
            func(i);
          }

          return dataset;
        },

        /**
         * adds a new column to the dataset
         * @param {dw.Column} column
         */
        add(column) {
          uniqueName(column);
          columns.push(column);
          columnsByName[column.name()] = column;
          origColumns.push(column);
          return dataset;
        },

        /**
         * cuts each column in the dataset to a maximum number of rows
         * @param {number} numRows
         * @returns {dw.Dataset}
         */
        limitRows(numRows) {
          columns.forEach(col => {
            col.limitRows(numRows);
          });
          return dataset;
        },

        /**
         * cuts the number of columns to a maximum value
         * @param {number} numCols
         * @returns {dw.Dataset}
         */
        limitColumns(numCols) {
          if (columns.length > numCols) {
            columns.length = numCols;
            origColumns.length = numCols;
          }

          return dataset;
        },

        /**
         * Sorts columns according to give `sortOrder`.
         *
         * Columns that don't appear in `sortOrder` will be put at the end.
         *
         * @param {number[]} sortOrder -- array of original column indexes in the desired order
         */
        columnOrder(sortOrder) {
          if (arguments.length) {
            const columnsWithNewIndexes = columns.map((column, i) => {
              const newIndex = sortOrder.indexOf(i);
              return [column, newIndex !== -1 ? newIndex : columns.length];
            });
            columns = columnsWithNewIndexes.sort((a, b) => a[1] - b[1]).map(x => x[0]);
            return dataset;
          }

          return columns.map(function (c) {
            return origColumns.indexOf(c);
          });
        },

        /**
         * make sure all columns have the same number of rows
         *
         * pad with empty string by default, because that's a neutral value that doesn't make the
         * cell invalid
         *
         * @param {*} [value=''] -- pad short columns with this value
         */
        align() {
          let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          const maxNumRows = Math.max(...columns.map(column => column.length));

          for (const column of columns) {
            const padding = Array(maxNumRows - column.length).fill(value);
            column.add(...padding);
          }
        },

        /**
         * create a copy of the dataset
         * @returns {dw.Dataset}
         */
        clone() {
          return Dataset(columns.map(column => column.clone()));
        },

        /**
         * remove all rows from all columns of the dataset
         */
        clear() {
          for (const column of columns) {
            column.clear();
          }
        },

        /**
         * deletes one or more rows from dataset
         * @param {...number} rowIndex
         * @returns {dw.Dataset}
         */
        deleteRow() {
          for (var _len = arguments.length, rowIndexes = new Array(_len), _key = 0; _key < _len; _key++) {
            rowIndexes[_key] = arguments[_key];
          }

          rowIndexes.sort();

          for (const column of columns) {
            let numDeleted = 0;
            rowIndexes.forEach(rowIndex => {
              const deletedRows = column.deleteRow(rowIndex - numDeleted);
              numDeleted += deletedRows.length;
            });
          }

          return dataset;
        }

      };
      return dataset;
    }

    function text () {
      return {
        parse: identity,
        errors: function () {
          return 0;
        },
        name: function () {
          return 'text';
        },
        isValid: function () {
          return true;
        },
        format: function () {}
      };
    }

    /* eslint no-irregular-whitespace: "off" */
    /*
     * A type for numbers:
     *
     * Usage:
     * var parse = dw.type.number(sampleData);
     * parse()
     */

    function number (sample) {
      let format;
      let errors = 0;
      const knownFormats = {
        '-.': /^ *[-–—−]?[0-9]*(\.[0-9]+)?(e[+-][0-9]+)?%? *$/,
        '-,': /^ *[-–—−]?[0-9]*(,[0-9]+)?%? *$/,
        ',.': /^ *[-–—−]?[0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?%? *$/,
        '.,': /^ *[-–—−]?[0-9]{1,3}(\.[0-9]{3})*(,[0-9]+)?%? *$/,
        ' .': /^ *[-–—−]?[0-9]{1,3}([   ][0-9]{3})*(\.[0-9]+)?%? *$/,
        ' ,': /^ *[-–—−]?[0-9]{1,3}([   ][0-9]{3})*(,[0-9]+)?%? *$/,
        // excel sometimes produces a strange white-space:
        "'.": /^ *[-–—−]?[0-9]{1,3}('[0-9]{3})*(\.[0-9]+)?%? *$/
      };
      const formatLabels = {
        '-.': '1234.56',
        '-,': '1234,56',
        ',.': '1,234.56',
        '.,': '1.234,56',
        ' .': '1 234.56',
        ' ,': '1 234,56',
        // excel sometimes produces a strange white-space:
        ' .': '1 234.56',
        ' ,': '1 234,56',
        ' .': '1 234.56',
        ' ,': '1 234,56'
      }; // a list of strings that are recognized as 'not available'

      const naStrings = {
        na: 1,
        'n/a': 1,
        '-': 1,
        ':': 1
      };
      const matches = {};
      const bestMatch = ['-.', 0];
      sample = sample || [];
      each(sample, function (n) {
        each(knownFormats, function (regex, fmt) {
          if (matches[fmt] === undefined) matches[fmt] = 0;

          if (regex.test(n)) {
            matches[fmt] += 1;

            if (matches[fmt] > bestMatch[1]) {
              bestMatch[0] = fmt;
              bestMatch[1] = matches[fmt];
            }
          }
        });
      });
      format = bestMatch[0]; // public interface

      var type = {
        parse: function (raw) {
          if (isNumber(raw) || isUndefined(raw) || isNull(raw)) return raw; // replace percent sign, n-dash & m-dash, remove weird spaces

          var number = raw.replace('%', '').replace('−', '-').replace(/[   ]/g, '').replace('–', '-').replace('—', '-'); // normalize number

          if (format[0] !== '-') {
            // remove kilo seperator
            number = number.replace(new RegExp(format[0] === '.' ? '\\.' : format[0], 'g'), '');
          }

          if (format[1] !== '.') {
            // replace decimal char w/ point
            number = number.replace(format[1], '.');
          }

          if (isNaN(number) || number === '') {
            if (!naStrings[number.toLowerCase()] && number !== '') errors++;
            return raw;
          }

          return Number(number);
        },
        toNum: function (i) {
          return i;
        },
        fromNum: function (i) {
          return i;
        },
        errors: function () {
          return errors;
        },
        name: function () {
          return 'number';
        },
        isValid: function (val) {
          return val === '' || naStrings[String(val).toLowerCase()] || isNumber(type.parse(val));
        },
        ambiguousFormats: function () {
          var candidates = [];
          each(matches, function (cnt, fmt) {
            if (cnt === bestMatch[1]) {
              candidates.push([fmt, formatLabels[fmt]]); // key, label
            }
          });
          return candidates;
        },
        format: function (fmt) {
          if (arguments.length) {
            format = fmt;
            return type;
          }

          return format;
        }
      };
      return type;
    }

    const begin = /^ */.source;
    const end = /[*']* *$/.source;
    const s0 = /[ \-/.]?/.source; // optional separator

    const s1 = /[ \-/.]/.source; // mandatory separator

    const s2 = /[ \-/.;,]/.source; // mandatory separator

    const s3 = /[ \-|T]/.source; // mandatory separator

    const sM = /[ \-/.m]/.source; // mandatory separator

    const rx = {
      YY: {
        parse: /['’‘]?(\d{2})/
      },
      YYYY: {
        test: /([12]\d{3})/,
        parse: /(\d{4})/
      },
      YYYY2: {
        test: /(?:1[7-9]|20)\d{2}/,
        parse: /(\d{4})/
      },
      H: {
        parse: /h([12])/
      },
      Q: {
        parse: /q([1234])/
      },
      W: {
        parse: /w([0-5]?[0-9])/
      },
      MM: {
        test: /(0?[1-9]|1[0-2])/,
        parse: /(0?[1-9]|1[0-2])/
      },
      DD: {
        parse: /(0?[1-9]|[1-2][0-9]|3[01])/
      },
      DOW: {
        parse: /([0-7])/
      },
      HHMM: {
        parse: /(0?\d|1\d|2[0-3]):([0-5]\d)(?::([0-5]\d))? *(am|pm)?/
      }
    };
    const MONTHS = {
      // feel free to add more localized month names
      0: ['jan', 'january', 'januar', 'jänner', 'jän', 'janv', 'janvier', 'ene', 'enero', 'gen', 'gennaio', 'janeiro'],
      1: ['feb', 'february', 'febr', 'februar', 'fév', 'févr', 'février', 'febrero', 'febbraio', 'fev', 'fevereiro'],
      2: ['mar', 'mär', 'march', 'mrz', 'märz', 'mars', 'mars', 'marzo', 'marzo', 'março'],
      3: ['apr', 'april', 'apr', 'april', 'avr', 'avril', 'abr', 'abril', 'aprile'],
      4: ['may', 'mai', 'mayo', 'mag', 'maggio', 'maio', 'maj'],
      5: ['jun', 'june', 'juni', 'juin', 'junio', 'giu', 'giugno', 'junho'],
      6: ['jul', 'july', 'juli', 'juil', 'juillet', 'julio', 'lug', 'luglio', 'julho'],
      7: ['aug', 'august', 'août', 'ago', 'agosto'],
      8: ['sep', 'september', 'sept', 'septembre', 'septiembre', 'set', 'settembre', 'setembro'],
      9: ['oct', 'october', 'okt', 'oktober', 'octobre', 'octubre', 'ott', 'ottobre', 'out', 'outubro'],
      10: ['nov', 'november', 'november', 'novembre', 'noviembre', 'novembre', 'novembro'],
      11: ['dec', 'december', 'dez', 'des', 'dezember', 'déc', 'décembre', 'dic', 'diciembre', 'dicembre', 'desember', 'dezembro']
    };
    const shortMonthKey = {};
    each(MONTHS, function (abbr, m) {
      each(abbr, function (a) {
        shortMonthKey[a] = m;
      });
    });
    rx.MMM = {
      parse: new RegExp('(' + flatten(values(MONTHS)).join('|') + ')')
    };
    each(rx, function (r) {
      r.parse = r.parse.source;
      if (isRegExp(r.test)) r.test = r.test.source;else r.test = r.parse;
    });
    var knownFormats = {
      // each format has two regex, a strict one for format guessing
      // based on a sample and a lazy one for parsing
      YYYY: {
        test: reg(rx.YYYY2.test),
        parse: reg(rx.YYYY2.parse),
        precision: 'year'
      },
      'YYYY-H': {
        test: reg(rx.YYYY.test, s0, rx.H.test),
        parse: reg(rx.YYYY.parse, s0, rx.H.parse),
        precision: 'half'
      },
      'H-YYYY': {
        test: reg(rx.H.test, s1, rx.YYYY.test),
        parse: reg(rx.H.parse, s1, rx.YYYY.parse),
        precision: 'half'
      },
      'YYYY-Q': {
        test: reg(rx.YYYY.test, s0, rx.Q.test),
        parse: reg(rx.YYYY.parse, s0, rx.Q.parse),
        precision: 'quarter'
      },
      'Q-YYYY': {
        test: reg(rx.Q.test, s1, rx.YYYY.test),
        parse: reg(rx.Q.parse, s1, rx.YYYY.parse),
        precision: 'quarter'
      },
      'YYYY-M': {
        test: reg(rx.YYYY.test, sM, rx.MM.test),
        parse: reg(rx.YYYY.parse, sM, rx.MM.parse),
        precision: 'month'
      },
      'M-YYYY': {
        test: reg(rx.MM.test, s1, rx.YYYY.test),
        parse: reg(rx.MM.parse, s1, rx.YYYY.parse),
        precision: 'month'
      },
      'YYYY-MMM': {
        test: reg(rx.YYYY.test, s1, rx.MMM.parse),
        parse: reg(rx.YYYY.parse, s1, rx.MMM.parse),
        precision: 'month'
      },
      'MMM-YYYY': {
        test: reg(rx.MMM.parse, s1, rx.YYYY.test),
        parse: reg(rx.MMM.parse, s1, rx.YYYY.parse),
        precision: 'month'
      },
      'MMM-YY': {
        test: reg(rx.MMM.parse, s1, rx.YY.test),
        parse: reg(rx.MMM.parse, s1, rx.YY.parse),
        precision: 'month'
      },
      MMM: {
        test: reg(rx.MMM.parse),
        parse: reg(rx.MMM.parse),
        precision: 'month'
      },
      'YYYY-WW': {
        test: reg(rx.YYYY.test, s0, rx.W.test),
        parse: reg(rx.YYYY.parse, s0, rx.W.parse),
        precision: 'week'
      },
      'WW-YYYY': {
        test: reg(rx.W.test, s1, rx.YYYY.test),
        parse: reg(rx.W.parse, s1, rx.YYYY.parse),
        precision: 'week'
      },
      'MM/DD/YYYY': {
        test: reg(rx.MM.test, '([\\-\\/])', rx.DD.test, '\\2', rx.YYYY.test),
        parse: reg(rx.MM.parse, '([\\-\\/])', rx.DD.parse, '\\2', rx.YYYY.parse),
        precision: 'day'
      },
      'MM/DD/YY': {
        test: reg(rx.MM.test, '([\\-\\/])', rx.DD.test, '\\2', rx.YY.test),
        parse: reg(rx.MM.parse, '([\\-\\/])', rx.DD.parse, '\\2', rx.YY.parse),
        precision: 'day'
      },
      'DD/MM/YY': {
        test: reg(rx.DD.test, '([\\-\\.\\/ ?])', rx.MM.test, '\\2', rx.YY.test),
        parse: reg(rx.DD.parse, '([\\-\\.\\/ ?])', rx.MM.parse, '\\2', rx.YY.parse),
        precision: 'day'
      },
      'DD/MM/YYYY': {
        test: reg(rx.DD.test, '([\\-\\.\\/ ?])', rx.MM.test, '\\2', rx.YYYY.test),
        parse: reg(rx.DD.parse, '([\\-\\.\\/ ?])', rx.MM.parse, '\\2', rx.YYYY.parse),
        precision: 'day'
      },
      'DD/MMM/YYYY': {
        test: reg(rx.DD.test, '([\\-\\.\\/ ?])', rx.MMM.test, '\\2', rx.YYYY.test),
        parse: reg(rx.DD.parse, '([\\-\\.\\/ ?])', rx.MMM.parse, '\\2', rx.YYYY.parse),
        precision: 'day'
      },
      'DD/MMM/YY': {
        test: reg(rx.DD.test, '([\\-\\.\\/ ?])', rx.MMM.test, '\\2', rx.YY.test),
        parse: reg(rx.DD.parse, '([\\-\\.\\/ ?])', rx.MMM.parse, '\\2', rx.YY.parse),
        precision: 'day'
      },
      'YYYY-MM-DD': {
        test: reg(rx.YYYY.test, '([\\-\\.\\/ ?])', rx.MM.test, '\\2', rx.DD.test),
        parse: reg(rx.YYYY.parse, '([\\-\\.\\/ ?])', rx.MM.parse, '\\2', rx.DD.parse),
        precision: 'day'
      },
      'MMM-DD-YYYY': {
        test: reg(rx.MMM.test, s1, rx.DD.test, s2, rx.YYYY.test),
        parse: reg(rx.MMM.parse, s1, rx.DD.parse, s2, rx.YYYY.parse),
        precision: 'day'
      },
      'YYYY-WW-d': {
        // year + ISO week + [day]
        test: reg(rx.YYYY.test, s0, rx.W.test, s1, rx.DOW.test),
        parse: reg(rx.YYYY.parse, s0, rx.W.parse, s1, rx.DOW.parse),
        precision: 'day'
      },
      // dates with a time
      'MM/DD/YYYY HH:MM': {
        test: reg(rx.MM.test, '([\\-\\/])', rx.DD.test, '\\2', rx.YYYY.test, s3, rx.HHMM.test),
        parse: reg(rx.MM.parse, '([\\-\\/])', rx.DD.parse, '\\2', rx.YYYY.parse, s3, rx.HHMM.parse),
        precision: 'day-minutes'
      },
      'DD.MM.YYYY HH:MM': {
        test: reg(rx.DD.test, '([\\-\\.\\/ ?])', rx.MM.test, '\\2', rx.YYYY.test, s3, rx.HHMM.test),
        parse: reg(rx.DD.parse, '([\\-\\.\\/ ?])', rx.MM.parse, '\\2', rx.YYYY.parse, s3, rx.HHMM.parse),
        precision: 'day-minutes'
      },
      'YYYY-MM-DD HH:MM': {
        test: reg(rx.YYYY.test, '([\\-\\.\\/ ?])', rx.MM.test, '\\2', rx.DD.test, s3, rx.HHMM.test),
        parse: reg(rx.YYYY.parse, '([\\-\\.\\/ ?])', rx.MM.parse, '\\2', rx.DD.parse, s3, rx.HHMM.parse),
        precision: 'day-minutes'
      },
      ISO8601: {
        test: /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(\.\d+)?([+-][0-2]\d:[0-5]\d|Z)/,
        parse: function (str) {
          return str;
        },
        precision: 'day-seconds'
      }
    };

    function reg() {
      return new RegExp(begin + Array.prototype.slice.call(arguments).join(' *') + end, 'i');
    }

    function test(str, key) {
      var fmt = knownFormats[key];

      if (isRegExp(fmt.test)) {
        return fmt.test.test(str);
      } else {
        return fmt.test(str, key);
      }
    }

    function parse(str, key) {
      var fmt = knownFormats[key];

      if (isRegExp(fmt.parse)) {
        return str.match(fmt.parse);
      } else {
        return fmt.parse(str, key);
      }
    }

    function dateFromIsoWeek(year, week, day) {
      var d = new Date(Date.UTC(year, 0, 3));
      d.setUTCDate(3 - d.getUTCDay() + (week - 1) * 7 + parseInt(day, 10));
      return d;
    }

    function hour(hr, amPm) {
      if (hr !== 12) return hr + (amPm === 'pm' ? 12 : 0);
      return amPm === 'am' ? 0 : 12;
    }

    function date (sample) {
      let format;
      let errors = 0;
      const matches = {};
      const bestMatch = ['', 0];
      sample = sample || [];
      each(knownFormats, function (format, key) {
        each(sample, function (n) {
          if (matches[key] === undefined) matches[key] = 0;

          if (test(n, key)) {
            matches[key] += 1;

            if (matches[key] > bestMatch[1]) {
              bestMatch[0] = key;
              bestMatch[1] = matches[key];
            }
          }
        });
      });
      format = bestMatch[0]; // public interface

      const type = {
        parse: function (raw) {
          if (isDate(raw) || isUndefined(raw)) return raw;

          if (!format || !isString(raw)) {
            errors++;
            return raw;
          }

          var m = parse(raw.toLowerCase(), format);

          if (!m) {
            errors++;
            return raw;
          } else {
            // increment errors anyway if string doesn't match strict format
            if (!test(raw, format)) errors++;
          }

          function guessTwoDigitYear(yr) {
            yr = +yr;
            if (yr < 30) return 2000 + yr;else return 1900 + yr;
          }

          var curYear = new Date().getFullYear();

          switch (format) {
            case 'YYYY':
              return new Date(m[1], 0, 1);

            case 'YYYY-H':
              return new Date(m[1], (m[2] - 1) * 6, 1);

            case 'H-YYYY':
              return new Date(m[2], (m[1] - 1) * 6, 1);

            case 'YYYY-Q':
              return new Date(m[1], (m[2] - 1) * 3, 1);

            case 'Q-YYYY':
              return new Date(m[2], (m[1] - 1) * 3, 1);

            case 'YYYY-M':
              return new Date(m[1], m[2] - 1, 1);

            case 'M-YYYY':
              return new Date(m[2], m[1] - 1, 1);

            case 'YYYY-MMM':
              return new Date(+m[1], shortMonthKey[m[2]], 1);

            case 'MMM-YYYY':
              return new Date(+m[2], shortMonthKey[m[1]], 1);

            case 'MMM-YY':
              return new Date(guessTwoDigitYear(+m[2]), shortMonthKey[m[1]], 1);

            case 'MMM':
              return new Date(curYear, shortMonthKey[m[1]], 1);

            case 'YYYY-WW':
              return dateFromIsoWeek(m[1], m[2], 1);

            case 'WW-YYYY':
              return dateFromIsoWeek(m[2], m[1], 1);

            case 'YYYY-WW-d':
              return dateFromIsoWeek(m[1], m[2], m[3]);

            case 'YYYY-MM-DD':
              return new Date(m[1], m[3] - 1, m[4]);

            case 'DD/MM/YYYY':
              return new Date(m[4], m[3] - 1, m[1]);

            case 'DD/MMM/YYYY':
              return new Date(m[4], shortMonthKey[m[3]], m[1]);

            case 'DD/MMM/YY':
              return new Date(guessTwoDigitYear(m[4]), shortMonthKey[m[3]], m[1]);

            case 'MM/DD/YYYY':
              return new Date(m[4], m[1] - 1, m[3]);

            case 'MM/DD/YY':
              return new Date(guessTwoDigitYear(m[4]), m[1] - 1, m[3]);

            case 'DD/MM/YY':
              return new Date(guessTwoDigitYear(m[4]), m[3] - 1, m[1]);

            case 'MMM-DD-YYYY':
              return new Date(m[3], shortMonthKey[m[1]], m[2]);

            case 'YYYY-MM-DD HH:MM':
              return new Date(+m[1], m[3] - 1, +m[4], hour(+m[5], m[8]), +m[6] || 0, +m[7] || 0);

            case 'DD.MM.YYYY HH:MM':
              return new Date(+m[4], m[3] - 1, +m[1], hour(+m[5], m[8]), +m[6] || 0, +m[7] || 0);

            case 'MM/DD/YYYY HH:MM':
              return new Date(+m[4], m[1] - 1, +m[3], hour(+m[5], m[8]), +m[6] || 0, +m[7] || 0);

            case 'ISO8601':
              return new Date(m.toUpperCase());

            default:
              console.warn('unknown format', format);
          }

          errors++;
          return raw;
        },
        toNum: function (d) {
          return isDate(d) ? d.getTime() : Number.NaN;
        },
        fromNum: function (i) {
          return new Date(i);
        },
        errors: function () {
          return errors;
        },
        name: function () {
          return 'date';
        },
        format: function (fmt) {
          if (arguments.length) {
            format = fmt;
            return type;
          }

          return format;
        },
        precision: function () {
          return knownFormats[format].precision;
        },
        isValid: function (val) {
          return isDate(type.parse(val));
        },
        ambiguousFormats: function () {
          var candidates = [];
          each(matches, function (cnt, fmt) {
            if (cnt === bestMatch[1]) {
              candidates.push([fmt, fmt]); // key, label
            }
          });
          return candidates;
        }
      };
      return type;
    }

    var columnTypes = {
      text,
      number,
      date
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    var purify = {exports: {}};

    /*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */

    var hasRequiredPurify;

    function requirePurify () {
    	if (hasRequiredPurify) return purify.exports;
    	hasRequiredPurify = 1;
    	(function (module, exports) {
    		(function (global, factory) {
    		  module.exports = factory() ;
    		})(commonjsGlobal, (function () {
    		  function _typeof(obj) {
    		    "@babel/helpers - typeof";

    		    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    		      return typeof obj;
    		    } : function (obj) {
    		      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    		    }, _typeof(obj);
    		  }

    		  function _setPrototypeOf(o, p) {
    		    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    		      o.__proto__ = p;
    		      return o;
    		    };

    		    return _setPrototypeOf(o, p);
    		  }

    		  function _isNativeReflectConstruct() {
    		    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    		    if (Reflect.construct.sham) return false;
    		    if (typeof Proxy === "function") return true;

    		    try {
    		      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    		      return true;
    		    } catch (e) {
    		      return false;
    		    }
    		  }

    		  function _construct(Parent, args, Class) {
    		    if (_isNativeReflectConstruct()) {
    		      _construct = Reflect.construct;
    		    } else {
    		      _construct = function _construct(Parent, args, Class) {
    		        var a = [null];
    		        a.push.apply(a, args);
    		        var Constructor = Function.bind.apply(Parent, a);
    		        var instance = new Constructor();
    		        if (Class) _setPrototypeOf(instance, Class.prototype);
    		        return instance;
    		      };
    		    }

    		    return _construct.apply(null, arguments);
    		  }

    		  function _toConsumableArray(arr) {
    		    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    		  }

    		  function _arrayWithoutHoles(arr) {
    		    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    		  }

    		  function _iterableToArray(iter) {
    		    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    		  }

    		  function _unsupportedIterableToArray(o, minLen) {
    		    if (!o) return;
    		    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    		    var n = Object.prototype.toString.call(o).slice(8, -1);
    		    if (n === "Object" && o.constructor) n = o.constructor.name;
    		    if (n === "Map" || n === "Set") return Array.from(o);
    		    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    		  }

    		  function _arrayLikeToArray(arr, len) {
    		    if (len == null || len > arr.length) len = arr.length;

    		    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    		    return arr2;
    		  }

    		  function _nonIterableSpread() {
    		    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    		  }

    		  var hasOwnProperty = Object.hasOwnProperty,
    		      setPrototypeOf = Object.setPrototypeOf,
    		      isFrozen = Object.isFrozen,
    		      getPrototypeOf = Object.getPrototypeOf,
    		      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    		  var freeze = Object.freeze,
    		      seal = Object.seal,
    		      create = Object.create; // eslint-disable-line import/no-mutable-exports

    		  var _ref = typeof Reflect !== 'undefined' && Reflect,
    		      apply = _ref.apply,
    		      construct = _ref.construct;

    		  if (!apply) {
    		    apply = function apply(fun, thisValue, args) {
    		      return fun.apply(thisValue, args);
    		    };
    		  }

    		  if (!freeze) {
    		    freeze = function freeze(x) {
    		      return x;
    		    };
    		  }

    		  if (!seal) {
    		    seal = function seal(x) {
    		      return x;
    		    };
    		  }

    		  if (!construct) {
    		    construct = function construct(Func, args) {
    		      return _construct(Func, _toConsumableArray(args));
    		    };
    		  }

    		  var arrayForEach = unapply(Array.prototype.forEach);
    		  var arrayPop = unapply(Array.prototype.pop);
    		  var arrayPush = unapply(Array.prototype.push);
    		  var stringToLowerCase = unapply(String.prototype.toLowerCase);
    		  var stringMatch = unapply(String.prototype.match);
    		  var stringReplace = unapply(String.prototype.replace);
    		  var stringIndexOf = unapply(String.prototype.indexOf);
    		  var stringTrim = unapply(String.prototype.trim);
    		  var regExpTest = unapply(RegExp.prototype.test);
    		  var typeErrorCreate = unconstruct(TypeError);
    		  function unapply(func) {
    		    return function (thisArg) {
    		      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    		        args[_key - 1] = arguments[_key];
    		      }

    		      return apply(func, thisArg, args);
    		    };
    		  }
    		  function unconstruct(func) {
    		    return function () {
    		      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    		        args[_key2] = arguments[_key2];
    		      }

    		      return construct(func, args);
    		    };
    		  }
    		  /* Add properties to a lookup table */

    		  function addToSet(set, array, transformCaseFunc) {
    		    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

    		    if (setPrototypeOf) {
    		      // Make 'in' and truthy checks like Boolean(set.constructor)
    		      // independent of any properties defined on Object.prototype.
    		      // Prevent prototype setters from intercepting set as a this value.
    		      setPrototypeOf(set, null);
    		    }

    		    var l = array.length;

    		    while (l--) {
    		      var element = array[l];

    		      if (typeof element === 'string') {
    		        var lcElement = transformCaseFunc(element);

    		        if (lcElement !== element) {
    		          // Config presets (e.g. tags.js, attrs.js) are immutable.
    		          if (!isFrozen(array)) {
    		            array[l] = lcElement;
    		          }

    		          element = lcElement;
    		        }
    		      }

    		      set[element] = true;
    		    }

    		    return set;
    		  }
    		  /* Shallow clone an object */

    		  function clone(object) {
    		    var newObject = create(null);
    		    var property;

    		    for (property in object) {
    		      if (apply(hasOwnProperty, object, [property])) {
    		        newObject[property] = object[property];
    		      }
    		    }

    		    return newObject;
    		  }
    		  /* IE10 doesn't support __lookupGetter__ so lets'
    		   * simulate it. It also automatically checks
    		   * if the prop is function or getter and behaves
    		   * accordingly. */

    		  function lookupGetter(object, prop) {
    		    while (object !== null) {
    		      var desc = getOwnPropertyDescriptor(object, prop);

    		      if (desc) {
    		        if (desc.get) {
    		          return unapply(desc.get);
    		        }

    		        if (typeof desc.value === 'function') {
    		          return unapply(desc.value);
    		        }
    		      }

    		      object = getPrototypeOf(object);
    		    }

    		    function fallbackValue(element) {
    		      console.warn('fallback value for', element);
    		      return null;
    		    }

    		    return fallbackValue;
    		  }

    		  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

    		  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
    		  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
    		  // We still need to know them so that we can do namespace
    		  // checks properly in case one wants to add them to
    		  // allow-list.

    		  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
    		  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
    		  // even those that we disallow by default.

    		  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
    		  var text = freeze(['#text']);

    		  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
    		  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
    		  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
    		  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

    		  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

    		  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    		  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

    		  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

    		  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
    		  );
    		  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    		  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
    		  );
    		  var DOCTYPE_NAME = seal(/^html$/i);

    		  var getGlobal = function getGlobal() {
    		    return typeof window === 'undefined' ? null : window;
    		  };
    		  /**
    		   * Creates a no-op policy for internal use only.
    		   * Don't export this function outside this module!
    		   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
    		   * @param {Document} document The document object (to determine policy name suffix)
    		   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
    		   * are not supported).
    		   */


    		  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    		    if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    		      return null;
    		    } // Allow the callers to control the unique policy name
    		    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    		    // Policy creation with duplicate names throws in Trusted Types.


    		    var suffix = null;
    		    var ATTR_NAME = 'data-tt-policy-suffix';

    		    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    		      suffix = document.currentScript.getAttribute(ATTR_NAME);
    		    }

    		    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    		    try {
    		      return trustedTypes.createPolicy(policyName, {
    		        createHTML: function createHTML(html) {
    		          return html;
    		        },
    		        createScriptURL: function createScriptURL(scriptUrl) {
    		          return scriptUrl;
    		        }
    		      });
    		    } catch (_) {
    		      // Policy creation failed (most likely another DOMPurify script has
    		      // already run). Skip creating the policy, as this will only cause errors
    		      // if TT are enforced.
    		      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    		      return null;
    		    }
    		  };

    		  function createDOMPurify() {
    		    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    		    var DOMPurify = function DOMPurify(root) {
    		      return createDOMPurify(root);
    		    };
    		    /**
    		     * Version label, exposed for easier checks
    		     * if DOMPurify is up to date or not
    		     */


    		    DOMPurify.version = '2.4.0';
    		    /**
    		     * Array of elements that DOMPurify removed during sanitation.
    		     * Empty if nothing was removed.
    		     */

    		    DOMPurify.removed = [];

    		    if (!window || !window.document || window.document.nodeType !== 9) {
    		      // Not running in a browser, provide a factory function
    		      // so that you can pass your own Window
    		      DOMPurify.isSupported = false;
    		      return DOMPurify;
    		    }

    		    var originalDocument = window.document;
    		    var document = window.document;
    		    var DocumentFragment = window.DocumentFragment,
    		        HTMLTemplateElement = window.HTMLTemplateElement,
    		        Node = window.Node,
    		        Element = window.Element,
    		        NodeFilter = window.NodeFilter,
    		        _window$NamedNodeMap = window.NamedNodeMap,
    		        NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
    		        HTMLFormElement = window.HTMLFormElement,
    		        DOMParser = window.DOMParser,
    		        trustedTypes = window.trustedTypes;
    		    var ElementPrototype = Element.prototype;
    		    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    		    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    		    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    		    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
    		    // new document created via createHTMLDocument. As per the spec
    		    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    		    // a new empty registry is used when creating a template contents owner
    		    // document, so we use that as our parent document to ensure nothing
    		    // is inherited.

    		    if (typeof HTMLTemplateElement === 'function') {
    		      var template = document.createElement('template');

    		      if (template.content && template.content.ownerDocument) {
    		        document = template.content.ownerDocument;
    		      }
    		    }

    		    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

    		    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
    		    var _document = document,
    		        implementation = _document.implementation,
    		        createNodeIterator = _document.createNodeIterator,
    		        createDocumentFragment = _document.createDocumentFragment,
    		        getElementsByTagName = _document.getElementsByTagName;
    		    var importNode = originalDocument.importNode;
    		    var documentMode = {};

    		    try {
    		      documentMode = clone(document).documentMode ? document.documentMode : {};
    		    } catch (_) {}

    		    var hooks = {};
    		    /**
    		     * Expose whether this browser supports running the full DOMPurify.
    		     */

    		    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
    		    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
    		        ERB_EXPR$1 = ERB_EXPR,
    		        DATA_ATTR$1 = DATA_ATTR,
    		        ARIA_ATTR$1 = ARIA_ATTR,
    		        IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
    		        ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    		    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    		    /**
    		     * We consider the elements and attributes below to be safe. Ideally
    		     * don't add any new ones but feel free to remove unwanted ones.
    		     */

    		    /* allowed element names */

    		    var ALLOWED_TAGS = null;
    		    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    		    /* Allowed attribute names */

    		    var ALLOWED_ATTR = null;
    		    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    		    /*
    		     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
    		     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
    		     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
    		     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
    		     */

    		    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    		      tagNameCheck: {
    		        writable: true,
    		        configurable: false,
    		        enumerable: true,
    		        value: null
    		      },
    		      attributeNameCheck: {
    		        writable: true,
    		        configurable: false,
    		        enumerable: true,
    		        value: null
    		      },
    		      allowCustomizedBuiltInElements: {
    		        writable: true,
    		        configurable: false,
    		        enumerable: true,
    		        value: false
    		      }
    		    }));
    		    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

    		    var FORBID_TAGS = null;
    		    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

    		    var FORBID_ATTR = null;
    		    /* Decide if ARIA attributes are okay */

    		    var ALLOW_ARIA_ATTR = true;
    		    /* Decide if custom data attributes are okay */

    		    var ALLOW_DATA_ATTR = true;
    		    /* Decide if unknown protocols are okay */

    		    var ALLOW_UNKNOWN_PROTOCOLS = false;
    		    /* Output should be safe for common template engines.
    		     * This means, DOMPurify removes data attributes, mustaches and ERB
    		     */

    		    var SAFE_FOR_TEMPLATES = false;
    		    /* Decide if document with <html>... should be returned */

    		    var WHOLE_DOCUMENT = false;
    		    /* Track whether config is already set on this instance of DOMPurify. */

    		    var SET_CONFIG = false;
    		    /* Decide if all elements (e.g. style, script) must be children of
    		     * document.body. By default, browsers might move them to document.head */

    		    var FORCE_BODY = false;
    		    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
    		     * string (or a TrustedHTML object if Trusted Types are supported).
    		     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
    		     */

    		    var RETURN_DOM = false;
    		    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
    		     * string  (or a TrustedHTML object if Trusted Types are supported) */

    		    var RETURN_DOM_FRAGMENT = false;
    		    /* Try to return a Trusted Type object instead of a string, return a string in
    		     * case Trusted Types are not supported  */

    		    var RETURN_TRUSTED_TYPE = false;
    		    /* Output should be free from DOM clobbering attacks?
    		     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
    		     */

    		    var SANITIZE_DOM = true;
    		    /* Achieve full DOM Clobbering protection by isolating the namespace of named
    		     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
    		     *
    		     * HTML/DOM spec rules that enable DOM Clobbering:
    		     *   - Named Access on Window (§7.3.3)
    		     *   - DOM Tree Accessors (§3.1.5)
    		     *   - Form Element Parent-Child Relations (§4.10.3)
    		     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
    		     *   - HTMLCollection (§4.2.10.2)
    		     *
    		     * Namespace isolation is implemented by prefixing `id` and `name` attributes
    		     * with a constant string, i.e., `user-content-`
    		     */

    		    var SANITIZE_NAMED_PROPS = false;
    		    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    		    /* Keep element content when removing element? */

    		    var KEEP_CONTENT = true;
    		    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
    		     * of importing it into a new Document and returning a sanitized copy */

    		    var IN_PLACE = false;
    		    /* Allow usage of profiles like html, svg and mathMl */

    		    var USE_PROFILES = {};
    		    /* Tags to ignore content of when KEEP_CONTENT is true */

    		    var FORBID_CONTENTS = null;
    		    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    		    /* Tags that are safe for data: URIs */

    		    var DATA_URI_TAGS = null;
    		    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    		    /* Attributes safe for values like "javascript:" */

    		    var URI_SAFE_ATTRIBUTES = null;
    		    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    		    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    		    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    		    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    		    /* Document namespace */

    		    var NAMESPACE = HTML_NAMESPACE;
    		    var IS_EMPTY_INPUT = false;
    		    /* Parsing of strict XHTML documents */

    		    var PARSER_MEDIA_TYPE;
    		    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    		    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    		    var transformCaseFunc;
    		    /* Keep a reference to config to pass to hooks */

    		    var CONFIG = null;
    		    /* Ideally, do not touch anything below this line */

    		    /* ______________________________________________ */

    		    var formElement = document.createElement('form');

    		    var isRegexOrFunction = function isRegexOrFunction(testValue) {
    		      return testValue instanceof RegExp || testValue instanceof Function;
    		    };
    		    /**
    		     * _parseConfig
    		     *
    		     * @param  {Object} cfg optional config literal
    		     */
    		    // eslint-disable-next-line complexity


    		    var _parseConfig = function _parseConfig(cfg) {
    		      if (CONFIG && CONFIG === cfg) {
    		        return;
    		      }
    		      /* Shield configuration object from tampering */


    		      if (!cfg || _typeof(cfg) !== 'object') {
    		        cfg = {};
    		      }
    		      /* Shield configuration object from prototype pollution */


    		      cfg = clone(cfg);
    		      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    		      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

    		      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
    		        return x;
    		      } : stringToLowerCase;
    		      /* Set configuration parameters */

    		      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    		      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    		      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
    		      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
    		      transformCaseFunc // eslint-disable-line indent
    		      ) // eslint-disable-line indent
    		      : DEFAULT_URI_SAFE_ATTRIBUTES;
    		      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
    		      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
    		      transformCaseFunc // eslint-disable-line indent
    		      ) // eslint-disable-line indent
    		      : DEFAULT_DATA_URI_TAGS;
    		      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    		      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    		      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    		      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    		      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

    		      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

    		      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

    		      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

    		      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

    		      RETURN_DOM = cfg.RETURN_DOM || false; // Default false

    		      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

    		      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

    		      FORCE_BODY = cfg.FORCE_BODY || false; // Default false

    		      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

    		      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

    		      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

    		      IN_PLACE = cfg.IN_PLACE || false; // Default false

    		      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    		      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

    		      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
    		        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    		      }

    		      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
    		        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    		      }

    		      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
    		        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    		      }

    		      if (SAFE_FOR_TEMPLATES) {
    		        ALLOW_DATA_ATTR = false;
    		      }

    		      if (RETURN_DOM_FRAGMENT) {
    		        RETURN_DOM = true;
    		      }
    		      /* Parse profile info */


    		      if (USE_PROFILES) {
    		        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
    		        ALLOWED_ATTR = [];

    		        if (USE_PROFILES.html === true) {
    		          addToSet(ALLOWED_TAGS, html$1);
    		          addToSet(ALLOWED_ATTR, html);
    		        }

    		        if (USE_PROFILES.svg === true) {
    		          addToSet(ALLOWED_TAGS, svg$1);
    		          addToSet(ALLOWED_ATTR, svg);
    		          addToSet(ALLOWED_ATTR, xml);
    		        }

    		        if (USE_PROFILES.svgFilters === true) {
    		          addToSet(ALLOWED_TAGS, svgFilters);
    		          addToSet(ALLOWED_ATTR, svg);
    		          addToSet(ALLOWED_ATTR, xml);
    		        }

    		        if (USE_PROFILES.mathMl === true) {
    		          addToSet(ALLOWED_TAGS, mathMl$1);
    		          addToSet(ALLOWED_ATTR, mathMl);
    		          addToSet(ALLOWED_ATTR, xml);
    		        }
    		      }
    		      /* Merge configuration parameters */


    		      if (cfg.ADD_TAGS) {
    		        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
    		          ALLOWED_TAGS = clone(ALLOWED_TAGS);
    		        }

    		        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    		      }

    		      if (cfg.ADD_ATTR) {
    		        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
    		          ALLOWED_ATTR = clone(ALLOWED_ATTR);
    		        }

    		        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    		      }

    		      if (cfg.ADD_URI_SAFE_ATTR) {
    		        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    		      }

    		      if (cfg.FORBID_CONTENTS) {
    		        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
    		          FORBID_CONTENTS = clone(FORBID_CONTENTS);
    		        }

    		        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    		      }
    		      /* Add #text in case KEEP_CONTENT is set to true */


    		      if (KEEP_CONTENT) {
    		        ALLOWED_TAGS['#text'] = true;
    		      }
    		      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


    		      if (WHOLE_DOCUMENT) {
    		        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    		      }
    		      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


    		      if (ALLOWED_TAGS.table) {
    		        addToSet(ALLOWED_TAGS, ['tbody']);
    		        delete FORBID_TAGS.tbody;
    		      } // Prevent further manipulation of configuration.
    		      // Not available in IE8, Safari 5, etc.


    		      if (freeze) {
    		        freeze(cfg);
    		      }

    		      CONFIG = cfg;
    		    };

    		    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    		    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
    		    // namespace. We need to specify them explicitly
    		    // so that they don't get erroneously deleted from
    		    // HTML namespace.

    		    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    		    /* Keep track of all possible SVG and MathML tags
    		     * so that we can perform the namespace checks
    		     * correctly. */

    		    var ALL_SVG_TAGS = addToSet({}, svg$1);
    		    addToSet(ALL_SVG_TAGS, svgFilters);
    		    addToSet(ALL_SVG_TAGS, svgDisallowed);
    		    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    		    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    		    /**
    		     *
    		     *
    		     * @param  {Element} element a DOM element whose namespace is being checked
    		     * @returns {boolean} Return false if the element has a
    		     *  namespace that a spec-compliant parser would never
    		     *  return. Return true otherwise.
    		     */

    		    var _checkValidNamespace = function _checkValidNamespace(element) {
    		      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
    		      // can be null. We just simulate parent in this case.

    		      if (!parent || !parent.tagName) {
    		        parent = {
    		          namespaceURI: HTML_NAMESPACE,
    		          tagName: 'template'
    		        };
    		      }

    		      var tagName = stringToLowerCase(element.tagName);
    		      var parentTagName = stringToLowerCase(parent.tagName);

    		      if (element.namespaceURI === SVG_NAMESPACE) {
    		        // The only way to switch from HTML namespace to SVG
    		        // is via <svg>. If it happens via any other tag, then
    		        // it should be killed.
    		        if (parent.namespaceURI === HTML_NAMESPACE) {
    		          return tagName === 'svg';
    		        } // The only way to switch from MathML to SVG is via
    		        // svg if parent is either <annotation-xml> or MathML
    		        // text integration points.


    		        if (parent.namespaceURI === MATHML_NAMESPACE) {
    		          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
    		        } // We only allow elements that are defined in SVG
    		        // spec. All others are disallowed in SVG namespace.


    		        return Boolean(ALL_SVG_TAGS[tagName]);
    		      }

    		      if (element.namespaceURI === MATHML_NAMESPACE) {
    		        // The only way to switch from HTML namespace to MathML
    		        // is via <math>. If it happens via any other tag, then
    		        // it should be killed.
    		        if (parent.namespaceURI === HTML_NAMESPACE) {
    		          return tagName === 'math';
    		        } // The only way to switch from SVG to MathML is via
    		        // <math> and HTML integration points


    		        if (parent.namespaceURI === SVG_NAMESPACE) {
    		          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
    		        } // We only allow elements that are defined in MathML
    		        // spec. All others are disallowed in MathML namespace.


    		        return Boolean(ALL_MATHML_TAGS[tagName]);
    		      }

    		      if (element.namespaceURI === HTML_NAMESPACE) {
    		        // The only way to switch from SVG to HTML is via
    		        // HTML integration points, and from MathML to HTML
    		        // is via MathML text integration points
    		        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
    		          return false;
    		        }

    		        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
    		          return false;
    		        } // We disallow tags that are specific for MathML
    		        // or SVG and should never appear in HTML namespace


    		        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    		      } // The code should never reach this place (this means
    		      // that the element somehow got namespace that is not
    		      // HTML, SVG or MathML). Return false just in case.


    		      return false;
    		    };
    		    /**
    		     * _forceRemove
    		     *
    		     * @param  {Node} node a DOM node
    		     */


    		    var _forceRemove = function _forceRemove(node) {
    		      arrayPush(DOMPurify.removed, {
    		        element: node
    		      });

    		      try {
    		        // eslint-disable-next-line unicorn/prefer-dom-node-remove
    		        node.parentNode.removeChild(node);
    		      } catch (_) {
    		        try {
    		          node.outerHTML = emptyHTML;
    		        } catch (_) {
    		          node.remove();
    		        }
    		      }
    		    };
    		    /**
    		     * _removeAttribute
    		     *
    		     * @param  {String} name an Attribute name
    		     * @param  {Node} node a DOM node
    		     */


    		    var _removeAttribute = function _removeAttribute(name, node) {
    		      try {
    		        arrayPush(DOMPurify.removed, {
    		          attribute: node.getAttributeNode(name),
    		          from: node
    		        });
    		      } catch (_) {
    		        arrayPush(DOMPurify.removed, {
    		          attribute: null,
    		          from: node
    		        });
    		      }

    		      node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

    		      if (name === 'is' && !ALLOWED_ATTR[name]) {
    		        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
    		          try {
    		            _forceRemove(node);
    		          } catch (_) {}
    		        } else {
    		          try {
    		            node.setAttribute(name, '');
    		          } catch (_) {}
    		        }
    		      }
    		    };
    		    /**
    		     * _initDocument
    		     *
    		     * @param  {String} dirty a string of dirty markup
    		     * @return {Document} a DOM, filled with the dirty markup
    		     */


    		    var _initDocument = function _initDocument(dirty) {
    		      /* Create a HTML document */
    		      var doc;
    		      var leadingWhitespace;

    		      if (FORCE_BODY) {
    		        dirty = '<remove></remove>' + dirty;
    		      } else {
    		        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
    		        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
    		        leadingWhitespace = matches && matches[0];
    		      }

    		      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
    		        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
    		        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    		      }

    		      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    		      /*
    		       * Use the DOMParser API by default, fallback later if needs be
    		       * DOMParser not work for svg when has multiple root element.
    		       */

    		      if (NAMESPACE === HTML_NAMESPACE) {
    		        try {
    		          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
    		        } catch (_) {}
    		      }
    		      /* Use createHTMLDocument in case DOMParser is not available */


    		      if (!doc || !doc.documentElement) {
    		        doc = implementation.createDocument(NAMESPACE, 'template', null);

    		        try {
    		          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
    		        } catch (_) {// Syntax error if dirtyPayload is invalid xml
    		        }
    		      }

    		      var body = doc.body || doc.documentElement;

    		      if (dirty && leadingWhitespace) {
    		        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    		      }
    		      /* Work on whole document or just its body */


    		      if (NAMESPACE === HTML_NAMESPACE) {
    		        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    		      }

    		      return WHOLE_DOCUMENT ? doc.documentElement : body;
    		    };
    		    /**
    		     * _createIterator
    		     *
    		     * @param  {Document} root document/fragment to create iterator for
    		     * @return {Iterator} iterator instance
    		     */


    		    var _createIterator = function _createIterator(root) {
    		      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
    		      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    		    };
    		    /**
    		     * _isClobbered
    		     *
    		     * @param  {Node} elm element to check for clobbering attacks
    		     * @return {Boolean} true if clobbered, false if safe
    		     */


    		    var _isClobbered = function _isClobbered(elm) {
    		      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
    		    };
    		    /**
    		     * _isNode
    		     *
    		     * @param  {Node} obj object to check whether it's a DOM node
    		     * @return {Boolean} true is object is a DOM node
    		     */


    		    var _isNode = function _isNode(object) {
    		      return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    		    };
    		    /**
    		     * _executeHook
    		     * Execute user configurable hooks
    		     *
    		     * @param  {String} entryPoint  Name of the hook's entry point
    		     * @param  {Node} currentNode node to work on with the hook
    		     * @param  {Object} data additional hook parameters
    		     */


    		    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    		      if (!hooks[entryPoint]) {
    		        return;
    		      }

    		      arrayForEach(hooks[entryPoint], function (hook) {
    		        hook.call(DOMPurify, currentNode, data, CONFIG);
    		      });
    		    };
    		    /**
    		     * _sanitizeElements
    		     *
    		     * @protect nodeName
    		     * @protect textContent
    		     * @protect removeChild
    		     *
    		     * @param   {Node} currentNode to check for permission to exist
    		     * @return  {Boolean} true if node was killed, false if left alive
    		     */


    		    var _sanitizeElements = function _sanitizeElements(currentNode) {
    		      var content;
    		      /* Execute a hook if present */

    		      _executeHook('beforeSanitizeElements', currentNode, null);
    		      /* Check if element is clobbered or can clobber */


    		      if (_isClobbered(currentNode)) {
    		        _forceRemove(currentNode);

    		        return true;
    		      }
    		      /* Check if tagname contains Unicode */


    		      if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
    		        _forceRemove(currentNode);

    		        return true;
    		      }
    		      /* Now let's check the element's type and name */


    		      var tagName = transformCaseFunc(currentNode.nodeName);
    		      /* Execute a hook if present */

    		      _executeHook('uponSanitizeElement', currentNode, {
    		        tagName: tagName,
    		        allowedTags: ALLOWED_TAGS
    		      });
    		      /* Detect mXSS attempts abusing namespace confusion */


    		      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
    		        _forceRemove(currentNode);

    		        return true;
    		      }
    		      /* Mitigate a problem with templates inside select */


    		      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
    		        _forceRemove(currentNode);

    		        return true;
    		      }
    		      /* Remove element if anything forbids its presence */


    		      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
    		        /* Check if we have a custom element to handle */
    		        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
    		          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
    		          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
    		        }
    		        /* Keep content except for bad-listed elements */


    		        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
    		          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
    		          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

    		          if (childNodes && parentNode) {
    		            var childCount = childNodes.length;

    		            for (var i = childCount - 1; i >= 0; --i) {
    		              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
    		            }
    		          }
    		        }

    		        _forceRemove(currentNode);

    		        return true;
    		      }
    		      /* Check whether element has a valid namespace */


    		      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
    		        _forceRemove(currentNode);

    		        return true;
    		      }

    		      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
    		        _forceRemove(currentNode);

    		        return true;
    		      }
    		      /* Sanitize element content to be template-safe */


    		      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
    		        /* Get the element's text content */
    		        content = currentNode.textContent;
    		        content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
    		        content = stringReplace(content, ERB_EXPR$1, ' ');

    		        if (currentNode.textContent !== content) {
    		          arrayPush(DOMPurify.removed, {
    		            element: currentNode.cloneNode()
    		          });
    		          currentNode.textContent = content;
    		        }
    		      }
    		      /* Execute a hook if present */


    		      _executeHook('afterSanitizeElements', currentNode, null);

    		      return false;
    		    };
    		    /**
    		     * _isValidAttribute
    		     *
    		     * @param  {string} lcTag Lowercase tag name of containing element.
    		     * @param  {string} lcName Lowercase attribute name.
    		     * @param  {string} value Attribute value.
    		     * @return {Boolean} Returns true if `value` is valid, otherwise false.
    		     */
    		    // eslint-disable-next-line complexity


    		    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    		      /* Make sure attribute cannot clobber */
    		      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
    		        return false;
    		      }
    		      /* Allow valid data-* attributes: At least one character after "-"
    		          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
    		          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
    		          We don't need to check the value; it's always URI safe. */


    		      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
    		        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
    		        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
    		        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
    		        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
    		        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
    		        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
    		          return false;
    		        }
    		        /* Check value is safe. First, is attr inert? If so, is safe */

    		      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
    		        return false;
    		      }

    		      return true;
    		    };
    		    /**
    		     * _basicCustomElementCheck
    		     * checks if at least one dash is included in tagName, and it's not the first char
    		     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
    		     * @param {string} tagName name of the tag of the node to sanitize
    		     */


    		    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
    		      return tagName.indexOf('-') > 0;
    		    };
    		    /**
    		     * _sanitizeAttributes
    		     *
    		     * @protect attributes
    		     * @protect nodeName
    		     * @protect removeAttribute
    		     * @protect setAttribute
    		     *
    		     * @param  {Node} currentNode to sanitize
    		     */


    		    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    		      var attr;
    		      var value;
    		      var lcName;
    		      var l;
    		      /* Execute a hook if present */

    		      _executeHook('beforeSanitizeAttributes', currentNode, null);

    		      var attributes = currentNode.attributes;
    		      /* Check if we have attributes; if not we might have a text node */

    		      if (!attributes) {
    		        return;
    		      }

    		      var hookEvent = {
    		        attrName: '',
    		        attrValue: '',
    		        keepAttr: true,
    		        allowedAttributes: ALLOWED_ATTR
    		      };
    		      l = attributes.length;
    		      /* Go backwards over all attributes; safely remove bad ones */

    		      while (l--) {
    		        attr = attributes[l];
    		        var _attr = attr,
    		            name = _attr.name,
    		            namespaceURI = _attr.namespaceURI;
    		        value = name === 'value' ? attr.value : stringTrim(attr.value);
    		        lcName = transformCaseFunc(name);
    		        /* Execute a hook if present */

    		        hookEvent.attrName = lcName;
    		        hookEvent.attrValue = value;
    		        hookEvent.keepAttr = true;
    		        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

    		        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

    		        value = hookEvent.attrValue;
    		        /* Did the hooks approve of the attribute? */

    		        if (hookEvent.forceKeepAttr) {
    		          continue;
    		        }
    		        /* Remove attribute */


    		        _removeAttribute(name, currentNode);
    		        /* Did the hooks approve of the attribute? */


    		        if (!hookEvent.keepAttr) {
    		          continue;
    		        }
    		        /* Work around a security issue in jQuery 3.0 */


    		        if (regExpTest(/\/>/i, value)) {
    		          _removeAttribute(name, currentNode);

    		          continue;
    		        }
    		        /* Sanitize attribute content to be template-safe */


    		        if (SAFE_FOR_TEMPLATES) {
    		          value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
    		          value = stringReplace(value, ERB_EXPR$1, ' ');
    		        }
    		        /* Is `value` valid for this attribute? */


    		        var lcTag = transformCaseFunc(currentNode.nodeName);

    		        if (!_isValidAttribute(lcTag, lcName, value)) {
    		          continue;
    		        }
    		        /* Full DOM Clobbering protection via namespace isolation,
    		         * Prefix id and name attributes with `user-content-`
    		         */


    		        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
    		          // Remove the attribute with this value
    		          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


    		          value = SANITIZE_NAMED_PROPS_PREFIX + value;
    		        }
    		        /* Handle attributes that require Trusted Types */


    		        if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
    		          if (namespaceURI) ; else {
    		            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
    		              case 'TrustedHTML':
    		                value = trustedTypesPolicy.createHTML(value);
    		                break;

    		              case 'TrustedScriptURL':
    		                value = trustedTypesPolicy.createScriptURL(value);
    		                break;
    		            }
    		          }
    		        }
    		        /* Handle invalid data-* attribute set by try-catching it */


    		        try {
    		          if (namespaceURI) {
    		            currentNode.setAttributeNS(namespaceURI, name, value);
    		          } else {
    		            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
    		            currentNode.setAttribute(name, value);
    		          }

    		          arrayPop(DOMPurify.removed);
    		        } catch (_) {}
    		      }
    		      /* Execute a hook if present */


    		      _executeHook('afterSanitizeAttributes', currentNode, null);
    		    };
    		    /**
    		     * _sanitizeShadowDOM
    		     *
    		     * @param  {DocumentFragment} fragment to iterate over recursively
    		     */


    		    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    		      var shadowNode;

    		      var shadowIterator = _createIterator(fragment);
    		      /* Execute a hook if present */


    		      _executeHook('beforeSanitizeShadowDOM', fragment, null);

    		      while (shadowNode = shadowIterator.nextNode()) {
    		        /* Execute a hook if present */
    		        _executeHook('uponSanitizeShadowNode', shadowNode, null);
    		        /* Sanitize tags and elements */


    		        if (_sanitizeElements(shadowNode)) {
    		          continue;
    		        }
    		        /* Deep shadow DOM detected */


    		        if (shadowNode.content instanceof DocumentFragment) {
    		          _sanitizeShadowDOM(shadowNode.content);
    		        }
    		        /* Check attributes, sanitize if necessary */


    		        _sanitizeAttributes(shadowNode);
    		      }
    		      /* Execute a hook if present */


    		      _executeHook('afterSanitizeShadowDOM', fragment, null);
    		    };
    		    /**
    		     * Sanitize
    		     * Public method providing core sanitation functionality
    		     *
    		     * @param {String|Node} dirty string or DOM node
    		     * @param {Object} configuration object
    		     */
    		    // eslint-disable-next-line complexity


    		    DOMPurify.sanitize = function (dirty) {
    		      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    		      var body;
    		      var importedNode;
    		      var currentNode;
    		      var oldNode;
    		      var returnNode;
    		      /* Make sure we have a string to sanitize.
    		        DO NOT return early, as this will return the wrong type if
    		        the user has requested a DOM object rather than a string */

    		      IS_EMPTY_INPUT = !dirty;

    		      if (IS_EMPTY_INPUT) {
    		        dirty = '<!-->';
    		      }
    		      /* Stringify, in case dirty is an object */


    		      if (typeof dirty !== 'string' && !_isNode(dirty)) {
    		        // eslint-disable-next-line no-negated-condition
    		        if (typeof dirty.toString !== 'function') {
    		          throw typeErrorCreate('toString is not a function');
    		        } else {
    		          dirty = dirty.toString();

    		          if (typeof dirty !== 'string') {
    		            throw typeErrorCreate('dirty is not a string, aborting');
    		          }
    		        }
    		      }
    		      /* Check we can run. Otherwise fall back or ignore */


    		      if (!DOMPurify.isSupported) {
    		        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
    		          if (typeof dirty === 'string') {
    		            return window.toStaticHTML(dirty);
    		          }

    		          if (_isNode(dirty)) {
    		            return window.toStaticHTML(dirty.outerHTML);
    		          }
    		        }

    		        return dirty;
    		      }
    		      /* Assign config vars */


    		      if (!SET_CONFIG) {
    		        _parseConfig(cfg);
    		      }
    		      /* Clean up removed elements */


    		      DOMPurify.removed = [];
    		      /* Check if dirty is correctly typed for IN_PLACE */

    		      if (typeof dirty === 'string') {
    		        IN_PLACE = false;
    		      }

    		      if (IN_PLACE) {
    		        /* Do some early pre-sanitization to avoid unsafe root nodes */
    		        if (dirty.nodeName) {
    		          var tagName = transformCaseFunc(dirty.nodeName);

    		          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
    		            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
    		          }
    		        }
    		      } else if (dirty instanceof Node) {
    		        /* If dirty is a DOM element, append to an empty document to avoid
    		           elements being stripped by the parser */
    		        body = _initDocument('<!---->');
    		        importedNode = body.ownerDocument.importNode(dirty, true);

    		        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
    		          /* Node is already a body, use as is */
    		          body = importedNode;
    		        } else if (importedNode.nodeName === 'HTML') {
    		          body = importedNode;
    		        } else {
    		          // eslint-disable-next-line unicorn/prefer-dom-node-append
    		          body.appendChild(importedNode);
    		        }
    		      } else {
    		        /* Exit directly if we have nothing to do */
    		        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
    		        dirty.indexOf('<') === -1) {
    		          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
    		        }
    		        /* Initialize the document to work on */


    		        body = _initDocument(dirty);
    		        /* Check we have a DOM node from the data */

    		        if (!body) {
    		          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
    		        }
    		      }
    		      /* Remove first element node (ours) if FORCE_BODY is set */


    		      if (body && FORCE_BODY) {
    		        _forceRemove(body.firstChild);
    		      }
    		      /* Get node iterator */


    		      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    		      /* Now start iterating over the created document */


    		      while (currentNode = nodeIterator.nextNode()) {
    		        /* Fix IE's strange behavior with manipulated textNodes #89 */
    		        if (currentNode.nodeType === 3 && currentNode === oldNode) {
    		          continue;
    		        }
    		        /* Sanitize tags and elements */


    		        if (_sanitizeElements(currentNode)) {
    		          continue;
    		        }
    		        /* Shadow DOM detected, sanitize it */


    		        if (currentNode.content instanceof DocumentFragment) {
    		          _sanitizeShadowDOM(currentNode.content);
    		        }
    		        /* Check attributes, sanitize if necessary */


    		        _sanitizeAttributes(currentNode);

    		        oldNode = currentNode;
    		      }

    		      oldNode = null;
    		      /* If we sanitized `dirty` in-place, return it. */

    		      if (IN_PLACE) {
    		        return dirty;
    		      }
    		      /* Return sanitized string or DOM */


    		      if (RETURN_DOM) {
    		        if (RETURN_DOM_FRAGMENT) {
    		          returnNode = createDocumentFragment.call(body.ownerDocument);

    		          while (body.firstChild) {
    		            // eslint-disable-next-line unicorn/prefer-dom-node-append
    		            returnNode.appendChild(body.firstChild);
    		          }
    		        } else {
    		          returnNode = body;
    		        }

    		        if (ALLOWED_ATTR.shadowroot) {
    		          /*
    		            AdoptNode() is not used because internal state is not reset
    		            (e.g. the past names map of a HTMLFormElement), this is safe
    		            in theory but we would rather not risk another attack vector.
    		            The state that is cloned by importNode() is explicitly defined
    		            by the specs.
    		          */
    		          returnNode = importNode.call(originalDocument, returnNode, true);
    		        }

    		        return returnNode;
    		      }

    		      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    		      /* Serialize doctype if allowed */

    		      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
    		        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    		      }
    		      /* Sanitize final string template-safe */


    		      if (SAFE_FOR_TEMPLATES) {
    		        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
    		        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
    		      }

    		      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    		    };
    		    /**
    		     * Public method to set the configuration once
    		     * setConfig
    		     *
    		     * @param {Object} cfg configuration object
    		     */


    		    DOMPurify.setConfig = function (cfg) {
    		      _parseConfig(cfg);

    		      SET_CONFIG = true;
    		    };
    		    /**
    		     * Public method to remove the configuration
    		     * clearConfig
    		     *
    		     */


    		    DOMPurify.clearConfig = function () {
    		      CONFIG = null;
    		      SET_CONFIG = false;
    		    };
    		    /**
    		     * Public method to check if an attribute value is valid.
    		     * Uses last set config, if any. Otherwise, uses config defaults.
    		     * isValidAttribute
    		     *
    		     * @param  {string} tag Tag name of containing element.
    		     * @param  {string} attr Attribute name.
    		     * @param  {string} value Attribute value.
    		     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
    		     */


    		    DOMPurify.isValidAttribute = function (tag, attr, value) {
    		      /* Initialize shared config vars if necessary. */
    		      if (!CONFIG) {
    		        _parseConfig({});
    		      }

    		      var lcTag = transformCaseFunc(tag);
    		      var lcName = transformCaseFunc(attr);
    		      return _isValidAttribute(lcTag, lcName, value);
    		    };
    		    /**
    		     * AddHook
    		     * Public method to add DOMPurify hooks
    		     *
    		     * @param {String} entryPoint entry point for the hook to add
    		     * @param {Function} hookFunction function to execute
    		     */


    		    DOMPurify.addHook = function (entryPoint, hookFunction) {
    		      if (typeof hookFunction !== 'function') {
    		        return;
    		      }

    		      hooks[entryPoint] = hooks[entryPoint] || [];
    		      arrayPush(hooks[entryPoint], hookFunction);
    		    };
    		    /**
    		     * RemoveHook
    		     * Public method to remove a DOMPurify hook at a given entryPoint
    		     * (pops it from the stack of hooks if more are present)
    		     *
    		     * @param {String} entryPoint entry point for the hook to remove
    		     * @return {Function} removed(popped) hook
    		     */


    		    DOMPurify.removeHook = function (entryPoint) {
    		      if (hooks[entryPoint]) {
    		        return arrayPop(hooks[entryPoint]);
    		      }
    		    };
    		    /**
    		     * RemoveHooks
    		     * Public method to remove all DOMPurify hooks at a given entryPoint
    		     *
    		     * @param  {String} entryPoint entry point for the hooks to remove
    		     */


    		    DOMPurify.removeHooks = function (entryPoint) {
    		      if (hooks[entryPoint]) {
    		        hooks[entryPoint] = [];
    		      }
    		    };
    		    /**
    		     * RemoveAllHooks
    		     * Public method to remove all DOMPurify hooks
    		     *
    		     */


    		    DOMPurify.removeAllHooks = function () {
    		      hooks = {};
    		    };

    		    return DOMPurify;
    		  }

    		  var purify = createDOMPurify();

    		  return purify;

    		}));
    		
    } (purify));
    	return purify.exports;
    }

    var browser = window.DOMPurify || (window.DOMPurify = requirePurify().default || requirePurify());

    var memoizer$1 = {};

    Object.defineProperty(memoizer$1, "__esModule", {
      value: true
    });
    memoizer$1.createPermanentMemoizer = void 0;

    const createPermanentMemoizer = (keySerializer, valueCreator) => {
      const map = new Map();
      return {
        get: key => {
          const serializedKey = keySerializer(key);

          if (map.has(serializedKey)) {
            // We can be certain that `map.get` does not return undefined
            // (if TValue does not include undefined)
            // because we've just checked that it has this key.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return map.get(serializedKey);
          }

          const value = valueCreator(key);
          map.set(serializedKey, value);
          return value;
        }
      };
    };

    memoizer$1.createPermanentMemoizer = createPermanentMemoizer;

    var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    const isomorphic_dompurify_1 = __importDefault$3(browser);

    const memoizer_1 = memoizer$1;
    const DEFAULT_ALLOWED = ['a', 'span', 'b', 'br', 'i', 'strong', 'sup', 'sub', 'strike', 'u', 'em', 'tt'].sort();
    /**
     * Set default TARGET and REL for A tags.
     *
     * Don't overwrite target="_self".
     */

    isomorphic_dompurify_1.default.addHook('afterSanitizeElements', function (el) {
      if (el.nodeName.toLowerCase() === 'a') {
        if (el.getAttribute('target') !== '_self') {
          el.setAttribute('target', '_blank');
        }

        el.setAttribute('rel', 'nofollow noopener noreferrer');
      }
    });
    const memoizer = (0, memoizer_1.createPermanentMemoizer)(allowedTagsInput => String(allowedTagsInput), allowedTagsInput => {
      const allowedTags = allowedTagsInput === undefined ? DEFAULT_ALLOWED : typeof allowedTagsInput === 'string' ? allowedTagsInput.toLowerCase().slice(1, -1).split('><') : allowedTagsInput;
      const config = {
        ALLOWED_TAGS: allowedTags,
        ADD_ATTR: ['target'],
        FORCE_BODY: true // Makes sure that top-level SCRIPT tags are kept if explicitly allowed.

      };
      return (0, memoizer_1.createPermanentMemoizer)(input => input, input => {
        // Implementation of DOMPurify accepts anything,
        // and we need to accept anything too, according to tests
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return isomorphic_dompurify_1.default.sanitize(input, config);
      });
    });

    function purifyHTML(input, allowedTagsInput) {
      if (!input) {
        return input;
      }

      return memoizer.get(allowedTagsInput).get(input);
    }

    var purifyHtml = purifyHTML;

    /*
     * column abstracts the functionality of each column
     * of a dataset. A column has a type (text|number|date).
     *
     * API:
     *
     * column.name() ... returns the name (string)
     * column.type() ... return column type (string)
     * column.length ... number of rows (number)
     * column.val(i) ... parsed value in row i
     * column.each(func) ... apply function to each value
     * column.raw() ... access raw, unparsed values
     *
     */
    /**
     * @class dw.Column
     */

    function Column(name_, rows, type, allowedTags) {
      function notEmpty(d) {
        return d !== null && d !== undefined && d !== '';
      }

      function guessType(sample) {
        if (every(rows, isNumber)) return columnTypes.number();
        if (every(rows, isDate)) return columnTypes.date(); // guessing column type by counting parsing errors
        // for every known type

        const types = [columnTypes.date(sample), columnTypes.number(sample), columnTypes.text()];
        let type;
        const tolerance = 0.1 * rows.filter(notEmpty).length; // allowing 10% mis-parsed values

        each(rows, function (val) {
          each(types, function (t) {
            t.parse(val);
          });
        });
        every(types, function (t) {
          if (t.errors() < tolerance) type = t;
          return !type;
        });
        if (isUndefined(type)) type = types[2]; // default to text;

        return type;
      } // we pick random 200 non-empty values for column type testing


      const sample = shuffle(range(rows.length)).filter(function (i) {
        return notEmpty(rows[i]);
      }).slice(0, 200).map(function (i) {
        return rows[i];
      });
      type = type ? columnTypes[type](sample) : guessType(sample);
      let name = purifyHtml(name_);
      let origName = name;
      let valueRange, sum, mean, median;
      const origRows = rows.slice(0);
      let title; // public interface

      var column = {
        // column name (used for reference in chart metadata)
        name() {
          if (arguments.length >= 1) {
            name = purifyHtml(arguments[0]);

            if (arguments.length === 2) {
              origName = purifyHtml(arguments[1]);
            } else {
              origName = name;
            }

            return column;
          }

          return name;
        },

        origName() {
          return origName;
        },

        // column title (used for presentation)
        title() {
          if (arguments.length) {
            title = purifyHtml(arguments[0], allowedTags);
            return column;
          }

          return title || name;
        },

        /**
         * number of rows
         */
        length: rows.length,

        /**
         * returns ith row of the col, parsed
         *
         * @param i
         * @param unfiltered  if set to true, precedent calls of filterRows are ignored
         */
        val(i, unfiltered) {
          if (!arguments.length) return undefined;
          var r = unfiltered ? origRows : rows;
          if (i < 0) i += r.length;
          return type.parse(isDate(r[i]) || isNumber(r[i]) ? r[i] : purifyHtml(r[i], allowedTags));
        },

        /**
         * returns an array of formatted values
         *
         * @param {string} [opt.numeral=null] -- format numbers using this Numeral.js instance
         */
        formatted() {
          let numeral = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          if (numeral && this.type() === 'number') {
            return this.values().map(val => {
              if (Number.isFinite(val)) {
                return numeral(val).format('0.[00000000000000000000]');
              } // When the value is null, undefined, NaN, Infinity, or when parsing failed.


              return val;
            });
          }

          return this.raw();
        },

        /**
         * returns an array of parsed values
         */
        values(unfiltered) {
          var r = unfiltered ? origRows : rows;
          r = map(r, function (d) {
            return isDate(d) || isNumber(d) ? d : purifyHtml(d, allowedTags);
          });
          return map(r, type.parse);
        },

        /**
         * apply function to each value
         */
        each(f) {
          for (var i = 0; i < rows.length; i++) {
            f(column.val(i), i);
          }
        },

        // access to raw values
        raw(i, val) {
          if (!arguments.length) return rows.map(d => isDate(d) || isNumber(d) ? d : purifyHtml(d, allowedTags));

          if (arguments.length === 2) {
            rows[i] = val;
            return column;
          }

          return isDate(rows[i]) || isNumber(rows[i]) ? rows[i] : purifyHtml(rows[i], allowedTags);
        },

        /**
         * if called with no arguments, this returns the column type name
         * if called with true as argument, this returns the column type (as object)
         * if called with a string as argument, this sets a new column type
         */
        type(o) {
          if (o === true) return type;

          if (isString(o)) {
            if (columnTypes[o]) {
              type = columnTypes[o](sample);
              return column;
            } else {
              throw new Error('unknown column type: ' + o);
            }
          }

          return type.name();
        },

        // [min,max] range
        range() {
          if (!type.toNum) return false;

          if (!valueRange) {
            valueRange = [Number.MAX_VALUE, -Number.MAX_VALUE];
            column.each(function (v) {
              v = type.toNum(v);
              if (!isNumber(v) || isNaN$1(v)) return;
              if (v < valueRange[0]) valueRange[0] = v;
              if (v > valueRange[1]) valueRange[1] = v;
            });
            valueRange[0] = type.fromNum(valueRange[0]);
            valueRange[1] = type.fromNum(valueRange[1]);
          }

          return valueRange;
        },

        // sum of values
        sum() {
          if (!type.toNum) return false;

          if (sum === undefined) {
            sum = 0;
            column.each(function (v) {
              const n = type.toNum(v);

              if (Number.isFinite(n)) {
                sum += n;
              }
            });
            sum = type.fromNum(sum);
          }

          return sum;
        },

        mean() {
          if (!type.toNum) return false;

          if (mean === undefined) {
            mean = 0;
            let count = 0;
            column.each(function (v) {
              const n = type.toNum(v);

              if (Number.isFinite(n)) {
                mean += n;
                count++;
              }
            });
            mean = type.fromNum(mean / count);
          }

          return mean;
        },

        median() {
          if (!type.toNum) return false;

          if (median === undefined) {
            const arr = column.values().map(type.toNum);
            median = type.fromNum(d3Median(arr));
          }

          return median;
        },

        // remove rows from column, keep those whose index
        // is within @r
        filterRows(r) {
          rows = [];

          if (arguments.length) {
            each(r, function (i) {
              rows.push(origRows[i]);
            });
          } else {
            rows = origRows.slice(0);
          }

          column.length = rows.length; // invalidate valueRange and total

          valueRange = sum = mean = median = undefined;
          return column;
        },

        deleteRow(i) {
          const deletedRows = rows.splice(i, 1);
          origRows.splice(i, 1);
          column.length = rows.length; // invalidate valueRange and total

          valueRange = sum = mean = median = undefined;
          return deletedRows;
        },

        toString() {
          return name + ' (' + type.name() + ')';
        },

        indexOf(val) {
          return find(range(rows.length), function (i) {
            return column.val(i) === val;
          });
        },

        limitRows(numRows) {
          if (origRows.length > numRows) {
            origRows.length = numRows;
            rows.length = numRows;
            column.length = numRows;
          }
        },

        /**
         * add one or more new rows
         * @param {...*} values
         */
        add() {
          origRows.push(...arguments);
          rows.push(...arguments);
          column.length = rows.length;
        },

        /**
         * create a copy of the column
         * @returns {dw.Column}
         */
        clone() {
          return Column(name, rows.slice(), type.name());
        },

        /**
         * delete all rows
         */
        clear() {
          rows.splice(0);
          column.length = rows.length;
        }

      }; // backwards compatibility

      column.total = column.sum;
      return column;
    } // some d3 stuff

    function d3Median(array) {
      var numbers = [];
      var n = array.length;
      var a;
      var i = -1;

      if (arguments.length === 1) {
        while (++i < n) if (d3Numeric(a = d3Number(array[i]))) numbers.push(a);
      }

      if (numbers.length) return d3Quantile(numbers.sort(d3Ascending), 0.5);
    }

    function d3Quantile(values, p) {
      var H = (values.length - 1) * p + 1;
      var h = Math.floor(H);
      var v = +values[h - 1];
      var e = H - h;
      return e ? v + e * (values[h] - v) : v;
    }

    function d3Number(x) {
      return x === null ? NaN : +x;
    }

    function d3Numeric(x) {
      return !isNaN$1(x);
    }

    function d3Ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    /*
     * dataset source for delimited files (CSV, TSV, ...)
     */
    /**
     * Parses a separator-delimited string (e.g. CSV)
     *
     * @param {object} opts
     * @param {string} opts.csv - the CSV string to be parsed
     * @param {string} opts.delimiter - defaults to 'auto'
     * @param {string} opts.quoteChar
     * @param {number} opts.skipRows - number of initial rows to skip
     * @param {*} opts.emptyValue
     * @param {boolean} opts.transpose
     * @param {boolean} opts.firstRowIsHeader
     * @param {string} opts.allowedTags - list of HTML tags that will not get filtered out by purifyHTML
     * @return {Dataset}
     */

    function delimited(opts) {
      function loadAndParseCsv() {
        if (opts.url) {
          const ts = new Date().getTime();
          const url = `${opts.url}${opts.url.indexOf('?') > -1 ? '&' : '?'}v=${opts.url.indexOf('//static.dwcdn.net') > -1 ? ts - ts % 60000 : ts}`;
          return window.fetch(url).then(res => res.text()).then(raw => {
            return new DelimitedParser(opts).parse(raw);
          });
        } else if (opts.csv || opts.csv === '') {
          const dfd = new Promise(resolve => {
            resolve(opts.csv);
          });
          const parsed = dfd.then(raw => {
            return new DelimitedParser(opts).parse(raw);
          });
          return parsed;
        }

        const err = new Error('You need to provide either a URL or CSV data');
        return Promise.reject(err);
      }

      return {
        dataset: function () {
          return loadAndParseCsv().catch(e => {
            console.error(`Could not fetch delimited data source for chart ${opts.chartId}, ` + `returning an empty dataset: ${e.message}`);
            return Dataset([]);
          });
        },
        parse: function () {
          return new DelimitedParser(opts).parse(opts.csv);
        }
      };
    }

    Dataset.delimited = delimited;

    class DelimitedParser {
      constructor(opts) {
        opts = Object.assign({
          delimiter: 'auto',
          quoteChar: '"',
          skipRows: 0,
          emptyValue: null,
          transpose: false,
          firstRowIsHeader: true
        }, opts);
        this.__delimiterPatterns = getDelimiterPatterns(opts.delimiter, opts.quoteChar);
        this.opts = opts;
      }

      parse(data) {
        this.__rawData = data;
        const opts = this.opts;

        if (opts.delimiter === 'auto') {
          opts.delimiter = this.guessDelimiter(data, opts.skipRows);
          this.__delimiterPatterns = getDelimiterPatterns(opts.delimiter, opts.quoteChar);
        }

        const closure = opts.delimiter !== '|' ? '|' : '#';
        let arrData;
        data = closure + '\n' + data.replace(/[ \r\n\f]+$/g, '').replace(/^\uFEFF/, '') + closure;

        function parseCSV(delimiterPattern, strData, strDelimiter) {
          // implementation and regex borrowed from:
          // http://www.bennadel.com/blog/1504-Ask-Ben-Parsing-CSV-Strings-With-Javascript-Exec-Regular-Expression-Command.htm
          // Check to see if the delimiter is defined. If not,
          // then default to comma.
          strDelimiter = strDelimiter || ','; // Create an array to hold our data. Give the array
          // a default empty first row.

          const arrData = [[]]; // Create an array to hold our individual pattern
          // matching groups.

          let arrMatches = null;
          let strMatchedValue; // Keep looping over the regular expression matches
          // until we can no longer find a match.

          while (arrMatches = delimiterPattern.exec(strData)) {
            // Get the delimiter that was found.
            var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know
            // that this delimiter is a row delimiter.

            if (strMatchedDelimiter.length && strMatchedDelimiter !== strDelimiter) {
              // Since we have reached a new row of data,
              // add an empty row to our data array.
              arrData.push([]);
            } // Now that we have our delimiter out of the way,
            // let's check to see which kind of value we
            // captured (quoted or unquoted).


            if (arrMatches[2]) {
              // We found a quoted value. When we capture
              // this value, unescape any double quotes.
              strMatchedValue = arrMatches[2].replace(new RegExp('""', 'g'), '"');
            } else {
              // We found a non-quoted value.
              strMatchedValue = arrMatches[3];
            } // Now that we have our value string, let's add
            // it to the data array.


            arrData[arrData.length - 1].push(strMatchedValue === undefined ? '' : strMatchedValue);
          } // remove closure


          if (arrData[0][0].substr(0, 1) === closure) {
            arrData[0][0] = arrData[0][0].substr(1);
          }

          const p = arrData.length - 1;
          const q = arrData[p].length - 1;
          const r = arrData[p][q].length - 1;

          if (arrData[p][q].substr(r) === closure) {
            arrData[p][q] = arrData[p][q].substr(0, r);
          } // Return the parsed data.


          return arrData.slice(1);
        } // end parseCSV


        function transpose(arrMatrix) {
          // borrowed from:
          // http://www.shamasis.net/2010/02/transpose-an-array-in-javascript-and-jquery/
          const a = arrMatrix;
          const w = a.length ? a.length : 0;
          const h = a[0] instanceof Array ? a[0].length : 0;

          if (h === 0 || w === 0) {
            return [];
          }

          let i, j;
          const t = [];

          for (i = 0; i < h; i++) {
            t[i] = [];

            for (j = 0; j < w; j++) {
              t[i][j] = a[j][i];
            }
          }

          return t;
        }

        function makeColumns(arrData) {
          if (!arrData) {
            return [];
          }

          arrData = arrData.slice(opts.skipRows);

          if (!arrData.length) {
            return [];
          } // compute series


          const firstRow = arrData[0];
          const columnNames = {};
          let srcColumns = [];
          let rowIndex = 0;

          if (opts.firstRowIsHeader) {
            srcColumns = arrData[rowIndex];
            rowIndex++;
            arrData.shift();
          }

          return firstRow.map((_, i) => {
            const data = arrData.map(row => row[i] !== '' ? row[i] : opts.emptyValue);
            let col = isString(srcColumns[i]) ? srcColumns[i].replace(/^\s+|\s+$/g, '') : '';
            let suffix = col !== '' ? '' : 1;
            col = col !== '' ? col : 'X.';

            while (columnNames[col + suffix] !== undefined) {
              suffix = suffix === '' ? 1 : suffix + 1;
            }

            columnNames[col + suffix] = true;
            return Column(col + suffix, data, undefined, opts.allowedTags);
          });
        }

        function makeDataset(arrData) {
          const columns = makeColumns(arrData);
          return Dataset(columns);
        }

        arrData = parseCSV(this.__delimiterPatterns, data, opts.delimiter);

        if (opts.transpose) {
          arrData = transpose(arrData);
        }

        return makeDataset(trimArrayData(arrData));
      } // end parse


      guessDelimiter(strData) {
        // find delimiter which occurs most often
        let maxMatchCount = 0;
        let k = -1;
        const me = this;
        const delimiters = ['\t', ';', '|', ','];
        delimiters.forEach((delimiter, i) => {
          const regex = getDelimiterPatterns(delimiter, me.quoteChar);
          let c = strData.match(regex).length;
          if (delimiter === '\t') c *= 1.15; // give tab delimiters more weight

          if (c > maxMatchCount) {
            maxMatchCount = c;
            k = i;
          }
        });
        return delimiters[k];
      }

    }

    function getDelimiterPatterns(delimiter, quoteChar) {
      return new RegExp( // Delimiters.
      '(\\' + delimiter + '|\\r?\\n|\\r|^)' + // Quoted fields.
      '(?:' + quoteChar + '([^' + quoteChar + ']*(?:' + quoteChar + '"[^' + quoteChar + ']*)*)' + quoteChar + '|' + // Standard fields.
      '([^\\' + delimiter + '\\r\\n]*))', 'gi');
    }

    function trimArrayData(arrData) {
      for (let i = arrData.length - 1; i >= 0; i--) {
        if (arrData[i].some(col => col !== '')) {
          return arrData.slice(0, i + 1);
        }
      }

      return arrData.slice(0, 1);
    }

    /*
     * dataset source for JSON data
     */

    function json(opts) {
      function loadAndParseJSON() {
        if (opts.url) {
          return fetch(opts.url).then(res => res.text()).then(raw => {
            return JSON.parse(raw);
          });
        } else if (opts.csv) {
          const dfd = new Promise(resolve => {
            resolve(opts.csv);
          });
          const parsed = dfd.then(raw => {
            return JSON.parse(raw);
          });
          return parsed;
        }

        const err = new Error('You need to provide either a URL or CSV data');
        return Promise.reject(err);
      }

      return {
        dataset: function () {
          return loadAndParseJSON().catch(e => {
            console.error(`Could not fetch JSON data source for chart ${opts.chartId}, ` + `returning an empty object: ${e.message}`);
            return {};
          });
        },
        parse: function () {
          return JSON.parse(opts.csv);
        }
      };
    }

    Dataset.json = json;

    var tailLength = function tailLength(value) {
      return Math.max(0, String(value - Math.floor(value)).replace(/00000*[0-9]+$/, '').replace(/33333*[0-9]+$/, '').replace(/99999*[0-9]+$/, '').length - 2);
    };

    var round = function round(value) {
      let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const base = Math.pow(10, decimals);
      return Math.round(value * base) / base;
    };

    var underscoreUmd = {exports: {}};

    (function (module, exports) {
    	(function (global, factory) {
    	  module.exports = factory() ;
    	}(commonjsGlobal, (function () {
    	  //     Underscore.js 1.13.4
    	  //     https://underscorejs.org
    	  //     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
    	  //     Underscore may be freely distributed under the MIT license.

    	  // Current version.
    	  var VERSION = '1.13.4';

    	  // Establish the root object, `window` (`self`) in the browser, `global`
    	  // on the server, or `this` in some virtual machines. We use `self`
    	  // instead of `window` for `WebWorker` support.
    	  var root = (typeof self == 'object' && self.self === self && self) ||
    	            (typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal) ||
    	            Function('return this')() ||
    	            {};

    	  // Save bytes in the minified (but not gzipped) version:
    	  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
    	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

    	  // Create quick reference variables for speed access to core prototypes.
    	  var push = ArrayProto.push,
    	      slice = ArrayProto.slice,
    	      toString = ObjProto.toString,
    	      hasOwnProperty = ObjProto.hasOwnProperty;

    	  // Modern feature detection.
    	  var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
    	      supportsDataView = typeof DataView !== 'undefined';

    	  // All **ECMAScript 5+** native function implementations that we hope to use
    	  // are declared here.
    	  var nativeIsArray = Array.isArray,
    	      nativeKeys = Object.keys,
    	      nativeCreate = Object.create,
    	      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

    	  // Create references to these builtin functions because we override them.
    	  var _isNaN = isNaN,
    	      _isFinite = isFinite;

    	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
    	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    	    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

    	  // The largest integer that can be represented exactly.
    	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

    	  // Some functions take a variable number of arguments, or a few expected
    	  // arguments at the beginning and then a variable number of values to operate
    	  // on. This helper accumulates all remaining arguments past the function’s
    	  // argument length (or an explicit `startIndex`), into an array that becomes
    	  // the last argument. Similar to ES6’s "rest parameter".
    	  function restArguments(func, startIndex) {
    	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    	    return function() {
    	      var length = Math.max(arguments.length - startIndex, 0),
    	          rest = Array(length),
    	          index = 0;
    	      for (; index < length; index++) {
    	        rest[index] = arguments[index + startIndex];
    	      }
    	      switch (startIndex) {
    	        case 0: return func.call(this, rest);
    	        case 1: return func.call(this, arguments[0], rest);
    	        case 2: return func.call(this, arguments[0], arguments[1], rest);
    	      }
    	      var args = Array(startIndex + 1);
    	      for (index = 0; index < startIndex; index++) {
    	        args[index] = arguments[index];
    	      }
    	      args[startIndex] = rest;
    	      return func.apply(this, args);
    	    };
    	  }

    	  // Is a given variable an object?
    	  function isObject(obj) {
    	    var type = typeof obj;
    	    return type === 'function' || (type === 'object' && !!obj);
    	  }

    	  // Is a given value equal to null?
    	  function isNull(obj) {
    	    return obj === null;
    	  }

    	  // Is a given variable undefined?
    	  function isUndefined(obj) {
    	    return obj === void 0;
    	  }

    	  // Is a given value a boolean?
    	  function isBoolean(obj) {
    	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    	  }

    	  // Is a given value a DOM element?
    	  function isElement(obj) {
    	    return !!(obj && obj.nodeType === 1);
    	  }

    	  // Internal function for creating a `toString`-based type tester.
    	  function tagTester(name) {
    	    var tag = '[object ' + name + ']';
    	    return function(obj) {
    	      return toString.call(obj) === tag;
    	    };
    	  }

    	  var isString = tagTester('String');

    	  var isNumber = tagTester('Number');

    	  var isDate = tagTester('Date');

    	  var isRegExp = tagTester('RegExp');

    	  var isError = tagTester('Error');

    	  var isSymbol = tagTester('Symbol');

    	  var isArrayBuffer = tagTester('ArrayBuffer');

    	  var isFunction = tagTester('Function');

    	  // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
    	  // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
    	  var nodelist = root.document && root.document.childNodes;
    	  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    	    isFunction = function(obj) {
    	      return typeof obj == 'function' || false;
    	    };
    	  }

    	  var isFunction$1 = isFunction;

    	  var hasObjectTag = tagTester('Object');

    	  // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
    	  // In IE 11, the most common among them, this problem also applies to
    	  // `Map`, `WeakMap` and `Set`.
    	  var hasStringTagBug = (
    	        supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8)))
    	      ),
    	      isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));

    	  var isDataView = tagTester('DataView');

    	  // In IE 10 - Edge 13, we need a different heuristic
    	  // to determine whether an object is a `DataView`.
    	  function ie10IsDataView(obj) {
    	    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
    	  }

    	  var isDataView$1 = (hasStringTagBug ? ie10IsDataView : isDataView);

    	  // Is a given value an array?
    	  // Delegates to ECMA5's native `Array.isArray`.
    	  var isArray = nativeIsArray || tagTester('Array');

    	  // Internal function to check whether `key` is an own property name of `obj`.
    	  function has$1(obj, key) {
    	    return obj != null && hasOwnProperty.call(obj, key);
    	  }

    	  var isArguments = tagTester('Arguments');

    	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
    	  // there isn't any inspectable "Arguments" type.
    	  (function() {
    	    if (!isArguments(arguments)) {
    	      isArguments = function(obj) {
    	        return has$1(obj, 'callee');
    	      };
    	    }
    	  }());

    	  var isArguments$1 = isArguments;

    	  // Is a given object a finite number?
    	  function isFinite$1(obj) {
    	    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
    	  }

    	  // Is the given value `NaN`?
    	  function isNaN$1(obj) {
    	    return isNumber(obj) && _isNaN(obj);
    	  }

    	  // Predicate-generating function. Often useful outside of Underscore.
    	  function constant(value) {
    	    return function() {
    	      return value;
    	    };
    	  }

    	  // Common internal logic for `isArrayLike` and `isBufferLike`.
    	  function createSizePropertyCheck(getSizeProperty) {
    	    return function(collection) {
    	      var sizeProperty = getSizeProperty(collection);
    	      return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
    	    }
    	  }

    	  // Internal helper to generate a function to obtain property `key` from `obj`.
    	  function shallowProperty(key) {
    	    return function(obj) {
    	      return obj == null ? void 0 : obj[key];
    	    };
    	  }

    	  // Internal helper to obtain the `byteLength` property of an object.
    	  var getByteLength = shallowProperty('byteLength');

    	  // Internal helper to determine whether we should spend extensive checks against
    	  // `ArrayBuffer` et al.
    	  var isBufferLike = createSizePropertyCheck(getByteLength);

    	  // Is a given value a typed array?
    	  var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    	  function isTypedArray(obj) {
    	    // `ArrayBuffer.isView` is the most future-proof, so use it when available.
    	    // Otherwise, fall back on the above regular expression.
    	    return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :
    	                  isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
    	  }

    	  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);

    	  // Internal helper to obtain the `length` property of an object.
    	  var getLength = shallowProperty('length');

    	  // Internal helper to create a simple lookup structure.
    	  // `collectNonEnumProps` used to depend on `_.contains`, but this led to
    	  // circular imports. `emulatedSet` is a one-off solution that only works for
    	  // arrays of strings.
    	  function emulatedSet(keys) {
    	    var hash = {};
    	    for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
    	    return {
    	      contains: function(key) { return hash[key] === true; },
    	      push: function(key) {
    	        hash[key] = true;
    	        return keys.push(key);
    	      }
    	    };
    	  }

    	  // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
    	  // be iterated by `for key in ...` and thus missed. Extends `keys` in place if
    	  // needed.
    	  function collectNonEnumProps(obj, keys) {
    	    keys = emulatedSet(keys);
    	    var nonEnumIdx = nonEnumerableProps.length;
    	    var constructor = obj.constructor;
    	    var proto = (isFunction$1(constructor) && constructor.prototype) || ObjProto;

    	    // Constructor is a special case.
    	    var prop = 'constructor';
    	    if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);

    	    while (nonEnumIdx--) {
    	      prop = nonEnumerableProps[nonEnumIdx];
    	      if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
    	        keys.push(prop);
    	      }
    	    }
    	  }

    	  // Retrieve the names of an object's own properties.
    	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
    	  function keys(obj) {
    	    if (!isObject(obj)) return [];
    	    if (nativeKeys) return nativeKeys(obj);
    	    var keys = [];
    	    for (var key in obj) if (has$1(obj, key)) keys.push(key);
    	    // Ahem, IE < 9.
    	    if (hasEnumBug) collectNonEnumProps(obj, keys);
    	    return keys;
    	  }

    	  // Is a given array, string, or object empty?
    	  // An "empty" object has no enumerable own-properties.
    	  function isEmpty(obj) {
    	    if (obj == null) return true;
    	    // Skip the more expensive `toString`-based type checks if `obj` has no
    	    // `.length`.
    	    var length = getLength(obj);
    	    if (typeof length == 'number' && (
    	      isArray(obj) || isString(obj) || isArguments$1(obj)
    	    )) return length === 0;
    	    return getLength(keys(obj)) === 0;
    	  }

    	  // Returns whether an object has a given set of `key:value` pairs.
    	  function isMatch(object, attrs) {
    	    var _keys = keys(attrs), length = _keys.length;
    	    if (object == null) return !length;
    	    var obj = Object(object);
    	    for (var i = 0; i < length; i++) {
    	      var key = _keys[i];
    	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    	    }
    	    return true;
    	  }

    	  // If Underscore is called as a function, it returns a wrapped object that can
    	  // be used OO-style. This wrapper holds altered versions of all functions added
    	  // through `_.mixin`. Wrapped objects may be chained.
    	  function _$1(obj) {
    	    if (obj instanceof _$1) return obj;
    	    if (!(this instanceof _$1)) return new _$1(obj);
    	    this._wrapped = obj;
    	  }

    	  _$1.VERSION = VERSION;

    	  // Extracts the result from a wrapped and chained object.
    	  _$1.prototype.value = function() {
    	    return this._wrapped;
    	  };

    	  // Provide unwrapping proxies for some methods used in engine operations
    	  // such as arithmetic and JSON stringification.
    	  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;

    	  _$1.prototype.toString = function() {
    	    return String(this._wrapped);
    	  };

    	  // Internal function to wrap or shallow-copy an ArrayBuffer,
    	  // typed array or DataView to a new view, reusing the buffer.
    	  function toBufferView(bufferSource) {
    	    return new Uint8Array(
    	      bufferSource.buffer || bufferSource,
    	      bufferSource.byteOffset || 0,
    	      getByteLength(bufferSource)
    	    );
    	  }

    	  // We use this string twice, so give it a name for minification.
    	  var tagDataView = '[object DataView]';

    	  // Internal recursive comparison function for `_.isEqual`.
    	  function eq(a, b, aStack, bStack) {
    	    // Identical objects are equal. `0 === -0`, but they aren't identical.
    	    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
    	    if (a === b) return a !== 0 || 1 / a === 1 / b;
    	    // `null` or `undefined` only equal to itself (strict comparison).
    	    if (a == null || b == null) return false;
    	    // `NaN`s are equivalent, but non-reflexive.
    	    if (a !== a) return b !== b;
    	    // Exhaust primitive checks
    	    var type = typeof a;
    	    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    	    return deepEq(a, b, aStack, bStack);
    	  }

    	  // Internal recursive comparison function for `_.isEqual`.
    	  function deepEq(a, b, aStack, bStack) {
    	    // Unwrap any wrapped objects.
    	    if (a instanceof _$1) a = a._wrapped;
    	    if (b instanceof _$1) b = b._wrapped;
    	    // Compare `[[Class]]` names.
    	    var className = toString.call(a);
    	    if (className !== toString.call(b)) return false;
    	    // Work around a bug in IE 10 - Edge 13.
    	    if (hasStringTagBug && className == '[object Object]' && isDataView$1(a)) {
    	      if (!isDataView$1(b)) return false;
    	      className = tagDataView;
    	    }
    	    switch (className) {
    	      // These types are compared by value.
    	      case '[object RegExp]':
    	        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    	      case '[object String]':
    	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
    	        // equivalent to `new String("5")`.
    	        return '' + a === '' + b;
    	      case '[object Number]':
    	        // `NaN`s are equivalent, but non-reflexive.
    	        // Object(NaN) is equivalent to NaN.
    	        if (+a !== +a) return +b !== +b;
    	        // An `egal` comparison is performed for other numeric values.
    	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    	      case '[object Date]':
    	      case '[object Boolean]':
    	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
    	        // millisecond representations. Note that invalid dates with millisecond representations
    	        // of `NaN` are not equivalent.
    	        return +a === +b;
    	      case '[object Symbol]':
    	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    	      case '[object ArrayBuffer]':
    	      case tagDataView:
    	        // Coerce to typed array so we can fall through.
    	        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
    	    }

    	    var areArrays = className === '[object Array]';
    	    if (!areArrays && isTypedArray$1(a)) {
    	        var byteLength = getByteLength(a);
    	        if (byteLength !== getByteLength(b)) return false;
    	        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    	        areArrays = true;
    	    }
    	    if (!areArrays) {
    	      if (typeof a != 'object' || typeof b != 'object') return false;

    	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    	      // from different frames are.
    	      var aCtor = a.constructor, bCtor = b.constructor;
    	      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&
    	                               isFunction$1(bCtor) && bCtor instanceof bCtor)
    	                          && ('constructor' in a && 'constructor' in b)) {
    	        return false;
    	      }
    	    }
    	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    	    // Initializing stack of traversed objects.
    	    // It's done here since we only need them for objects and arrays comparison.
    	    aStack = aStack || [];
    	    bStack = bStack || [];
    	    var length = aStack.length;
    	    while (length--) {
    	      // Linear search. Performance is inversely proportional to the number of
    	      // unique nested structures.
    	      if (aStack[length] === a) return bStack[length] === b;
    	    }

    	    // Add the first object to the stack of traversed objects.
    	    aStack.push(a);
    	    bStack.push(b);

    	    // Recursively compare objects and arrays.
    	    if (areArrays) {
    	      // Compare array lengths to determine if a deep comparison is necessary.
    	      length = a.length;
    	      if (length !== b.length) return false;
    	      // Deep compare the contents, ignoring non-numeric properties.
    	      while (length--) {
    	        if (!eq(a[length], b[length], aStack, bStack)) return false;
    	      }
    	    } else {
    	      // Deep compare objects.
    	      var _keys = keys(a), key;
    	      length = _keys.length;
    	      // Ensure that both objects contain the same number of properties before comparing deep equality.
    	      if (keys(b).length !== length) return false;
    	      while (length--) {
    	        // Deep compare each member
    	        key = _keys[length];
    	        if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    	      }
    	    }
    	    // Remove the first object from the stack of traversed objects.
    	    aStack.pop();
    	    bStack.pop();
    	    return true;
    	  }

    	  // Perform a deep comparison to check if two objects are equal.
    	  function isEqual(a, b) {
    	    return eq(a, b);
    	  }

    	  // Retrieve all the enumerable property names of an object.
    	  function allKeys(obj) {
    	    if (!isObject(obj)) return [];
    	    var keys = [];
    	    for (var key in obj) keys.push(key);
    	    // Ahem, IE < 9.
    	    if (hasEnumBug) collectNonEnumProps(obj, keys);
    	    return keys;
    	  }

    	  // Since the regular `Object.prototype.toString` type tests don't work for
    	  // some types in IE 11, we use a fingerprinting heuristic instead, based
    	  // on the methods. It's not great, but it's the best we got.
    	  // The fingerprint method lists are defined below.
    	  function ie11fingerprint(methods) {
    	    var length = getLength(methods);
    	    return function(obj) {
    	      if (obj == null) return false;
    	      // `Map`, `WeakMap` and `Set` have no enumerable keys.
    	      var keys = allKeys(obj);
    	      if (getLength(keys)) return false;
    	      for (var i = 0; i < length; i++) {
    	        if (!isFunction$1(obj[methods[i]])) return false;
    	      }
    	      // If we are testing against `WeakMap`, we need to ensure that
    	      // `obj` doesn't have a `forEach` method in order to distinguish
    	      // it from a regular `Map`.
    	      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
    	    };
    	  }

    	  // In the interest of compact minification, we write
    	  // each string in the fingerprints only once.
    	  var forEachName = 'forEach',
    	      hasName = 'has',
    	      commonInit = ['clear', 'delete'],
    	      mapTail = ['get', hasName, 'set'];

    	  // `Map`, `WeakMap` and `Set` each have slightly different
    	  // combinations of the above sublists.
    	  var mapMethods = commonInit.concat(forEachName, mapTail),
    	      weakMapMethods = commonInit.concat(mapTail),
    	      setMethods = ['add'].concat(commonInit, forEachName, hasName);

    	  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

    	  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

    	  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

    	  var isWeakSet = tagTester('WeakSet');

    	  // Retrieve the values of an object's properties.
    	  function values(obj) {
    	    var _keys = keys(obj);
    	    var length = _keys.length;
    	    var values = Array(length);
    	    for (var i = 0; i < length; i++) {
    	      values[i] = obj[_keys[i]];
    	    }
    	    return values;
    	  }

    	  // Convert an object into a list of `[key, value]` pairs.
    	  // The opposite of `_.object` with one argument.
    	  function pairs(obj) {
    	    var _keys = keys(obj);
    	    var length = _keys.length;
    	    var pairs = Array(length);
    	    for (var i = 0; i < length; i++) {
    	      pairs[i] = [_keys[i], obj[_keys[i]]];
    	    }
    	    return pairs;
    	  }

    	  // Invert the keys and values of an object. The values must be serializable.
    	  function invert(obj) {
    	    var result = {};
    	    var _keys = keys(obj);
    	    for (var i = 0, length = _keys.length; i < length; i++) {
    	      result[obj[_keys[i]]] = _keys[i];
    	    }
    	    return result;
    	  }

    	  // Return a sorted list of the function names available on the object.
    	  function functions(obj) {
    	    var names = [];
    	    for (var key in obj) {
    	      if (isFunction$1(obj[key])) names.push(key);
    	    }
    	    return names.sort();
    	  }

    	  // An internal function for creating assigner functions.
    	  function createAssigner(keysFunc, defaults) {
    	    return function(obj) {
    	      var length = arguments.length;
    	      if (defaults) obj = Object(obj);
    	      if (length < 2 || obj == null) return obj;
    	      for (var index = 1; index < length; index++) {
    	        var source = arguments[index],
    	            keys = keysFunc(source),
    	            l = keys.length;
    	        for (var i = 0; i < l; i++) {
    	          var key = keys[i];
    	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
    	        }
    	      }
    	      return obj;
    	    };
    	  }

    	  // Extend a given object with all the properties in passed-in object(s).
    	  var extend = createAssigner(allKeys);

    	  // Assigns a given object with all the own properties in the passed-in
    	  // object(s).
    	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
    	  var extendOwn = createAssigner(keys);

    	  // Fill in a given object with default properties.
    	  var defaults = createAssigner(allKeys, true);

    	  // Create a naked function reference for surrogate-prototype-swapping.
    	  function ctor() {
    	    return function(){};
    	  }

    	  // An internal function for creating a new object that inherits from another.
    	  function baseCreate(prototype) {
    	    if (!isObject(prototype)) return {};
    	    if (nativeCreate) return nativeCreate(prototype);
    	    var Ctor = ctor();
    	    Ctor.prototype = prototype;
    	    var result = new Ctor;
    	    Ctor.prototype = null;
    	    return result;
    	  }

    	  // Creates an object that inherits from the given prototype object.
    	  // If additional properties are provided then they will be added to the
    	  // created object.
    	  function create(prototype, props) {
    	    var result = baseCreate(prototype);
    	    if (props) extendOwn(result, props);
    	    return result;
    	  }

    	  // Create a (shallow-cloned) duplicate of an object.
    	  function clone(obj) {
    	    if (!isObject(obj)) return obj;
    	    return isArray(obj) ? obj.slice() : extend({}, obj);
    	  }

    	  // Invokes `interceptor` with the `obj` and then returns `obj`.
    	  // The primary purpose of this method is to "tap into" a method chain, in
    	  // order to perform operations on intermediate results within the chain.
    	  function tap(obj, interceptor) {
    	    interceptor(obj);
    	    return obj;
    	  }

    	  // Normalize a (deep) property `path` to array.
    	  // Like `_.iteratee`, this function can be customized.
    	  function toPath$1(path) {
    	    return isArray(path) ? path : [path];
    	  }
    	  _$1.toPath = toPath$1;

    	  // Internal wrapper for `_.toPath` to enable minification.
    	  // Similar to `cb` for `_.iteratee`.
    	  function toPath(path) {
    	    return _$1.toPath(path);
    	  }

    	  // Internal function to obtain a nested property in `obj` along `path`.
    	  function deepGet(obj, path) {
    	    var length = path.length;
    	    for (var i = 0; i < length; i++) {
    	      if (obj == null) return void 0;
    	      obj = obj[path[i]];
    	    }
    	    return length ? obj : void 0;
    	  }

    	  // Get the value of the (deep) property on `path` from `object`.
    	  // If any property in `path` does not exist or if the value is
    	  // `undefined`, return `defaultValue` instead.
    	  // The `path` is normalized through `_.toPath`.
    	  function get(object, path, defaultValue) {
    	    var value = deepGet(object, toPath(path));
    	    return isUndefined(value) ? defaultValue : value;
    	  }

    	  // Shortcut function for checking if an object has a given property directly on
    	  // itself (in other words, not on a prototype). Unlike the internal `has`
    	  // function, this public version can also traverse nested properties.
    	  function has(obj, path) {
    	    path = toPath(path);
    	    var length = path.length;
    	    for (var i = 0; i < length; i++) {
    	      var key = path[i];
    	      if (!has$1(obj, key)) return false;
    	      obj = obj[key];
    	    }
    	    return !!length;
    	  }

    	  // Keep the identity function around for default iteratees.
    	  function identity(value) {
    	    return value;
    	  }

    	  // Returns a predicate for checking whether an object has a given set of
    	  // `key:value` pairs.
    	  function matcher(attrs) {
    	    attrs = extendOwn({}, attrs);
    	    return function(obj) {
    	      return isMatch(obj, attrs);
    	    };
    	  }

    	  // Creates a function that, when passed an object, will traverse that object’s
    	  // properties down the given `path`, specified as an array of keys or indices.
    	  function property(path) {
    	    path = toPath(path);
    	    return function(obj) {
    	      return deepGet(obj, path);
    	    };
    	  }

    	  // Internal function that returns an efficient (for current engines) version
    	  // of the passed-in callback, to be repeatedly applied in other Underscore
    	  // functions.
    	  function optimizeCb(func, context, argCount) {
    	    if (context === void 0) return func;
    	    switch (argCount == null ? 3 : argCount) {
    	      case 1: return function(value) {
    	        return func.call(context, value);
    	      };
    	      // The 2-argument case is omitted because we’re not using it.
    	      case 3: return function(value, index, collection) {
    	        return func.call(context, value, index, collection);
    	      };
    	      case 4: return function(accumulator, value, index, collection) {
    	        return func.call(context, accumulator, value, index, collection);
    	      };
    	    }
    	    return function() {
    	      return func.apply(context, arguments);
    	    };
    	  }

    	  // An internal function to generate callbacks that can be applied to each
    	  // element in a collection, returning the desired result — either `_.identity`,
    	  // an arbitrary callback, a property matcher, or a property accessor.
    	  function baseIteratee(value, context, argCount) {
    	    if (value == null) return identity;
    	    if (isFunction$1(value)) return optimizeCb(value, context, argCount);
    	    if (isObject(value) && !isArray(value)) return matcher(value);
    	    return property(value);
    	  }

    	  // External wrapper for our callback generator. Users may customize
    	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
    	  // This abstraction hides the internal-only `argCount` argument.
    	  function iteratee(value, context) {
    	    return baseIteratee(value, context, Infinity);
    	  }
    	  _$1.iteratee = iteratee;

    	  // The function we call internally to generate a callback. It invokes
    	  // `_.iteratee` if overridden, otherwise `baseIteratee`.
    	  function cb(value, context, argCount) {
    	    if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
    	    return baseIteratee(value, context, argCount);
    	  }

    	  // Returns the results of applying the `iteratee` to each element of `obj`.
    	  // In contrast to `_.map` it returns an object.
    	  function mapObject(obj, iteratee, context) {
    	    iteratee = cb(iteratee, context);
    	    var _keys = keys(obj),
    	        length = _keys.length,
    	        results = {};
    	    for (var index = 0; index < length; index++) {
    	      var currentKey = _keys[index];
    	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    	    }
    	    return results;
    	  }

    	  // Predicate-generating function. Often useful outside of Underscore.
    	  function noop(){}

    	  // Generates a function for a given object that returns a given property.
    	  function propertyOf(obj) {
    	    if (obj == null) return noop;
    	    return function(path) {
    	      return get(obj, path);
    	    };
    	  }

    	  // Run a function **n** times.
    	  function times(n, iteratee, context) {
    	    var accum = Array(Math.max(0, n));
    	    iteratee = optimizeCb(iteratee, context, 1);
    	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    	    return accum;
    	  }

    	  // Return a random integer between `min` and `max` (inclusive).
    	  function random(min, max) {
    	    if (max == null) {
    	      max = min;
    	      min = 0;
    	    }
    	    return min + Math.floor(Math.random() * (max - min + 1));
    	  }

    	  // A (possibly faster) way to get the current timestamp as an integer.
    	  var now = Date.now || function() {
    	    return new Date().getTime();
    	  };

    	  // Internal helper to generate functions for escaping and unescaping strings
    	  // to/from HTML interpolation.
    	  function createEscaper(map) {
    	    var escaper = function(match) {
    	      return map[match];
    	    };
    	    // Regexes for identifying a key that needs to be escaped.
    	    var source = '(?:' + keys(map).join('|') + ')';
    	    var testRegexp = RegExp(source);
    	    var replaceRegexp = RegExp(source, 'g');
    	    return function(string) {
    	      string = string == null ? '' : '' + string;
    	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    	    };
    	  }

    	  // Internal list of HTML entities for escaping.
    	  var escapeMap = {
    	    '&': '&amp;',
    	    '<': '&lt;',
    	    '>': '&gt;',
    	    '"': '&quot;',
    	    "'": '&#x27;',
    	    '`': '&#x60;'
    	  };

    	  // Function for escaping strings to HTML interpolation.
    	  var _escape = createEscaper(escapeMap);

    	  // Internal list of HTML entities for unescaping.
    	  var unescapeMap = invert(escapeMap);

    	  // Function for unescaping strings from HTML interpolation.
    	  var _unescape = createEscaper(unescapeMap);

    	  // By default, Underscore uses ERB-style template delimiters. Change the
    	  // following template settings to use alternative delimiters.
    	  var templateSettings = _$1.templateSettings = {
    	    evaluate: /<%([\s\S]+?)%>/g,
    	    interpolate: /<%=([\s\S]+?)%>/g,
    	    escape: /<%-([\s\S]+?)%>/g
    	  };

    	  // When customizing `_.templateSettings`, if you don't want to define an
    	  // interpolation, evaluation or escaping regex, we need one that is
    	  // guaranteed not to match.
    	  var noMatch = /(.)^/;

    	  // Certain characters need to be escaped so that they can be put into a
    	  // string literal.
    	  var escapes = {
    	    "'": "'",
    	    '\\': '\\',
    	    '\r': 'r',
    	    '\n': 'n',
    	    '\u2028': 'u2028',
    	    '\u2029': 'u2029'
    	  };

    	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

    	  function escapeChar(match) {
    	    return '\\' + escapes[match];
    	  }

    	  // In order to prevent third-party code injection through
    	  // `_.templateSettings.variable`, we test it against the following regular
    	  // expression. It is intentionally a bit more liberal than just matching valid
    	  // identifiers, but still prevents possible loopholes through defaults or
    	  // destructuring assignment.
    	  var bareIdentifier = /^\s*(\w|\$)+\s*$/;

    	  // JavaScript micro-templating, similar to John Resig's implementation.
    	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
    	  // and correctly escapes quotes within interpolated code.
    	  // NB: `oldSettings` only exists for backwards compatibility.
    	  function template(text, settings, oldSettings) {
    	    if (!settings && oldSettings) settings = oldSettings;
    	    settings = defaults({}, settings, _$1.templateSettings);

    	    // Combine delimiters into one regular expression via alternation.
    	    var matcher = RegExp([
    	      (settings.escape || noMatch).source,
    	      (settings.interpolate || noMatch).source,
    	      (settings.evaluate || noMatch).source
    	    ].join('|') + '|$', 'g');

    	    // Compile the template source, escaping string literals appropriately.
    	    var index = 0;
    	    var source = "__p+='";
    	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    	      index = offset + match.length;

    	      if (escape) {
    	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    	      } else if (interpolate) {
    	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    	      } else if (evaluate) {
    	        source += "';\n" + evaluate + "\n__p+='";
    	      }

    	      // Adobe VMs need the match returned to produce the correct offset.
    	      return match;
    	    });
    	    source += "';\n";

    	    var argument = settings.variable;
    	    if (argument) {
    	      // Insure against third-party code injection. (CVE-2021-23358)
    	      if (!bareIdentifier.test(argument)) throw new Error(
    	        'variable is not a bare identifier: ' + argument
    	      );
    	    } else {
    	      // If a variable is not specified, place data values in local scope.
    	      source = 'with(obj||{}){\n' + source + '}\n';
    	      argument = 'obj';
    	    }

    	    source = "var __t,__p='',__j=Array.prototype.join," +
    	      "print=function(){__p+=__j.call(arguments,'');};\n" +
    	      source + 'return __p;\n';

    	    var render;
    	    try {
    	      render = new Function(argument, '_', source);
    	    } catch (e) {
    	      e.source = source;
    	      throw e;
    	    }

    	    var template = function(data) {
    	      return render.call(this, data, _$1);
    	    };

    	    // Provide the compiled source as a convenience for precompilation.
    	    template.source = 'function(' + argument + '){\n' + source + '}';

    	    return template;
    	  }

    	  // Traverses the children of `obj` along `path`. If a child is a function, it
    	  // is invoked with its parent as context. Returns the value of the final
    	  // child, or `fallback` if any child is undefined.
    	  function result(obj, path, fallback) {
    	    path = toPath(path);
    	    var length = path.length;
    	    if (!length) {
    	      return isFunction$1(fallback) ? fallback.call(obj) : fallback;
    	    }
    	    for (var i = 0; i < length; i++) {
    	      var prop = obj == null ? void 0 : obj[path[i]];
    	      if (prop === void 0) {
    	        prop = fallback;
    	        i = length; // Ensure we don't continue iterating.
    	      }
    	      obj = isFunction$1(prop) ? prop.call(obj) : prop;
    	    }
    	    return obj;
    	  }

    	  // Generate a unique integer id (unique within the entire client session).
    	  // Useful for temporary DOM ids.
    	  var idCounter = 0;
    	  function uniqueId(prefix) {
    	    var id = ++idCounter + '';
    	    return prefix ? prefix + id : id;
    	  }

    	  // Start chaining a wrapped Underscore object.
    	  function chain(obj) {
    	    var instance = _$1(obj);
    	    instance._chain = true;
    	    return instance;
    	  }

    	  // Internal function to execute `sourceFunc` bound to `context` with optional
    	  // `args`. Determines whether to execute a function as a constructor or as a
    	  // normal function.
    	  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    	    var self = baseCreate(sourceFunc.prototype);
    	    var result = sourceFunc.apply(self, args);
    	    if (isObject(result)) return result;
    	    return self;
    	  }

    	  // Partially apply a function by creating a version that has had some of its
    	  // arguments pre-filled, without changing its dynamic `this` context. `_` acts
    	  // as a placeholder by default, allowing any combination of arguments to be
    	  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
    	  var partial = restArguments(function(func, boundArgs) {
    	    var placeholder = partial.placeholder;
    	    var bound = function() {
    	      var position = 0, length = boundArgs.length;
    	      var args = Array(length);
    	      for (var i = 0; i < length; i++) {
    	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    	      }
    	      while (position < arguments.length) args.push(arguments[position++]);
    	      return executeBound(func, bound, this, this, args);
    	    };
    	    return bound;
    	  });

    	  partial.placeholder = _$1;

    	  // Create a function bound to a given object (assigning `this`, and arguments,
    	  // optionally).
    	  var bind = restArguments(function(func, context, args) {
    	    if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');
    	    var bound = restArguments(function(callArgs) {
    	      return executeBound(func, bound, context, this, args.concat(callArgs));
    	    });
    	    return bound;
    	  });

    	  // Internal helper for collection methods to determine whether a collection
    	  // should be iterated as an array or as an object.
    	  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
    	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
    	  var isArrayLike = createSizePropertyCheck(getLength);

    	  // Internal implementation of a recursive `flatten` function.
    	  function flatten$1(input, depth, strict, output) {
    	    output = output || [];
    	    if (!depth && depth !== 0) {
    	      depth = Infinity;
    	    } else if (depth <= 0) {
    	      return output.concat(input);
    	    }
    	    var idx = output.length;
    	    for (var i = 0, length = getLength(input); i < length; i++) {
    	      var value = input[i];
    	      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
    	        // Flatten current level of array or arguments object.
    	        if (depth > 1) {
    	          flatten$1(value, depth - 1, strict, output);
    	          idx = output.length;
    	        } else {
    	          var j = 0, len = value.length;
    	          while (j < len) output[idx++] = value[j++];
    	        }
    	      } else if (!strict) {
    	        output[idx++] = value;
    	      }
    	    }
    	    return output;
    	  }

    	  // Bind a number of an object's methods to that object. Remaining arguments
    	  // are the method names to be bound. Useful for ensuring that all callbacks
    	  // defined on an object belong to it.
    	  var bindAll = restArguments(function(obj, keys) {
    	    keys = flatten$1(keys, false, false);
    	    var index = keys.length;
    	    if (index < 1) throw new Error('bindAll must be passed function names');
    	    while (index--) {
    	      var key = keys[index];
    	      obj[key] = bind(obj[key], obj);
    	    }
    	    return obj;
    	  });

    	  // Memoize an expensive function by storing its results.
    	  function memoize(func, hasher) {
    	    var memoize = function(key) {
    	      var cache = memoize.cache;
    	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    	      if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
    	      return cache[address];
    	    };
    	    memoize.cache = {};
    	    return memoize;
    	  }

    	  // Delays a function for the given number of milliseconds, and then calls
    	  // it with the arguments supplied.
    	  var delay = restArguments(function(func, wait, args) {
    	    return setTimeout(function() {
    	      return func.apply(null, args);
    	    }, wait);
    	  });

    	  // Defers a function, scheduling it to run after the current call stack has
    	  // cleared.
    	  var defer = partial(delay, _$1, 1);

    	  // Returns a function, that, when invoked, will only be triggered at most once
    	  // during a given window of time. Normally, the throttled function will run
    	  // as much as it can, without ever going more than once per `wait` duration;
    	  // but if you'd like to disable the execution on the leading edge, pass
    	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
    	  function throttle(func, wait, options) {
    	    var timeout, context, args, result;
    	    var previous = 0;
    	    if (!options) options = {};

    	    var later = function() {
    	      previous = options.leading === false ? 0 : now();
    	      timeout = null;
    	      result = func.apply(context, args);
    	      if (!timeout) context = args = null;
    	    };

    	    var throttled = function() {
    	      var _now = now();
    	      if (!previous && options.leading === false) previous = _now;
    	      var remaining = wait - (_now - previous);
    	      context = this;
    	      args = arguments;
    	      if (remaining <= 0 || remaining > wait) {
    	        if (timeout) {
    	          clearTimeout(timeout);
    	          timeout = null;
    	        }
    	        previous = _now;
    	        result = func.apply(context, args);
    	        if (!timeout) context = args = null;
    	      } else if (!timeout && options.trailing !== false) {
    	        timeout = setTimeout(later, remaining);
    	      }
    	      return result;
    	    };

    	    throttled.cancel = function() {
    	      clearTimeout(timeout);
    	      previous = 0;
    	      timeout = context = args = null;
    	    };

    	    return throttled;
    	  }

    	  // When a sequence of calls of the returned function ends, the argument
    	  // function is triggered. The end of a sequence is defined by the `wait`
    	  // parameter. If `immediate` is passed, the argument function will be
    	  // triggered at the beginning of the sequence instead of at the end.
    	  function debounce(func, wait, immediate) {
    	    var timeout, previous, args, result, context;

    	    var later = function() {
    	      var passed = now() - previous;
    	      if (wait > passed) {
    	        timeout = setTimeout(later, wait - passed);
    	      } else {
    	        timeout = null;
    	        if (!immediate) result = func.apply(context, args);
    	        // This check is needed because `func` can recursively invoke `debounced`.
    	        if (!timeout) args = context = null;
    	      }
    	    };

    	    var debounced = restArguments(function(_args) {
    	      context = this;
    	      args = _args;
    	      previous = now();
    	      if (!timeout) {
    	        timeout = setTimeout(later, wait);
    	        if (immediate) result = func.apply(context, args);
    	      }
    	      return result;
    	    });

    	    debounced.cancel = function() {
    	      clearTimeout(timeout);
    	      timeout = args = context = null;
    	    };

    	    return debounced;
    	  }

    	  // Returns the first function passed as an argument to the second,
    	  // allowing you to adjust arguments, run code before and after, and
    	  // conditionally execute the original function.
    	  function wrap(func, wrapper) {
    	    return partial(wrapper, func);
    	  }

    	  // Returns a negated version of the passed-in predicate.
    	  function negate(predicate) {
    	    return function() {
    	      return !predicate.apply(this, arguments);
    	    };
    	  }

    	  // Returns a function that is the composition of a list of functions, each
    	  // consuming the return value of the function that follows.
    	  function compose() {
    	    var args = arguments;
    	    var start = args.length - 1;
    	    return function() {
    	      var i = start;
    	      var result = args[start].apply(this, arguments);
    	      while (i--) result = args[i].call(this, result);
    	      return result;
    	    };
    	  }

    	  // Returns a function that will only be executed on and after the Nth call.
    	  function after(times, func) {
    	    return function() {
    	      if (--times < 1) {
    	        return func.apply(this, arguments);
    	      }
    	    };
    	  }

    	  // Returns a function that will only be executed up to (but not including) the
    	  // Nth call.
    	  function before(times, func) {
    	    var memo;
    	    return function() {
    	      if (--times > 0) {
    	        memo = func.apply(this, arguments);
    	      }
    	      if (times <= 1) func = null;
    	      return memo;
    	    };
    	  }

    	  // Returns a function that will be executed at most one time, no matter how
    	  // often you call it. Useful for lazy initialization.
    	  var once = partial(before, 2);

    	  // Returns the first key on an object that passes a truth test.
    	  function findKey(obj, predicate, context) {
    	    predicate = cb(predicate, context);
    	    var _keys = keys(obj), key;
    	    for (var i = 0, length = _keys.length; i < length; i++) {
    	      key = _keys[i];
    	      if (predicate(obj[key], key, obj)) return key;
    	    }
    	  }

    	  // Internal function to generate `_.findIndex` and `_.findLastIndex`.
    	  function createPredicateIndexFinder(dir) {
    	    return function(array, predicate, context) {
    	      predicate = cb(predicate, context);
    	      var length = getLength(array);
    	      var index = dir > 0 ? 0 : length - 1;
    	      for (; index >= 0 && index < length; index += dir) {
    	        if (predicate(array[index], index, array)) return index;
    	      }
    	      return -1;
    	    };
    	  }

    	  // Returns the first index on an array-like that passes a truth test.
    	  var findIndex = createPredicateIndexFinder(1);

    	  // Returns the last index on an array-like that passes a truth test.
    	  var findLastIndex = createPredicateIndexFinder(-1);

    	  // Use a comparator function to figure out the smallest index at which
    	  // an object should be inserted so as to maintain order. Uses binary search.
    	  function sortedIndex(array, obj, iteratee, context) {
    	    iteratee = cb(iteratee, context, 1);
    	    var value = iteratee(obj);
    	    var low = 0, high = getLength(array);
    	    while (low < high) {
    	      var mid = Math.floor((low + high) / 2);
    	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    	    }
    	    return low;
    	  }

    	  // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
    	  function createIndexFinder(dir, predicateFind, sortedIndex) {
    	    return function(array, item, idx) {
    	      var i = 0, length = getLength(array);
    	      if (typeof idx == 'number') {
    	        if (dir > 0) {
    	          i = idx >= 0 ? idx : Math.max(idx + length, i);
    	        } else {
    	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
    	        }
    	      } else if (sortedIndex && idx && length) {
    	        idx = sortedIndex(array, item);
    	        return array[idx] === item ? idx : -1;
    	      }
    	      if (item !== item) {
    	        idx = predicateFind(slice.call(array, i, length), isNaN$1);
    	        return idx >= 0 ? idx + i : -1;
    	      }
    	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
    	        if (array[idx] === item) return idx;
    	      }
    	      return -1;
    	    };
    	  }

    	  // Return the position of the first occurrence of an item in an array,
    	  // or -1 if the item is not included in the array.
    	  // If the array is large and already in sort order, pass `true`
    	  // for **isSorted** to use binary search.
    	  var indexOf = createIndexFinder(1, findIndex, sortedIndex);

    	  // Return the position of the last occurrence of an item in an array,
    	  // or -1 if the item is not included in the array.
    	  var lastIndexOf = createIndexFinder(-1, findLastIndex);

    	  // Return the first value which passes a truth test.
    	  function find(obj, predicate, context) {
    	    var keyFinder = isArrayLike(obj) ? findIndex : findKey;
    	    var key = keyFinder(obj, predicate, context);
    	    if (key !== void 0 && key !== -1) return obj[key];
    	  }

    	  // Convenience version of a common use case of `_.find`: getting the first
    	  // object containing specific `key:value` pairs.
    	  function findWhere(obj, attrs) {
    	    return find(obj, matcher(attrs));
    	  }

    	  // The cornerstone for collection functions, an `each`
    	  // implementation, aka `forEach`.
    	  // Handles raw objects in addition to array-likes. Treats all
    	  // sparse array-likes as if they were dense.
    	  function each(obj, iteratee, context) {
    	    iteratee = optimizeCb(iteratee, context);
    	    var i, length;
    	    if (isArrayLike(obj)) {
    	      for (i = 0, length = obj.length; i < length; i++) {
    	        iteratee(obj[i], i, obj);
    	      }
    	    } else {
    	      var _keys = keys(obj);
    	      for (i = 0, length = _keys.length; i < length; i++) {
    	        iteratee(obj[_keys[i]], _keys[i], obj);
    	      }
    	    }
    	    return obj;
    	  }

    	  // Return the results of applying the iteratee to each element.
    	  function map(obj, iteratee, context) {
    	    iteratee = cb(iteratee, context);
    	    var _keys = !isArrayLike(obj) && keys(obj),
    	        length = (_keys || obj).length,
    	        results = Array(length);
    	    for (var index = 0; index < length; index++) {
    	      var currentKey = _keys ? _keys[index] : index;
    	      results[index] = iteratee(obj[currentKey], currentKey, obj);
    	    }
    	    return results;
    	  }

    	  // Internal helper to create a reducing function, iterating left or right.
    	  function createReduce(dir) {
    	    // Wrap code that reassigns argument variables in a separate function than
    	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    	    var reducer = function(obj, iteratee, memo, initial) {
    	      var _keys = !isArrayLike(obj) && keys(obj),
    	          length = (_keys || obj).length,
    	          index = dir > 0 ? 0 : length - 1;
    	      if (!initial) {
    	        memo = obj[_keys ? _keys[index] : index];
    	        index += dir;
    	      }
    	      for (; index >= 0 && index < length; index += dir) {
    	        var currentKey = _keys ? _keys[index] : index;
    	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
    	      }
    	      return memo;
    	    };

    	    return function(obj, iteratee, memo, context) {
    	      var initial = arguments.length >= 3;
    	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    	    };
    	  }

    	  // **Reduce** builds up a single result from a list of values, aka `inject`,
    	  // or `foldl`.
    	  var reduce = createReduce(1);

    	  // The right-associative version of reduce, also known as `foldr`.
    	  var reduceRight = createReduce(-1);

    	  // Return all the elements that pass a truth test.
    	  function filter(obj, predicate, context) {
    	    var results = [];
    	    predicate = cb(predicate, context);
    	    each(obj, function(value, index, list) {
    	      if (predicate(value, index, list)) results.push(value);
    	    });
    	    return results;
    	  }

    	  // Return all the elements for which a truth test fails.
    	  function reject(obj, predicate, context) {
    	    return filter(obj, negate(cb(predicate)), context);
    	  }

    	  // Determine whether all of the elements pass a truth test.
    	  function every(obj, predicate, context) {
    	    predicate = cb(predicate, context);
    	    var _keys = !isArrayLike(obj) && keys(obj),
    	        length = (_keys || obj).length;
    	    for (var index = 0; index < length; index++) {
    	      var currentKey = _keys ? _keys[index] : index;
    	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    	    }
    	    return true;
    	  }

    	  // Determine if at least one element in the object passes a truth test.
    	  function some(obj, predicate, context) {
    	    predicate = cb(predicate, context);
    	    var _keys = !isArrayLike(obj) && keys(obj),
    	        length = (_keys || obj).length;
    	    for (var index = 0; index < length; index++) {
    	      var currentKey = _keys ? _keys[index] : index;
    	      if (predicate(obj[currentKey], currentKey, obj)) return true;
    	    }
    	    return false;
    	  }

    	  // Determine if the array or object contains a given item (using `===`).
    	  function contains(obj, item, fromIndex, guard) {
    	    if (!isArrayLike(obj)) obj = values(obj);
    	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    	    return indexOf(obj, item, fromIndex) >= 0;
    	  }

    	  // Invoke a method (with arguments) on every item in a collection.
    	  var invoke = restArguments(function(obj, path, args) {
    	    var contextPath, func;
    	    if (isFunction$1(path)) {
    	      func = path;
    	    } else {
    	      path = toPath(path);
    	      contextPath = path.slice(0, -1);
    	      path = path[path.length - 1];
    	    }
    	    return map(obj, function(context) {
    	      var method = func;
    	      if (!method) {
    	        if (contextPath && contextPath.length) {
    	          context = deepGet(context, contextPath);
    	        }
    	        if (context == null) return void 0;
    	        method = context[path];
    	      }
    	      return method == null ? method : method.apply(context, args);
    	    });
    	  });

    	  // Convenience version of a common use case of `_.map`: fetching a property.
    	  function pluck(obj, key) {
    	    return map(obj, property(key));
    	  }

    	  // Convenience version of a common use case of `_.filter`: selecting only
    	  // objects containing specific `key:value` pairs.
    	  function where(obj, attrs) {
    	    return filter(obj, matcher(attrs));
    	  }

    	  // Return the maximum element (or element-based computation).
    	  function max(obj, iteratee, context) {
    	    var result = -Infinity, lastComputed = -Infinity,
    	        value, computed;
    	    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    	      obj = isArrayLike(obj) ? obj : values(obj);
    	      for (var i = 0, length = obj.length; i < length; i++) {
    	        value = obj[i];
    	        if (value != null && value > result) {
    	          result = value;
    	        }
    	      }
    	    } else {
    	      iteratee = cb(iteratee, context);
    	      each(obj, function(v, index, list) {
    	        computed = iteratee(v, index, list);
    	        if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
    	          result = v;
    	          lastComputed = computed;
    	        }
    	      });
    	    }
    	    return result;
    	  }

    	  // Return the minimum element (or element-based computation).
    	  function min(obj, iteratee, context) {
    	    var result = Infinity, lastComputed = Infinity,
    	        value, computed;
    	    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    	      obj = isArrayLike(obj) ? obj : values(obj);
    	      for (var i = 0, length = obj.length; i < length; i++) {
    	        value = obj[i];
    	        if (value != null && value < result) {
    	          result = value;
    	        }
    	      }
    	    } else {
    	      iteratee = cb(iteratee, context);
    	      each(obj, function(v, index, list) {
    	        computed = iteratee(v, index, list);
    	        if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
    	          result = v;
    	          lastComputed = computed;
    	        }
    	      });
    	    }
    	    return result;
    	  }

    	  // Safely create a real, live array from anything iterable.
    	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
    	  function toArray(obj) {
    	    if (!obj) return [];
    	    if (isArray(obj)) return slice.call(obj);
    	    if (isString(obj)) {
    	      // Keep surrogate pair characters together.
    	      return obj.match(reStrSymbol);
    	    }
    	    if (isArrayLike(obj)) return map(obj, identity);
    	    return values(obj);
    	  }

    	  // Sample **n** random values from a collection using the modern version of the
    	  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
    	  // If **n** is not specified, returns a single random element.
    	  // The internal `guard` argument allows it to work with `_.map`.
    	  function sample(obj, n, guard) {
    	    if (n == null || guard) {
    	      if (!isArrayLike(obj)) obj = values(obj);
    	      return obj[random(obj.length - 1)];
    	    }
    	    var sample = toArray(obj);
    	    var length = getLength(sample);
    	    n = Math.max(Math.min(n, length), 0);
    	    var last = length - 1;
    	    for (var index = 0; index < n; index++) {
    	      var rand = random(index, last);
    	      var temp = sample[index];
    	      sample[index] = sample[rand];
    	      sample[rand] = temp;
    	    }
    	    return sample.slice(0, n);
    	  }

    	  // Shuffle a collection.
    	  function shuffle(obj) {
    	    return sample(obj, Infinity);
    	  }

    	  // Sort the object's values by a criterion produced by an iteratee.
    	  function sortBy(obj, iteratee, context) {
    	    var index = 0;
    	    iteratee = cb(iteratee, context);
    	    return pluck(map(obj, function(value, key, list) {
    	      return {
    	        value: value,
    	        index: index++,
    	        criteria: iteratee(value, key, list)
    	      };
    	    }).sort(function(left, right) {
    	      var a = left.criteria;
    	      var b = right.criteria;
    	      if (a !== b) {
    	        if (a > b || a === void 0) return 1;
    	        if (a < b || b === void 0) return -1;
    	      }
    	      return left.index - right.index;
    	    }), 'value');
    	  }

    	  // An internal function used for aggregate "group by" operations.
    	  function group(behavior, partition) {
    	    return function(obj, iteratee, context) {
    	      var result = partition ? [[], []] : {};
    	      iteratee = cb(iteratee, context);
    	      each(obj, function(value, index) {
    	        var key = iteratee(value, index, obj);
    	        behavior(result, value, key);
    	      });
    	      return result;
    	    };
    	  }

    	  // Groups the object's values by a criterion. Pass either a string attribute
    	  // to group by, or a function that returns the criterion.
    	  var groupBy = group(function(result, value, key) {
    	    if (has$1(result, key)) result[key].push(value); else result[key] = [value];
    	  });

    	  // Indexes the object's values by a criterion, similar to `_.groupBy`, but for
    	  // when you know that your index values will be unique.
    	  var indexBy = group(function(result, value, key) {
    	    result[key] = value;
    	  });

    	  // Counts instances of an object that group by a certain criterion. Pass
    	  // either a string attribute to count by, or a function that returns the
    	  // criterion.
    	  var countBy = group(function(result, value, key) {
    	    if (has$1(result, key)) result[key]++; else result[key] = 1;
    	  });

    	  // Split a collection into two arrays: one whose elements all pass the given
    	  // truth test, and one whose elements all do not pass the truth test.
    	  var partition = group(function(result, value, pass) {
    	    result[pass ? 0 : 1].push(value);
    	  }, true);

    	  // Return the number of elements in a collection.
    	  function size(obj) {
    	    if (obj == null) return 0;
    	    return isArrayLike(obj) ? obj.length : keys(obj).length;
    	  }

    	  // Internal `_.pick` helper function to determine whether `key` is an enumerable
    	  // property name of `obj`.
    	  function keyInObj(value, key, obj) {
    	    return key in obj;
    	  }

    	  // Return a copy of the object only containing the allowed properties.
    	  var pick = restArguments(function(obj, keys) {
    	    var result = {}, iteratee = keys[0];
    	    if (obj == null) return result;
    	    if (isFunction$1(iteratee)) {
    	      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
    	      keys = allKeys(obj);
    	    } else {
    	      iteratee = keyInObj;
    	      keys = flatten$1(keys, false, false);
    	      obj = Object(obj);
    	    }
    	    for (var i = 0, length = keys.length; i < length; i++) {
    	      var key = keys[i];
    	      var value = obj[key];
    	      if (iteratee(value, key, obj)) result[key] = value;
    	    }
    	    return result;
    	  });

    	  // Return a copy of the object without the disallowed properties.
    	  var omit = restArguments(function(obj, keys) {
    	    var iteratee = keys[0], context;
    	    if (isFunction$1(iteratee)) {
    	      iteratee = negate(iteratee);
    	      if (keys.length > 1) context = keys[1];
    	    } else {
    	      keys = map(flatten$1(keys, false, false), String);
    	      iteratee = function(value, key) {
    	        return !contains(keys, key);
    	      };
    	    }
    	    return pick(obj, iteratee, context);
    	  });

    	  // Returns everything but the last entry of the array. Especially useful on
    	  // the arguments object. Passing **n** will return all the values in
    	  // the array, excluding the last N.
    	  function initial(array, n, guard) {
    	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    	  }

    	  // Get the first element of an array. Passing **n** will return the first N
    	  // values in the array. The **guard** check allows it to work with `_.map`.
    	  function first(array, n, guard) {
    	    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    	    if (n == null || guard) return array[0];
    	    return initial(array, array.length - n);
    	  }

    	  // Returns everything but the first entry of the `array`. Especially useful on
    	  // the `arguments` object. Passing an **n** will return the rest N values in the
    	  // `array`.
    	  function rest(array, n, guard) {
    	    return slice.call(array, n == null || guard ? 1 : n);
    	  }

    	  // Get the last element of an array. Passing **n** will return the last N
    	  // values in the array.
    	  function last(array, n, guard) {
    	    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    	    if (n == null || guard) return array[array.length - 1];
    	    return rest(array, Math.max(0, array.length - n));
    	  }

    	  // Trim out all falsy values from an array.
    	  function compact(array) {
    	    return filter(array, Boolean);
    	  }

    	  // Flatten out an array, either recursively (by default), or up to `depth`.
    	  // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
    	  function flatten(array, depth) {
    	    return flatten$1(array, depth, false);
    	  }

    	  // Take the difference between one array and a number of other arrays.
    	  // Only the elements present in just the first array will remain.
    	  var difference = restArguments(function(array, rest) {
    	    rest = flatten$1(rest, true, true);
    	    return filter(array, function(value){
    	      return !contains(rest, value);
    	    });
    	  });

    	  // Return a version of the array that does not contain the specified value(s).
    	  var without = restArguments(function(array, otherArrays) {
    	    return difference(array, otherArrays);
    	  });

    	  // Produce a duplicate-free version of the array. If the array has already
    	  // been sorted, you have the option of using a faster algorithm.
    	  // The faster algorithm will not work with an iteratee if the iteratee
    	  // is not a one-to-one function, so providing an iteratee will disable
    	  // the faster algorithm.
    	  function uniq(array, isSorted, iteratee, context) {
    	    if (!isBoolean(isSorted)) {
    	      context = iteratee;
    	      iteratee = isSorted;
    	      isSorted = false;
    	    }
    	    if (iteratee != null) iteratee = cb(iteratee, context);
    	    var result = [];
    	    var seen = [];
    	    for (var i = 0, length = getLength(array); i < length; i++) {
    	      var value = array[i],
    	          computed = iteratee ? iteratee(value, i, array) : value;
    	      if (isSorted && !iteratee) {
    	        if (!i || seen !== computed) result.push(value);
    	        seen = computed;
    	      } else if (iteratee) {
    	        if (!contains(seen, computed)) {
    	          seen.push(computed);
    	          result.push(value);
    	        }
    	      } else if (!contains(result, value)) {
    	        result.push(value);
    	      }
    	    }
    	    return result;
    	  }

    	  // Produce an array that contains the union: each distinct element from all of
    	  // the passed-in arrays.
    	  var union = restArguments(function(arrays) {
    	    return uniq(flatten$1(arrays, true, true));
    	  });

    	  // Produce an array that contains every item shared between all the
    	  // passed-in arrays.
    	  function intersection(array) {
    	    var result = [];
    	    var argsLength = arguments.length;
    	    for (var i = 0, length = getLength(array); i < length; i++) {
    	      var item = array[i];
    	      if (contains(result, item)) continue;
    	      var j;
    	      for (j = 1; j < argsLength; j++) {
    	        if (!contains(arguments[j], item)) break;
    	      }
    	      if (j === argsLength) result.push(item);
    	    }
    	    return result;
    	  }

    	  // Complement of zip. Unzip accepts an array of arrays and groups
    	  // each array's elements on shared indices.
    	  function unzip(array) {
    	    var length = (array && max(array, getLength).length) || 0;
    	    var result = Array(length);

    	    for (var index = 0; index < length; index++) {
    	      result[index] = pluck(array, index);
    	    }
    	    return result;
    	  }

    	  // Zip together multiple lists into a single array -- elements that share
    	  // an index go together.
    	  var zip = restArguments(unzip);

    	  // Converts lists into objects. Pass either a single array of `[key, value]`
    	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
    	  // the corresponding values. Passing by pairs is the reverse of `_.pairs`.
    	  function object(list, values) {
    	    var result = {};
    	    for (var i = 0, length = getLength(list); i < length; i++) {
    	      if (values) {
    	        result[list[i]] = values[i];
    	      } else {
    	        result[list[i][0]] = list[i][1];
    	      }
    	    }
    	    return result;
    	  }

    	  // Generate an integer Array containing an arithmetic progression. A port of
    	  // the native Python `range()` function. See
    	  // [the Python documentation](https://docs.python.org/library/functions.html#range).
    	  function range(start, stop, step) {
    	    if (stop == null) {
    	      stop = start || 0;
    	      start = 0;
    	    }
    	    if (!step) {
    	      step = stop < start ? -1 : 1;
    	    }

    	    var length = Math.max(Math.ceil((stop - start) / step), 0);
    	    var range = Array(length);

    	    for (var idx = 0; idx < length; idx++, start += step) {
    	      range[idx] = start;
    	    }

    	    return range;
    	  }

    	  // Chunk a single array into multiple arrays, each containing `count` or fewer
    	  // items.
    	  function chunk(array, count) {
    	    if (count == null || count < 1) return [];
    	    var result = [];
    	    var i = 0, length = array.length;
    	    while (i < length) {
    	      result.push(slice.call(array, i, i += count));
    	    }
    	    return result;
    	  }

    	  // Helper function to continue chaining intermediate results.
    	  function chainResult(instance, obj) {
    	    return instance._chain ? _$1(obj).chain() : obj;
    	  }

    	  // Add your own custom functions to the Underscore object.
    	  function mixin(obj) {
    	    each(functions(obj), function(name) {
    	      var func = _$1[name] = obj[name];
    	      _$1.prototype[name] = function() {
    	        var args = [this._wrapped];
    	        push.apply(args, arguments);
    	        return chainResult(this, func.apply(_$1, args));
    	      };
    	    });
    	    return _$1;
    	  }

    	  // Add all mutator `Array` functions to the wrapper.
    	  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    	    var method = ArrayProto[name];
    	    _$1.prototype[name] = function() {
    	      var obj = this._wrapped;
    	      if (obj != null) {
    	        method.apply(obj, arguments);
    	        if ((name === 'shift' || name === 'splice') && obj.length === 0) {
    	          delete obj[0];
    	        }
    	      }
    	      return chainResult(this, obj);
    	    };
    	  });

    	  // Add all accessor `Array` functions to the wrapper.
    	  each(['concat', 'join', 'slice'], function(name) {
    	    var method = ArrayProto[name];
    	    _$1.prototype[name] = function() {
    	      var obj = this._wrapped;
    	      if (obj != null) obj = method.apply(obj, arguments);
    	      return chainResult(this, obj);
    	    };
    	  });

    	  // Named Exports

    	  var allExports = {
    	    __proto__: null,
    	    VERSION: VERSION,
    	    restArguments: restArguments,
    	    isObject: isObject,
    	    isNull: isNull,
    	    isUndefined: isUndefined,
    	    isBoolean: isBoolean,
    	    isElement: isElement,
    	    isString: isString,
    	    isNumber: isNumber,
    	    isDate: isDate,
    	    isRegExp: isRegExp,
    	    isError: isError,
    	    isSymbol: isSymbol,
    	    isArrayBuffer: isArrayBuffer,
    	    isDataView: isDataView$1,
    	    isArray: isArray,
    	    isFunction: isFunction$1,
    	    isArguments: isArguments$1,
    	    isFinite: isFinite$1,
    	    isNaN: isNaN$1,
    	    isTypedArray: isTypedArray$1,
    	    isEmpty: isEmpty,
    	    isMatch: isMatch,
    	    isEqual: isEqual,
    	    isMap: isMap,
    	    isWeakMap: isWeakMap,
    	    isSet: isSet,
    	    isWeakSet: isWeakSet,
    	    keys: keys,
    	    allKeys: allKeys,
    	    values: values,
    	    pairs: pairs,
    	    invert: invert,
    	    functions: functions,
    	    methods: functions,
    	    extend: extend,
    	    extendOwn: extendOwn,
    	    assign: extendOwn,
    	    defaults: defaults,
    	    create: create,
    	    clone: clone,
    	    tap: tap,
    	    get: get,
    	    has: has,
    	    mapObject: mapObject,
    	    identity: identity,
    	    constant: constant,
    	    noop: noop,
    	    toPath: toPath$1,
    	    property: property,
    	    propertyOf: propertyOf,
    	    matcher: matcher,
    	    matches: matcher,
    	    times: times,
    	    random: random,
    	    now: now,
    	    escape: _escape,
    	    unescape: _unescape,
    	    templateSettings: templateSettings,
    	    template: template,
    	    result: result,
    	    uniqueId: uniqueId,
    	    chain: chain,
    	    iteratee: iteratee,
    	    partial: partial,
    	    bind: bind,
    	    bindAll: bindAll,
    	    memoize: memoize,
    	    delay: delay,
    	    defer: defer,
    	    throttle: throttle,
    	    debounce: debounce,
    	    wrap: wrap,
    	    negate: negate,
    	    compose: compose,
    	    after: after,
    	    before: before,
    	    once: once,
    	    findKey: findKey,
    	    findIndex: findIndex,
    	    findLastIndex: findLastIndex,
    	    sortedIndex: sortedIndex,
    	    indexOf: indexOf,
    	    lastIndexOf: lastIndexOf,
    	    find: find,
    	    detect: find,
    	    findWhere: findWhere,
    	    each: each,
    	    forEach: each,
    	    map: map,
    	    collect: map,
    	    reduce: reduce,
    	    foldl: reduce,
    	    inject: reduce,
    	    reduceRight: reduceRight,
    	    foldr: reduceRight,
    	    filter: filter,
    	    select: filter,
    	    reject: reject,
    	    every: every,
    	    all: every,
    	    some: some,
    	    any: some,
    	    contains: contains,
    	    includes: contains,
    	    include: contains,
    	    invoke: invoke,
    	    pluck: pluck,
    	    where: where,
    	    max: max,
    	    min: min,
    	    shuffle: shuffle,
    	    sample: sample,
    	    sortBy: sortBy,
    	    groupBy: groupBy,
    	    indexBy: indexBy,
    	    countBy: countBy,
    	    partition: partition,
    	    toArray: toArray,
    	    size: size,
    	    pick: pick,
    	    omit: omit,
    	    first: first,
    	    head: first,
    	    take: first,
    	    initial: initial,
    	    last: last,
    	    rest: rest,
    	    tail: rest,
    	    drop: rest,
    	    compact: compact,
    	    flatten: flatten,
    	    without: without,
    	    uniq: uniq,
    	    unique: uniq,
    	    union: union,
    	    intersection: intersection,
    	    difference: difference,
    	    unzip: unzip,
    	    transpose: unzip,
    	    zip: zip,
    	    object: object,
    	    range: range,
    	    chunk: chunk,
    	    mixin: mixin,
    	    'default': _$1
    	  };

    	  // Default Export

    	  // Add all of the Underscore functions to the wrapper object.
    	  var _ = mixin(allExports);
    	  // Legacy Node.js API.
    	  _._ = _;

    	  return _;

    	})));
    	
    } (underscoreUmd));

    var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    const tailLength_1 = __importDefault$2(tailLength);

    const round_1$1 = __importDefault$2(round);

    const underscore_1 = underscoreUmd.exports;

    var significantDimension = function significantDimension(values) {
      let tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
      let result = [];
      let decimals = 0;
      const uniqValues = (0, underscore_1.uniq)(values.filter(underscore_1.isFinite));
      const totalUniq = uniqValues.length;
      let check;
      let diff;
      const accepted = Math.floor(totalUniq * (1 - tolerance));

      if (uniqValues.length < 3) {
        // special case if there are only 2 unique values
        return Math.round(uniqValues.reduce(function (acc, cur) {
          if (!cur) return acc;
          const exp = Math.log(Math.abs(cur)) / Math.LN10;

          if (exp < 8 && exp > -3) {
            // use tail length for normal numbers
            return acc + Math.min(3, (0, tailLength_1.default)(uniqValues[0]));
          } else {
            return acc + (exp > 0 ? (exp - 1) * -1 : exp * -1);
          }
        }, 0) / uniqValues.length);
      }

      if ((0, underscore_1.uniq)(uniqValues.map(currentRound)).length > accepted) {
        // we seem to have enough precision, but maybe it's too much?
        check = function () {
          return (0, underscore_1.uniq)(result).length === totalUniq;
        };

        diff = -1;
      } else {
        // if we end up here it means we're loosing too much information
        // due to rounding, we need to increase precision
        check = function () {
          return (0, underscore_1.uniq)(result).length <= accepted;
        };

        diff = +1;
      }

      let maxIter = 100;

      do {
        result = uniqValues.map(currentRound);
        decimals += diff;
      } while (check() && maxIter-- > 0);

      if (maxIter < 10) {
        console.warn('maximum iteration reached', values, result, decimals);
      }

      if (diff < 0) decimals += 2;else decimals--;
      /* rounds to the current number of decimals */

      function currentRound(v) {
        return (0, round_1$1.default)(v, decimals);
      }

      return decimals;
    };

    var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    const significantDimension_1 = __importDefault$1(significantDimension);

    const round_1 = __importDefault$1(round);

    var smartRound = function smartRound(values) {
      let addPrecision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
      let dim = (0, significantDimension_1.default)(values, tolerance);
      dim += addPrecision;
      return values.map(v => (0, round_1.default)(v, dim));
    };

    var equalish = function equalish(a, b) {
      return Math.abs(a - b) < 1e-6;
    };

    function clone(o) {
      if (!o || typeof o !== 'object') return o;

      try {
        return JSON.parse(JSON.stringify(o));
      } catch (e) {
        return o;
      }
    }

    var clone_1 = clone;

    function outerHeight(element) {
      let withMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (!element) return null;
      let height = element.offsetHeight;
      if (!withMargin) return height;
      var style = getComputedStyle(element);
      height += parseInt(style.marginTop) + parseInt(style.marginBottom);
      return height;
    }
    function getNonChartHeight() {
      let h = 0;
      const chart = document.querySelector('.dw-chart');

      for (let i = 0; i < chart.children.length; i++) {
        const el = chart.children[i];
        const tagName = el.tagName.toLowerCase();

        if (tagName !== 'script' && tagName !== 'style' && el.id !== 'chart' && !hasClass(el, 'tooltip') && !hasClass(el, 'vg-tooltip') && !hasClass(el, 'hidden') && !hasClass(el, 'sr-only') && !hasClass(el, 'qtip') && !hasClass(el, 'container') && !hasClass(el, 'noscript') && !hasClass(el, 'hidden') && !hasClass(el, 'dw-after-body') && !hasClass(el, 'dw-chart-body')) {
          h += Number(outerHeight(el, true));

          if (hasClass(el, 'dw-chart-header')) {
            const filter = el.querySelector('.filter-ui');
            if (filter) h -= Number(outerHeight(filter, true));
          }
        }
      }

      function hasClass(el, className) {
        return el.classList.contains(className);
      }

      function getProp(selector, property) {
        return getComputedStyle(document.querySelector(selector))[property].replace('px', '');
      }

      const selectors = ['.dw-chart', '.dw-chart-body', 'body'];
      const properties = ['padding-top', 'padding-bottom', 'margin-top', 'margin-bottom', 'border-top-width', 'border-bottom-width'];
      selectors.forEach(function (sel) {
        properties.forEach(function (prop) {
          h += Number(getProp(sel, prop));
        });
      });
      return h;
    }

    var TEOF = 'TEOF';
    var TOP = 'TOP';
    var TNUMBER = 'TNUMBER';
    var TSTRING = 'TSTRING';
    var TPAREN = 'TPAREN';
    var TBRACKET = 'TBRACKET';
    var TCOMMA = 'TCOMMA';
    var TNAME = 'TNAME';
    var TSEMICOLON = 'TSEMICOLON';
    function Token(type, value, index) {
      this.type = type;
      this.value = value;
      this.index = index;
    }

    Token.prototype.toString = function () {
      return this.type + ': ' + this.value;
    };

    function TokenStream(parser, expression) {
      this.pos = 0;
      this.current = null;
      this.unaryOps = parser.unaryOps;
      this.binaryOps = parser.binaryOps;
      this.ternaryOps = parser.ternaryOps;
      this.consts = parser.consts;
      this.expression = expression;
      this.savedPosition = 0;
      this.savedCurrent = null;
      this.options = parser.options;
      this.parser = parser;
    }

    TokenStream.prototype.newToken = function (type, value, pos) {
      return new Token(type, value, pos != null ? pos : this.pos);
    };

    TokenStream.prototype.save = function () {
      this.savedPosition = this.pos;
      this.savedCurrent = this.current;
    };

    TokenStream.prototype.restore = function () {
      this.pos = this.savedPosition;
      this.current = this.savedCurrent;
    };

    TokenStream.prototype.next = function () {
      if (this.pos >= this.expression.length) {
        return this.newToken(TEOF, 'EOF');
      }

      if (this.isWhitespace() || this.isComment()) {
        return this.next();
      } else if (this.isRadixInteger() || this.isNumber() || this.isOperator() || this.isString() || this.isParen() || this.isBracket() || this.isComma() || this.isSemicolon() || this.isNamedOp() || this.isConst() || this.isName()) {
        return this.current;
      } else {
        this.parseError('Unknown character "' + this.expression.charAt(this.pos) + '"');
      }
    };

    TokenStream.prototype.isString = function () {
      var r = false;
      var startPos = this.pos;
      var quote = this.expression.charAt(startPos);

      if (quote === "'" || quote === '"') {
        var index = this.expression.indexOf(quote, startPos + 1);

        while (index >= 0 && this.pos < this.expression.length) {
          this.pos = index + 1;

          if (this.expression.charAt(index - 1) !== '\\') {
            var rawString = this.expression.substring(startPos + 1, index);
            this.current = this.newToken(TSTRING, this.unescape(rawString), startPos);
            r = true;
            break;
          }

          index = this.expression.indexOf(quote, index + 1);
        }
      }

      return r;
    };

    TokenStream.prototype.isParen = function () {
      var c = this.expression.charAt(this.pos);

      if (c === '(' || c === ')') {
        this.current = this.newToken(TPAREN, c);
        this.pos++;
        return true;
      }

      return false;
    };

    TokenStream.prototype.isBracket = function () {
      var c = this.expression.charAt(this.pos);

      if ((c === '[' || c === ']') && this.isOperatorEnabled('[')) {
        this.current = this.newToken(TBRACKET, c);
        this.pos++;
        return true;
      }

      return false;
    };

    TokenStream.prototype.isComma = function () {
      var c = this.expression.charAt(this.pos);

      if (c === ',') {
        this.current = this.newToken(TCOMMA, ',');
        this.pos++;
        return true;
      }

      return false;
    };

    TokenStream.prototype.isSemicolon = function () {
      var c = this.expression.charAt(this.pos);

      if (c === ';') {
        this.current = this.newToken(TSEMICOLON, ';');
        this.pos++;
        return true;
      }

      return false;
    };

    TokenStream.prototype.isConst = function () {
      var startPos = this.pos;
      var i = startPos;

      for (; i < this.expression.length; i++) {
        var c = this.expression.charAt(i);

        if (c.toUpperCase() === c.toLowerCase()) {
          if (i === this.pos || c !== '_' && c !== '.' && (c < '0' || c > '9')) {
            break;
          }
        }
      }

      if (i > startPos) {
        var str = this.expression.substring(startPos, i);

        if (str in this.consts) {
          this.current = this.newToken(TNUMBER, this.consts[str]);
          this.pos += str.length;
          return true;
        }
      }

      return false;
    };

    TokenStream.prototype.isNamedOp = function () {
      var startPos = this.pos;
      var i = startPos;

      for (; i < this.expression.length; i++) {
        var c = this.expression.charAt(i);

        if (c.toUpperCase() === c.toLowerCase()) {
          if (i === this.pos || c !== '_' && (c < '0' || c > '9')) {
            break;
          }
        }
      }

      if (i > startPos) {
        var str = this.expression.substring(startPos, i);

        if (this.isOperatorEnabled(str) && (str in this.binaryOps || str in this.unaryOps || str in this.ternaryOps)) {
          this.current = this.newToken(TOP, str);
          this.pos += str.length;
          return true;
        }
      }

      return false;
    };

    TokenStream.prototype.isName = function () {
      var startPos = this.pos;
      var i = startPos;
      var hasLetter = false;

      for (; i < this.expression.length; i++) {
        var c = this.expression.charAt(i);

        if (c.toUpperCase() === c.toLowerCase()) {
          if (i === this.pos && (c === '$' || c === '_')) {
            if (c === '_') {
              hasLetter = true;
            }

            continue;
          } else if (i === this.pos || !hasLetter || c !== '_' && (c < '0' || c > '9')) {
            break;
          }
        } else {
          hasLetter = true;
        }
      }

      if (hasLetter) {
        var str = this.expression.substring(startPos, i);
        this.current = this.newToken(TNAME, str);
        this.pos += str.length;
        return true;
      }

      return false;
    };

    TokenStream.prototype.isWhitespace = function () {
      var r = false;
      var c = this.expression.charAt(this.pos);

      while (c === ' ' || c === '\t' || c === '\n' || c === '\r') {
        r = true;
        this.pos++;

        if (this.pos >= this.expression.length) {
          break;
        }

        c = this.expression.charAt(this.pos);
      }

      return r;
    };

    var codePointPattern = /^[0-9a-f]{4}$/i;

    TokenStream.prototype.unescape = function (v) {
      var index = v.indexOf('\\');

      if (index < 0) {
        return v;
      }

      var buffer = v.substring(0, index);

      while (index >= 0) {
        var c = v.charAt(++index);

        switch (c) {
          case "'":
            buffer += "'";
            break;

          case '"':
            buffer += '"';
            break;

          case '\\':
            buffer += '\\';
            break;

          case '/':
            buffer += '/';
            break;

          case 'b':
            buffer += '\b';
            break;

          case 'f':
            buffer += '\f';
            break;

          case 'n':
            buffer += '\n';
            break;

          case 'r':
            buffer += '\r';
            break;

          case 't':
            buffer += '\t';
            break;

          case 'u':
            // interpret the following 4 characters as the hex of the unicode code point
            var codePoint = v.substring(index + 1, index + 5);

            if (!codePointPattern.test(codePoint)) {
              this.parseError('Illegal escape sequence: \\u' + codePoint);
            }

            buffer += String.fromCharCode(parseInt(codePoint, 16));
            index += 4;
            break;

          default:
            throw this.parseError('Illegal escape sequence: "\\' + c + '"');
        }

        ++index;
        var backslash = v.indexOf('\\', index);
        buffer += v.substring(index, backslash < 0 ? v.length : backslash);
        index = backslash;
      }

      return buffer;
    };

    TokenStream.prototype.isComment = function () {
      var c = this.expression.charAt(this.pos);

      if (c === '/' && this.expression.charAt(this.pos + 1) === '*') {
        this.pos = this.expression.indexOf('*/', this.pos) + 2;

        if (this.pos === 1) {
          this.pos = this.expression.length;
        }

        return true;
      }

      return false;
    };

    TokenStream.prototype.isRadixInteger = function () {
      var pos = this.pos;

      if (pos >= this.expression.length - 2 || this.expression.charAt(pos) !== '0') {
        return false;
      }

      ++pos;
      var radix;
      var validDigit;

      if (this.expression.charAt(pos) === 'x') {
        radix = 16;
        validDigit = /^[0-9a-f]$/i;
        ++pos;
      } else if (this.expression.charAt(pos) === 'b') {
        radix = 2;
        validDigit = /^[01]$/i;
        ++pos;
      } else {
        return false;
      }

      var valid = false;
      var startPos = pos;

      while (pos < this.expression.length) {
        var c = this.expression.charAt(pos);

        if (validDigit.test(c)) {
          pos++;
          valid = true;
        } else {
          break;
        }
      }

      if (valid) {
        this.current = this.newToken(TNUMBER, parseInt(this.expression.substring(startPos, pos), radix));
        this.pos = pos;
      }

      return valid;
    };

    TokenStream.prototype.isNumber = function () {
      var valid = false;
      var pos = this.pos;
      var startPos = pos;
      var resetPos = pos;
      var foundDot = false;
      var foundDigits = false;
      var c;

      while (pos < this.expression.length) {
        c = this.expression.charAt(pos);

        if (c >= '0' && c <= '9' || !foundDot && c === '.') {
          if (c === '.') {
            foundDot = true;
          } else {
            foundDigits = true;
          }

          pos++;
          valid = foundDigits;
        } else {
          break;
        }
      }

      if (valid) {
        resetPos = pos;
      }

      if (c === 'e' || c === 'E') {
        pos++;
        var acceptSign = true;
        var validExponent = false;

        while (pos < this.expression.length) {
          c = this.expression.charAt(pos);

          if (acceptSign && (c === '+' || c === '-')) {
            acceptSign = false;
          } else if (c >= '0' && c <= '9') {
            validExponent = true;
            acceptSign = false;
          } else {
            break;
          }

          pos++;
        }

        if (!validExponent) {
          pos = resetPos;
        }
      }

      if (valid) {
        this.current = this.newToken(TNUMBER, parseFloat(this.expression.substring(startPos, pos)));
        this.pos = pos;
      } else {
        this.pos = resetPos;
      }

      return valid;
    };

    TokenStream.prototype.isOperator = function () {
      var startPos = this.pos;
      var c = this.expression.charAt(this.pos);

      if (c === '+' || c === '-' || c === '*' || c === '/' || c === '%' || c === '^' || c === '?' || c === ':' || c === '.') {
        this.current = this.newToken(TOP, c);
      } else if (c === '∙' || c === '•') {
        this.current = this.newToken(TOP, '*');
      } else if (c === '>') {
        if (this.expression.charAt(this.pos + 1) === '=') {
          this.current = this.newToken(TOP, '>=');
          this.pos++;
        } else {
          this.current = this.newToken(TOP, '>');
        }
      } else if (c === '<') {
        if (this.expression.charAt(this.pos + 1) === '=') {
          this.current = this.newToken(TOP, '<=');
          this.pos++;
        } else {
          this.current = this.newToken(TOP, '<');
        }
      } else if (c === '|') {
        if (this.expression.charAt(this.pos + 1) === '|') {
          this.current = this.newToken(TOP, '||');
          this.pos++;
        } else {
          return false;
        }
      } else if (c === '=') {
        if (this.expression.charAt(this.pos + 1) === '=') {
          this.current = this.newToken(TOP, '==');
          this.pos++;
        } else {
          this.current = this.newToken(TOP, c);
        }
      } else if (c === '!') {
        if (this.expression.charAt(this.pos + 1) === '=') {
          this.current = this.newToken(TOP, '!=');
          this.pos++;
        } else {
          this.current = this.newToken(TOP, c);
        }
      } else {
        return false;
      }

      this.pos++;

      if (this.isOperatorEnabled(this.current.value)) {
        return true;
      } else {
        this.pos = startPos;
        return false;
      }
    };

    TokenStream.prototype.isOperatorEnabled = function (op) {
      return this.parser.isOperatorEnabled(op);
    };

    TokenStream.prototype.getCoordinates = function () {
      var line = 0;
      var column;
      var newline = -1;

      do {
        line++;
        column = this.pos - newline;
        newline = this.expression.indexOf('\n', newline + 1);
      } while (newline >= 0 && newline < this.pos);

      return {
        line: line,
        column: column
      };
    };

    TokenStream.prototype.parseError = function (msg) {
      var coords = this.getCoordinates();
      throw new Error('parse error [' + coords.line + ':' + coords.column + ']: ' + msg);
    };

    var INUMBER = 'INUMBER';
    var IOP1 = 'IOP1';
    var IOP2 = 'IOP2';
    var IOP3 = 'IOP3';
    var IVAR = 'IVAR';
    var IVARNAME = 'IVARNAME';
    var IFUNCALL = 'IFUNCALL';
    var IFUNDEF = 'IFUNDEF';
    var IEXPR = 'IEXPR';
    var IEXPREVAL = 'IEXPREVAL';
    var IMEMBER = 'IMEMBER';
    var IENDSTATEMENT = 'IENDSTATEMENT';
    var IARRAY = 'IARRAY';
    function Instruction(type, value) {
      this.type = type;
      this.value = value !== undefined && value !== null ? value : 0;
    }

    Instruction.prototype.toString = function () {
      switch (this.type) {
        case INUMBER:
        case IOP1:
        case IOP2:
        case IOP3:
        case IVAR:
        case IVARNAME:
        case IENDSTATEMENT:
          return this.value;

        case IFUNCALL:
          return 'CALL ' + this.value;

        case IFUNDEF:
          return 'DEF ' + this.value;

        case IARRAY:
          return 'ARRAY ' + this.value;

        case IMEMBER:
          return '.' + this.value;

        default:
          return 'Invalid Instruction';
      }
    };

    function unaryInstruction(value) {
      return new Instruction(IOP1, value);
    }
    function binaryInstruction(value) {
      return new Instruction(IOP2, value);
    }
    function ternaryInstruction(value) {
      return new Instruction(IOP3, value);
    }

    function contains(array, obj) {
      for (var i = 0; i < array.length; i++) {
        if (array[i] === obj) {
          return true;
        }
      }

      return false;
    }

    function ParserState(parser, tokenStream, options) {
      this.parser = parser;
      this.tokens = tokenStream;
      this.current = null;
      this.nextToken = null;
      this.next();
      this.savedCurrent = null;
      this.savedNextToken = null;
      this.allowMemberAccess = options.allowMemberAccess !== false;
      this.restrictMemberAccess = new Set(options.restrictMemberAccess || []);
    }

    ParserState.prototype.next = function () {
      this.current = this.nextToken;
      return this.nextToken = this.tokens.next();
    };

    ParserState.prototype.tokenMatches = function (token, value) {
      if (typeof value === 'undefined') {
        return true;
      } else if (Array.isArray(value)) {
        return contains(value, token.value);
      } else if (typeof value === 'function') {
        return value(token);
      } else {
        return token.value === value;
      }
    };

    ParserState.prototype.save = function () {
      this.savedCurrent = this.current;
      this.savedNextToken = this.nextToken;
      this.tokens.save();
    };

    ParserState.prototype.restore = function () {
      this.tokens.restore();
      this.current = this.savedCurrent;
      this.nextToken = this.savedNextToken;
    };

    ParserState.prototype.accept = function (type, value) {
      if (this.nextToken.type === type && this.tokenMatches(this.nextToken, value)) {
        this.next();
        return true;
      }

      return false;
    };

    ParserState.prototype.expect = function (type, value) {
      if (!this.accept(type, value)) {
        var coords = this.tokens.getCoordinates();
        throw new Error('parse error [' + coords.line + ':' + coords.column + ']: Expected ' + (value || type));
      }
    };

    ParserState.prototype.parseAtom = function (instr) {
      var unaryOps = this.tokens.unaryOps;

      function isPrefixOperator(token) {
        return token.value in unaryOps;
      }

      if (this.accept(TNAME) || this.accept(TOP, isPrefixOperator)) {
        instr.push(new Instruction(IVAR, this.current.value));
      } else if (this.accept(TNUMBER)) {
        instr.push(new Instruction(INUMBER, this.current.value));
      } else if (this.accept(TSTRING)) {
        instr.push(new Instruction(INUMBER, this.current.value));
      } else if (this.accept(TPAREN, '(')) {
        this.parseExpression(instr);
        this.expect(TPAREN, ')');
      } else if (this.accept(TBRACKET, '[')) {
        if (this.accept(TBRACKET, ']')) {
          instr.push(new Instruction(IARRAY, 0));
        } else {
          var argCount = this.parseArrayList(instr);
          instr.push(new Instruction(IARRAY, argCount));
        }
      } else {
        throw new Error('unexpected ' + this.nextToken);
      }
    };

    ParserState.prototype.parseExpression = function (instr) {
      var exprInstr = [];

      if (this.parseUntilEndStatement(instr, exprInstr)) {
        return;
      }

      this.parseVariableAssignmentExpression(exprInstr);

      if (this.parseUntilEndStatement(instr, exprInstr)) {
        return;
      }

      this.pushExpression(instr, exprInstr);
    };

    ParserState.prototype.pushExpression = function (instr, exprInstr) {
      for (var i = 0, len = exprInstr.length; i < len; i++) {
        instr.push(exprInstr[i]);
      }
    };

    ParserState.prototype.parseUntilEndStatement = function (instr, exprInstr) {
      if (!this.accept(TSEMICOLON)) return false;

      if (this.nextToken && this.nextToken.type !== TEOF && !(this.nextToken.type === TPAREN && this.nextToken.value === ')')) {
        exprInstr.push(new Instruction(IENDSTATEMENT));
      }

      if (this.nextToken.type !== TEOF) {
        this.parseExpression(exprInstr);
      }

      instr.push(new Instruction(IEXPR, exprInstr));
      return true;
    };

    ParserState.prototype.parseArrayList = function (instr) {
      var argCount = 0;

      while (!this.accept(TBRACKET, ']')) {
        this.parseExpression(instr);
        ++argCount;

        while (this.accept(TCOMMA)) {
          this.parseExpression(instr);
          ++argCount;
        }
      }

      return argCount;
    };

    ParserState.prototype.parseVariableAssignmentExpression = function (instr) {
      this.parseConditionalExpression(instr);

      while (this.accept(TOP, '=')) {
        var varName = instr.pop();
        var varValue = [];
        var lastInstrIndex = instr.length - 1;

        if (varName.type === IFUNCALL) {
          if (!this.tokens.isOperatorEnabled('()=')) {
            throw new Error('function definition is not permitted');
          }

          for (var i = 0, len = varName.value + 1; i < len; i++) {
            var index = lastInstrIndex - i;

            if (instr[index].type === IVAR) {
              instr[index] = new Instruction(IVARNAME, instr[index].value);
            }
          }

          this.parseVariableAssignmentExpression(varValue);
          instr.push(new Instruction(IEXPR, varValue));
          instr.push(new Instruction(IFUNDEF, varName.value));
          continue;
        }

        if (varName.type !== IVAR && varName.type !== IMEMBER) {
          throw new Error('expected variable for assignment');
        }

        this.parseVariableAssignmentExpression(varValue);
        instr.push(new Instruction(IVARNAME, varName.value));
        instr.push(new Instruction(IEXPR, varValue));
        instr.push(binaryInstruction('='));
      }
    };

    ParserState.prototype.parseConditionalExpression = function (instr) {
      this.parseOrExpression(instr);

      while (this.accept(TOP, '?')) {
        var trueBranch = [];
        var falseBranch = [];
        this.parseConditionalExpression(trueBranch);
        this.expect(TOP, ':');
        this.parseConditionalExpression(falseBranch);
        instr.push(new Instruction(IEXPR, trueBranch));
        instr.push(new Instruction(IEXPR, falseBranch));
        instr.push(ternaryInstruction('?'));
      }
    };

    ParserState.prototype.parseOrExpression = function (instr) {
      this.parseAndExpression(instr);

      while (this.accept(TOP, 'or')) {
        var falseBranch = [];
        this.parseAndExpression(falseBranch);
        instr.push(new Instruction(IEXPR, falseBranch));
        instr.push(binaryInstruction('or'));
      }
    };

    ParserState.prototype.parseAndExpression = function (instr) {
      this.parseComparison(instr);

      while (this.accept(TOP, 'and')) {
        var trueBranch = [];
        this.parseComparison(trueBranch);
        instr.push(new Instruction(IEXPR, trueBranch));
        instr.push(binaryInstruction('and'));
      }
    };

    var COMPARISON_OPERATORS = ['==', '!=', '<', '<=', '>=', '>', 'in'];

    ParserState.prototype.parseComparison = function (instr) {
      this.parseAddSub(instr);

      while (this.accept(TOP, COMPARISON_OPERATORS)) {
        var op = this.current;
        this.parseAddSub(instr);
        instr.push(binaryInstruction(op.value));
      }
    };

    var ADD_SUB_OPERATORS = ['+', '-', '||'];

    ParserState.prototype.parseAddSub = function (instr) {
      this.parseTerm(instr);

      while (this.accept(TOP, ADD_SUB_OPERATORS)) {
        var op = this.current;
        this.parseTerm(instr);
        instr.push(binaryInstruction(op.value));
      }
    };

    var TERM_OPERATORS = ['*', '/', '%'];

    ParserState.prototype.parseTerm = function (instr) {
      this.parseFactor(instr);

      while (this.accept(TOP, TERM_OPERATORS)) {
        var op = this.current;
        this.parseFactor(instr);
        instr.push(binaryInstruction(op.value));
      }
    };

    ParserState.prototype.parseFactor = function (instr) {
      var unaryOps = this.tokens.unaryOps;

      function isPrefixOperator(token) {
        return token.value in unaryOps;
      }

      this.save();

      if (this.accept(TOP, isPrefixOperator)) {
        if (this.current.value !== '-' && this.current.value !== '+') {
          if (this.nextToken.type === TPAREN && this.nextToken.value === '(') {
            this.restore();
            this.parseExponential(instr);
            return;
          } else if (this.nextToken.type === TSEMICOLON || this.nextToken.type === TCOMMA || this.nextToken.type === TEOF || this.nextToken.type === TPAREN && this.nextToken.value === ')') {
            this.restore();
            this.parseAtom(instr);
            return;
          }
        }

        var op = this.current;
        this.parseFactor(instr);
        instr.push(unaryInstruction(op.value));
      } else {
        this.parseExponential(instr);
      }
    };

    ParserState.prototype.parseExponential = function (instr) {
      this.parsePostfixExpression(instr);

      while (this.accept(TOP, '^')) {
        this.parseFactor(instr);
        instr.push(binaryInstruction('^'));
      }
    };

    ParserState.prototype.parsePostfixExpression = function (instr) {
      this.parseFunctionCall(instr);

      while (this.accept(TOP, '!')) {
        instr.push(unaryInstruction('!'));
      }
    };

    ParserState.prototype.parseFunctionCall = function (instr) {
      var unaryOps = this.tokens.unaryOps;

      function isPrefixOperator(token) {
        return token.value in unaryOps;
      }

      if (this.accept(TOP, isPrefixOperator)) {
        var op = this.current;
        this.parseAtom(instr);
        instr.push(unaryInstruction(op.value));
      } else {
        this.parseMemberExpression(instr);

        while (this.accept(TPAREN, '(')) {
          if (this.accept(TPAREN, ')')) {
            instr.push(new Instruction(IFUNCALL, 0));
          } else {
            var argCount = this.parseArgumentList(instr);
            instr.push(new Instruction(IFUNCALL, argCount));
          }
        }
      }
    };

    ParserState.prototype.parseArgumentList = function (instr) {
      var argCount = 0;

      while (!this.accept(TPAREN, ')')) {
        this.parseExpression(instr);
        ++argCount;

        while (this.accept(TCOMMA)) {
          this.parseExpression(instr);
          ++argCount;
        }
      }

      return argCount;
    };

    ParserState.prototype.parseMemberExpression = function (instr) {
      this.parseAtom(instr);

      while (this.accept(TOP, '.') || this.accept(TBRACKET, '[')) {
        var op = this.current;

        if (op.value === '.') {
          if (!this.allowMemberAccess) {
            throw new Error('unexpected ".", member access is not permitted');
          }

          if (this.restrictMemberAccess.has(this.nextToken.value)) {
            throw new Error('access to member "' + this.nextToken.value + '" is not permitted');
          }

          this.expect(TNAME);
          instr.push(new Instruction(IMEMBER, this.current.value));
        } else if (op.value === '[') {
          if (!this.tokens.isOperatorEnabled('[')) {
            throw new Error('unexpected "[]", arrays are disabled');
          }

          this.parseExpression(instr);
          this.expect(TBRACKET, ']');
          instr.push(binaryInstruction('['));
        } else {
          throw new Error('unexpected symbol: ' + op.value);
        }
      }
    };

    function add(a, b) {
      return Number(a) + Number(b);
    }
    function sub(a, b) {
      return a - b;
    }
    function mul(a, b) {
      return a * b;
    }
    function div(a, b) {
      return a / b;
    }
    function mod(a, b) {
      return a % b;
    }
    function equal(a, b) {
      return a === b;
    }
    function notEqual(a, b) {
      return a !== b;
    }
    function greaterThan(a, b) {
      return a > b;
    }
    function lessThan(a, b) {
      return a < b;
    }
    function greaterThanEqual(a, b) {
      return a >= b;
    }
    function lessThanEqual(a, b) {
      return a <= b;
    }
    function andOperator(a, b) {
      return Boolean(a && b);
    }
    function orOperator(a, b) {
      return Boolean(a || b);
    }
    function log10(a) {
      return Math.log(a) * Math.LOG10E;
    }
    function neg(a) {
      return -a;
    }
    function not(a) {
      return !a;
    }
    function trunc(a) {
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    }
    function random(a) {
      return Math.random() * (a || 1);
    }
    function stringOrArrayLength(s) {
      if (Array.isArray(s)) {
        return s.length;
      }

      return String(s).length;
    }
    function condition(cond, yep, nope) {
      return cond ? yep : nope;
    }
    /**
     * Decimal adjustment of a number.
     * From @escopecz.
     *
     * @param {Number} value The number.
     * @param {Integer} exp  The exponent (the 10 logarithm of the adjustment base).
     * @return {Number} The adjusted value.
     */

    function roundTo(value, exp) {
      // If the exp is undefined or zero...
      if (typeof exp === 'undefined' || +exp === 0) {
        return Math.round(value);
      }

      value = +value;
      exp = -+exp; // If the value is not a number or the exp is not an integer...

      if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
        return NaN;
      } // Shift


      value = value.toString().split('e');
      value = Math.round(+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp))); // Shift back

      value = value.toString().split('e');
      return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
    }
    function arrayIndex(array, index) {
      return array[index | 0];
    }
    function max(array) {
      if (arguments.length === 1 && Array.isArray(array)) {
        return Math.max.apply(Math, array);
      } else {
        return Math.max.apply(Math, arguments);
      }
    }
    function min(array) {
      if (arguments.length === 1 && Array.isArray(array)) {
        return Math.min.apply(Math, array);
      } else {
        return Math.min.apply(Math, arguments);
      }
    }
    function arrayMap(f, a) {
      if (typeof f !== 'function') {
        throw new Error('First argument to map is not a function');
      }

      if (!Array.isArray(a)) {
        throw new Error('Second argument to map is not an array');
      }

      return a.map(function (x, i) {
        return f(x, i);
      });
    }
    function arrayFold(f, init, a) {
      if (typeof f !== 'function') {
        throw new Error('First argument to fold is not a function');
      }

      if (!Array.isArray(a)) {
        throw new Error('Second argument to fold is not an array');
      }

      return a.reduce(function (acc, x, i) {
        return f(acc, x, i);
      }, init);
    }
    function arrayFilter$2(f, a) {
      if (typeof f !== 'function') {
        throw new Error('First argument to filter is not a function');
      }

      if (!Array.isArray(a)) {
        throw new Error('Second argument to filter is not an array');
      }

      return a.filter(function (x, i) {
        return f(x, i);
      });
    }
    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function log1p(x) {
      return Math.log(1 + x);
    }
    function log2(x) {
      return Math.log(x) / Math.LN2;
    }
    function sum(array) {
      if (!Array.isArray(array)) {
        throw new Error('Sum argument is not an array');
      }

      return array.reduce(function (total, value) {
        return total + Number(value);
      }, 0);
    }

    function evaluate(tokens, expr, values) {
      var nstack = [];
      var n1, n2, n3;
      var f, args, argCount;

      if (isExpressionEvaluator(tokens)) {
        return resolveExpression(tokens, values);
      }

      var numTokens = tokens.length;

      for (var i = 0; i < numTokens; i++) {
        var item = tokens[i];
        var type = item.type;

        if (type === INUMBER || type === IVARNAME) {
          nstack.push(item.value);
        } else if (type === IOP2) {
          n2 = nstack.pop();
          n1 = nstack.pop();

          if (item.value === 'and') {
            nstack.push(n1 ? !!evaluate(n2, expr, values) : false);
          } else if (item.value === 'or') {
            nstack.push(n1 ? true : !!evaluate(n2, expr, values));
          } else if (item.value === '=') {
            f = expr.binaryOps[item.value];
            nstack.push(f(n1, evaluate(n2, expr, values), values));
          } else {
            f = expr.binaryOps[item.value];
            nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values)));
          }
        } else if (type === IOP3) {
          n3 = nstack.pop();
          n2 = nstack.pop();
          n1 = nstack.pop();

          if (item.value === '?') {
            nstack.push(evaluate(n1 ? n2 : n3, expr, values));
          } else {
            f = expr.ternaryOps[item.value];
            nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));
          }
        } else if (type === IVAR) {
          if (/^__proto__|prototype|constructor$/.test(item.value)) {
            throw new Error('prototype access detected');
          }

          if (item.value in expr.functions) {
            nstack.push(expr.functions[item.value]);
          } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {
            nstack.push(expr.unaryOps[item.value]);
          } else {
            var v = values[item.value];

            if (v !== undefined) {
              nstack.push(v);
            } else {
              throw new Error('undefined variable: ' + item.value);
            }
          }
        } else if (type === IOP1) {
          n1 = nstack.pop();
          f = expr.unaryOps[item.value];
          nstack.push(f(resolveExpression(n1, values)));
        } else if (type === IFUNCALL) {
          argCount = item.value;
          args = [];

          while (argCount-- > 0) {
            args.unshift(resolveExpression(nstack.pop(), values));
          }

          f = nstack.pop();

          if (f.apply && f.call) {
            nstack.push(f.apply(undefined, args));
          } else {
            throw new Error(f + ' is not a function');
          }
        } else if (type === IFUNDEF) {
          // Create closure to keep references to arguments and expression
          nstack.push(function () {
            var n2 = nstack.pop();
            var args = [];
            var argCount = item.value;

            while (argCount-- > 0) {
              args.unshift(nstack.pop());
            }

            var n1 = nstack.pop();

            var f = function () {
              var scope = Object.assign({}, values);

              for (var i = 0, len = args.length; i < len; i++) {
                scope[args[i]] = arguments[i];
              }

              return evaluate(n2, expr, scope);
            }; // f.name = n1


            Object.defineProperty(f, 'name', {
              value: n1,
              writable: false
            });
            values[n1] = f;
            return f;
          }());
        } else if (type === IEXPR) {
          nstack.push(createExpressionEvaluator(item, expr));
        } else if (type === IEXPREVAL) {
          nstack.push(item);
        } else if (type === IMEMBER) {
          n1 = nstack.pop();
          nstack.push(n1[item.value]);
        } else if (type === IENDSTATEMENT) {
          nstack.pop();
        } else if (type === IARRAY) {
          argCount = item.value;
          args = [];

          while (argCount-- > 0) {
            args.unshift(nstack.pop());
          }

          nstack.push(args);
        } else {
          throw new Error('invalid Expression');
        }
      }

      if (nstack.length > 1) {
        throw new Error('invalid Expression (parity)');
      } // Explicitly return zero to avoid test issues caused by -0


      return nstack[0] === 0 ? 0 : resolveExpression(nstack[0], values);
    }

    function createExpressionEvaluator(token, expr, values) {
      if (isExpressionEvaluator(token)) return token;
      return {
        type: IEXPREVAL,
        value: function (scope) {
          return evaluate(token.value, expr, scope);
        }
      };
    }

    function isExpressionEvaluator(n) {
      return n && n.type === IEXPREVAL;
    }

    function resolveExpression(n, values) {
      return isExpressionEvaluator(n) ? n.value(values) : n;
    }

    function Expression(tokens, parser) {
      this.tokens = tokens;
      this.parser = parser;
      this.unaryOps = parser.unaryOps;
      this.binaryOps = parser.binaryOps;
      this.ternaryOps = parser.ternaryOps;
      this.functions = parser.functions;
    }

    Expression.prototype.evaluate = function (values) {
      values = values || {};
      return evaluate(this.tokens, this, values);
    };

    Expression.prototype.variables = function () {
      return (this.tokens || []).filter(token => token.type === 'IVAR').map(token => token.value);
    };

    function trim(s) {
      return s.trim();
    }

    const RESTRICT_MEMBER_ACCESS = new Set(['__proto__', 'prototype', 'constructor']); // parser

    function Parser(options) {
      this.options = options || {};
      this.unaryOps = {
        /**
         * Sine (trigonometric function)
         *
         * @method SIN
         * @returns {number}
         * @example
         * SIN PI
         * SIN(PI)
         */
        SIN: Math.sin,

        /**
         * Cosine (trigonometric function)
         *
         * @method COS
         * @returns {number}
         * @example
         * COS PI
         * COS(PI)
         */
        COS: Math.cos,

        /**
         * Tangent (trigonometric function)
         *
         * @method TAN
         * @returns {number}
         * @example
         * TAN PI
         * TAN(PI)
         */
        TAN: Math.tan,

        /**
         * Arcus sine (inverse tigonometric function)
         *
         * @method ASIN
         * @returns {number}
         */
        ASIN: Math.asin,

        /**
         * Arcus cosine (inverse trigonometric function)
         *
         * @method ACOS
         * @returns {number}
         */
        ACOS: Math.acos,

        /**
         * Arcus tangent (inverse trigonometric function)
         *
         * @method ATAN
         * @returns {number}
         */
        ATAN: Math.atan,

        /**
         * Computes the square root
         *
         * @method SQRT
         * @returns {number}
         * @example
         * SQRT 9 // 3
         * SQRT(9) // 3
         */
        SQRT: Math.sqrt,

        /**
         * Returns the natural logarithm (base `e`) of a number
         *
         * @method LOG
         * @returns {number}
         * @example
         * LOG x
         */
        LOG: Math.log,

        /**
         * Returns the base 2 logarithm of a number
         *
         * @method LOG2
         * @returns {number}
         * @example
         * LOG2 8 // 3
         */
        LOG2: Math.log2 || log2,

        /**
         * Alias for {@link LOG}
         * @method LN
         * @returns {number}
         * @alias LOG
         */
        LN: Math.log,

        /**
         * Returns the base 10 logarithm of a number
         *
         * @method LOG10
         * @alias LG
         * @returns {number}
         * @example
         * LOG10 10 // 1
         * LOG10(100) // 2
         * LOG10(1000) // 3
         */
        LOG10: Math.log10 || log10,

        /**
         * Alias for {@link LOG10}
         * @method LG
         * @returns {number}
         * @alias LOG10
         */
        LG: Math.log10 || log10,
        LOG1P: Math.log1p || log1p,

        /**
         * Absolute number
         *
         * @method ABS
         * @example
         * ABS -10 // 10
         * @returns {number}
         */
        ABS: Math.abs,

        /**
         * Round number to next largest integer
         *
         * @method CEIL
         * @example
         * CEIL 2.3 // 3
         * CEIL(2.7) // 3
         * @returns {number}
         * @see {@link FLOOR}, {@link ROUND}, {@link TRUNC}
         */
        CEIL: Math.ceil,

        /**
         * Round number to the next smallest integer
         *
         * @method FLOOR
         * @example
         * FLOOR 2.3 // 2
         * FLOOR 2.7 // 2
         * FLOOR -5.05 // -6
         * @see {@link CEIL}, {@link ROUND}, {@link TRUNC}
         * @returns {number}
         */
        FLOOR: Math.floor,

        /**
         * Checks if an expression is NULL
         *
         * @method ISNULL
         * @example
         * ISNULL 0 // false
         * ISNULL NULL // true*
         * @returns {boolean}
         */
        ISNULL(a) {
          return a === null;
        },

        /**
         * Returns the integer part of a number by removing any fractional digits
         * @method TRUNC
         * @returns {number}
         * @see {@link CEIL}, {@link ROUND}, {@link FLOOR}
         * @example
         * TRUNC 5.05 // 5
         * TRUNC -5.05 // -5
         */
        TRUNC: Math.trunc || trunc,
        '-': neg,
        '+': Number,

        /**
         * Returns `e^x` where `e` is the Euler's number
         * @method EXP
         * @returns {number}
         * @example
         * LOG(EXP(4)) // 4
         */
        EXP: Math.exp,

        /**
         * Negates a boolean expression
         * @method NOT
         * @returns {boolean}
         * @example
         * NOT 3 > 5 // true
         */
        NOT: not,

        /**
         * Returns the length of an array or strng
         * @method LENGTH
         * @returns {number}
         * @example
         * LENGTH 'hello' // 5
         * LENGTH [1,2,3] // 3
         */
        LENGTH: stringOrArrayLength,

        /**
         * Alias for {@link NOT}
         * @method !
         * @alias NOT
         */
        '!': not,

        /**
         * returns either a positive or negative +/- 1, indicating the sign of a number passed
         * @example
         * SIGN 35 // 1
         * SIGN -6 // -1
         * @returns {number}
         */
        SIGN: Math.sign || sign,

        /**
         * Converts a value to a string
         * @method TEXT
         * @returns {string}
         * @example
         * TEXT 12.5 // '12.5'
         * @see {@link NUMBER}
         */
        TEXT(value) {
          if (isDate(value)) {
            return value.toISOString();
          }

          return String(value);
        },

        /**
         * Converts a value to a number
         * @method NUMBER
         * @returns {number}
         * @example
         * NUMBER '12.5' // 12.5
         * @see {@link TEXT}
         */
        NUMBER: Number
      };
      this.binaryOps = {
        '+': add,
        '-': sub,
        '*': mul,
        '/': div,
        '%': mod,
        '^': Math.pow,
        '==': equal,
        '!=': notEqual,
        '>': greaterThan,
        '<': lessThan,
        '>=': greaterThanEqual,
        '<=': lessThanEqual,
        and: andOperator,
        or: orOperator,
        in: (needle, haystack) => Array.isArray(haystack) ? haystack.includes(needle) : String(haystack).includes(needle),
        '[': arrayIndex
      };
      this.ternaryOps = {
        '?': condition
      };

      const isDate = d => d instanceof Date && !isNaN(d);

      const asDate = d => {
        if (isDate(d)) return d;

        try {
          const n = new Date(d);
          if (isDate(n)) return n;
          return null;
        } catch (e) {
          return null;
        }
      };

      function filterNumbers(array) {
        return (arguments.length === 1 && Array.isArray(array) ? array : Array.from(arguments)).slice(0).filter(v => !isNaN(v) && Number.isFinite(v));
      } // fallback regular expressions for browsers without
      // support for the unicode flag //u


      let PROPER_REGEX = /\w*/g;
      let TITLE_REGEX = /\w\S*/g;
      const ESCAPE_REGEX = /[\\^$*+?.()|[\]{}]/g;

      try {
        PROPER_REGEX = new RegExp('\\p{L}*', 'ug');
        TITLE_REGEX = new RegExp('[\\p{L}\\p{N}]\\S*', 'ug');
      } catch (e) {// continue regardless of error
      }

      this.functions = {
        // ---- LOGICAL FUNCTIONS ----

        /**
         * if-else statement
         *
         * @method IF
         *
         * @param boolean condition
         * @param expr  yay   expression to use if condition is `TRUE`
         * @param expr  nay   expression to use if condition is `FALSE`
         * @example IF(temp_diff > 0, "hotter", "colder")
         * // note: you can also use the shorthand ? notaton:
         * temp_diff > 0 ? "hotter" : "colder"
         */
        IF: condition,
        // ---- MATH FUNCTIONS ----

        /**
         * Generate a random real number between 0 and 1 when used without arguments, or between 0 and the passed number
         *
         * @method RANDOM
         * @param number  max value (optional)
         * @example RANDOM()
         * RANDOM(100)
         * @returns {number}
         */
        RANDOM: random,

        // fac: factorial,

        /**
         * Returns the smallest of the given numbers
         *
         * @method MIN
         * @example
         * MIN(1,2,3) // 1
         * MIN([1,2,3]) // 1
         * @returns {number}
         */
        MIN() {
          const v = filterNumbers.apply(this, arguments);
          return min(v);
        },

        /**
         * Returns the largest of the given numbers
         *
         * @method MAX
         * @example
         * MAX(1,2,3) // 3
         * MAX([1,2,3]) // 3
         * @returns {number}
         */
        MAX() {
          return max(filterNumbers.apply(this, arguments));
        },

        /**
         * Returns the sum of the given numbers
         *
         * @method SUM
         *
         * @example
         * SUM(1,2,3) // 6
         * SUM([1,2,3]) // 6
         * @returns {number}
         */
        SUM() {
          return sum(filterNumbers.apply(this, arguments));
        },

        /**
         * Returns the average of the given numbers
         *
         * @method MEAN
         * @example
         * MEAN(1,2,4,8) // 3.75
         * MEAN([1,2,4,8]) // 3.75
         * @returns {number}
         * @see {@link MEDIAN}
         */
        MEAN() {
          const v = filterNumbers.apply(this, arguments);
          return sum(v) / v.length;
        },

        /**
         * Returns the median of the given numbers
         *
         * @method MEDIAN
         * @example
         * MEDIAN(1,2,4,8) // 3
         * MEDIAN([1,2,4,8]) // 3
         * @returns {number}
         * @see {@link MEAN}
         */
        MEDIAN() {
          const v = filterNumbers.apply(this, arguments).sort((a, b) => a - b);
          const i = Math.floor(v.length / 2);
          return v.length % 2 === 1 ? v[i] : (v[i - 1] + v[i]) * 0.5;
        },

        /**
         * Computes the power of a number
         *
         * @method POW
         * @example
         * POW(2,3) // 8
         * POW(4,2) // 16
         * @returns {number}
         */
        POW: Math.pow,

        /**
         * Computes the atan2, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2
         *
         * @method ATAN2
         * @example
         * ATAN2(2,3) // 8
         * ATAN2(4,2) // 16
         * @returns {number}
         */
        ATAN2: Math.atan2,

        /**
         * Rounds a number (to a given number of decimals)
         *
         * @method ROUND
         * @example
         * ROUND(3.1415) // 3
         * ROUND(3.1415, 2) // 3.14
         * @returns {number}
         * @see {@link FLOOR}, {@link CEIL}
         */
        ROUND: roundTo,

        // ---- STRING FUNCTIONS ----

        /**
         * Concatenate two or more strings
         *
         * @method CONCAT
         * @example
         * CONCAT("<b>", name, "</b>")
         * @returns {string}
         */
        CONCAT() {
          return Array.from(arguments).join('');
        },

        /**
         * Removes whitespaces at the beginning and end of a string
         *
         * @method TRIM
         * @returns {string}
         * @example
         * TRIM("  hello ") // 'hello'
         */
        TRIM: trim,

        /**
         * Extracts a part of a string
         *
         * @method SUBSTR
         * @param string the input string
         * @param number start
         * @param number end
         * @example
         * SUBSTR("This is fine", 5,7) // 'is'
         * @returns {string}
         */
        SUBSTR(s, start, end) {
          return s.substr(start, end);
        },

        /**
         * Replaces all occurances of a string with another string
         *
         * @method REPLACE
         * @param string the input string
         * @param string the search string
         * @param string the replacement string or function
         * @example
         * REPLACE("hello name", "name", "world") // 'hello world'
         * REPLACE("hello name", "name", TITLE) // 'hello Name'
         * REPLACE("hello name", "name", f(d) = CONCAT("<b>", d, "</b>")) // 'hello <b>name</b>'
         * @returns {string}
         * @see {@link REPLACE_REGEX}
         */
        REPLACE(str, search, replace) {
          return str.replace(new RegExp(String(search).replace(ESCAPE_REGEX, '\\$&'), 'g'), replace);
        },

        /**
         * Like REPLACE, but interprets the search string as regular expression
         *
         * @method REPLACE_REGEX
         * @param string the input string
         * @param string the search regex
         * @param string the replacement string or function
         * @example
         * REPLACE_REGEX("hello 123 world", "[0-9]", '#') // 'hello ### world'
         * REPLACE_REGEX("hello 123 world", "[0-9]+", '#') // 'hello # world'
         * @returns {string}
         * @see {@link REPLACE}
         */
        REPLACE_REGEX(str, regex, replace) {
          return str.replace(new RegExp(regex, 'g'), replace);
        },

        /**
         * Splits a string into an array
         *
         * @method SPLIT
         * @param string the input string
         * @param string the separator string
         * @example
         * SPLIT("hello world", " ") // ['hello', 'world']
         * @returns {array}
         */
        SPLIT(str, sep) {
          return String(str).split(sep);
        },

        /**
         * Lowercase a string
         *
         * @method LOWER
         * @example
         * LOWER("Hello World") // 'hello world'
         * @returns {string}
         * @see {@link UPPER}, {@link TITLE}, {@link PROPER}
         */
        LOWER(str) {
          return String(str).toLowerCase();
        },

        /**
         * Uppercase a string
         *
         * @method UPPER
         * @example
         * UPPER("Hello World") // 'HELLO WORLD'
         * @returns {string}
         * @see {@link LOWER}, {@link TITLE}, {@link PROPER}
         */
        UPPER(str) {
          return String(str).toUpperCase();
        },

        /**
         * Convert a string to title-case. Like `TITLE`, but better for names.
         *
         * @method PROPER
         * @example
         * PROPER("hello WoRLd") // 'Hello World'
         * PROPER("2-WAY STREET") // '2-Way Street'
         * PROPER("baron lloyd-webber") // 'Baron Lloyd-Webber'
         * @returns {string}
         * @see {@link TITLE}
         */
        PROPER(str) {
          return String(str).replace(PROPER_REGEX, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
        },

        /**
         * Convert a string to title-case. Like `PROPER`, but better for headlines.
         *
         * @method TITLE
         * @example
         * TITLE("hello WoRLd") // 'Hello World'
         * TITLE("2-WAY STREET") // '2-way Street'
         * TITLE("baron lloyd-webber") // 'Baron Lloyd-webber'
         * @returns {string}
         * @see {@link PROPER}
         */
        TITLE(str) {
          return String(str).replace(TITLE_REGEX, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
        },

        // ARRAY FUNCTIONS

        /**
         * Sort an array ascending or descending
         *
         * @method SORT
         * @param array the input array
         * @param boolean true for ascending, false for descending
         * @param string key to sort by (optional)
         * @example
         * SORT([5,2,4,1]) // [1,2,4,5]
         * SORT(countries, false, 'population')
         * @returns {array}
         */
        SORT(arr) {
          let asc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          let key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (RESTRICT_MEMBER_ACCESS.has(key)) throw new Error('Invalid key');

          if (!Array.isArray(arr)) {
            throw new Error('First argument to SORT is not an array');
          }

          return arr.slice(0).sort((a, b) => {
            a = typeof key === 'string' ? a[key] : typeof key === 'function' ? key(a) : a;
            b = typeof key === 'string' ? b[key] : typeof key === 'function' ? key(b) : b;
            return (a > b ? 1 : a < b ? -1 : 0) * (asc ? 1 : -1);
          });
        },

        /**
         * Slice an array (extract a part of array)
         *
         * @method SLICE
         * @param array the input array
         * @param number start index
         * @param number end index
         * @example
         * SLICE([1,2,3,4,5], 1) // [2,3,4,5]
         * SLICE([1,2,3,4,5], 1,3) // [2,3]
         * SLICE([1,2,3,4,5], -2) // [4,5]
         * @returns {array}
         */
        SLICE(arr, start, end) {
          if (!Array.isArray(arr)) {
            throw new Error('First argument to SLICE is not an array');
          }

          return arr.slice(start, end);
        },

        /**
         * Join array elements into a string
         *
         * @method JOIN
         * @param array the input array
         * @param string the glue string
         * @param string alternative glue string for the last join (optional)
         * @returns {string}
         * @example
         * JOIN(['USA', 'Canada', 'Mexico'], ', ') // 'USA, Canada, Mexico'
         * JOIN(['USA', 'Canada', 'Mexico'], ', ', ', and ') // 'USA, Canada, and Mexico'
         */
        JOIN(arr, sep) {
          let sepLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!Array.isArray(arr)) {
            throw new Error('First argument to JOIN is not an array');
          }

          return sepLast ? [arr.slice(0, arr.length - 1).join(sep), arr[arr.length - 1]].join(sepLast) : arr.join(sep);
        },

        /**
         * Evaluate function for each element in an array
         *
         * @method MAP
         * @param function the function to call
         * @param array the input array
         * @returns {array}
         * @example
         * MAP(UPPER, ['USA', 'Canada', 'Mexico']) // ['USA', 'CANADA', 'MEXICO']
         * MAP(f(s) = SUBSTR(s, 0, 2), ['USA', 'Canada', 'Mexico']) // ['US', 'Ca', 'Me']
         */
        MAP: arrayMap,

        /**
         * Fold array into a single value, good for more complex aggregations
         *
         * @method FOLD
         * @param function the function to call
         * @param * intial value
         * @param array the input array
         * @returns {}
         * @example
         * FOLD(f(a,b) = a * b, 1, [1,2,3,4,5]) // 120
         */
        FOLD: arrayFold,

        /**
         * Filter elements of an array using a function
         *
         * @method FILTER
         * @param function the function to test elements
         * @param array the input array
         * @returns {array}
         * @example
         * FILTER(f(x) = x > 2, [1, 2, 0, 3, -1, 5]) // [3, 5]
         * FILTER(f(x) = x >= 2, [1, 2, 0, 3, -1, 5]) // [2, 3, 5]
         */
        FILTER: arrayFilter$2,

        /**
         * Extract values from an array of objects
         *
         * @method PLUCK
         * @param array the input array of objects
         * @param string the key
         * @returns {array}
         * @example
         * PLUCK(countries, 'name')
         * PLUCK(countries, 'population')
         */
        PLUCK(arr, key) {
          if (RESTRICT_MEMBER_ACCESS.has(key)) throw new Error('Invalid key');
          if (!Array.isArray(arr)) throw new Error('First argument to PLUCK is not an array');
          return arr.map(item => Object.prototype.hasOwnProperty.call(item, key) ? item[key] : null);
        },

        /**
         * Returns the index of the first occurance of an element in an array (or -1 if it's not in the array)
         *
         * @method INDEXOF
         * @param array the input array of objects
         * @param * target
         * @returns {number}
         * @example
         * INDEXOF(['a', 'b', 'c'], 'b') // 1
         * INDEXOF(['a', 'b', 'c'], 'd') // -1
         * @see {@link FIND}
         */
        INDEXOF(arr, target) {
          if (!Array.isArray(arr)) arr = String(arr);
          return arr.indexOf(target);
        },

        /**
         * Returns the first element of an array for which the test function returns true
         *
         * @method FIND
         * @param array the input array of objects
         * @param function test function
         * @returns {*}
         * @example
         * FIND([1,2,3,4,5,6], f(d) = d > 3) // 4
         * @see {@link INDEXOF}
         */
        FIND(arr, test) {
          if (!Array.isArray(arr)) throw new Error('First argument to FIND is not an array');
          if (typeof test !== 'function') throw new Error('Second argument to FIND is not a function');
          const k = arr.length;

          for (let i = 0; i < k; i++) {
            if (test(arr[i])) return arr[i];
          }

          return null;
        },

        /**
         * Creates an array of numbers
         *
         * @method RANGE
         * @param number start value
         * @param number stop value (not included)
         * @param number step to increment each
         * @returns {array}
         * @example
         * RANGE(0,5) // [0,1,2,3,4]
         * RANGE(0,5,2) // [0,2,4]
         * RANGE(0,1,0.25) // [0,0.25,0.5,0.75]
         */
        RANGE(start, stop, step) {
          // borrowed from https://github.com/jashkenas/underscore/blob/master/modules/range.js
          if (stop == null) {
            stop = start || 0;
            start = 0;
          }

          if (!step) {
            step = stop < start ? -1 : 1;
          }

          var length = Math.max(Math.ceil((stop - start) / step), 0);
          var range = Array(length);

          for (var idx = 0; idx < length; idx++, start += step) {
            range[idx] = start;
          }

          return range;
        },

        /**
         * Returns TRUE if the test function is TRUE for every element in the arrat
         *
         * @method EVERY
         * @param array the input array
         * @param function the test function
         * @returns {boolean}
         * @see {@link SOME}
         * @example
         * EVERY([5,8,4,7,3], f(d) = d > 2) // true
         * EVERY([5,8,4,7,3], f(d) = d < 6) // false
         */
        EVERY(arr, test) {
          if (!Array.isArray(arr)) throw new Error('First argument to EVERY is not an array');
          if (typeof test !== 'function') throw new Error('Second argument to EVERY is not a function');
          const k = arr.length;
          let every = true;

          for (let i = 0; i < k; i++) {
            every = every && test(arr[i]);
            if (!every) return false;
          }

          return true;
        },

        /**
         * Returns `true` if the test function is `true` for at least one element in the arrat
         *
         * @method SOME
         * @param array the input array
         * @param function the test function
         * @returns {boolean}
         * @see {@link EVERY}
         * @example
         * SOME([5,8,4,7,3], f(d) = d > 2) // true
         * SOME([5,8,4,7,3], f(d) = d < 6) // true
         * SOME([5,8,4,7,3], f(d) = d < 2) // false
         */
        SOME(arr, test) {
          if (!Array.isArray(arr)) throw new Error('First argument to SOME is not an array');
          if (typeof test !== 'function') throw new Error('Second argument to SOME is not a function');
          const k = arr.length;
          let some = false;

          for (let i = 0; i < k; i++) {
            some = some || test(arr[i]);
            if (some) return true;
          }

          return false;
        },

        // ---- DATE FUNCTIONS ----

        /**
         * Constructs a new date object
         *
         * @method DATE
         * @param number year
         * @param number month
         * @param number day
         * @returns {date}
         * @example
         * DATE(2020, 1, 1) // January 1st, 2020
         */
        DATE() {
          if (arguments.length > 1) {
            // "correct" month argument (1=january, etc)
            arguments[1] = arguments[1] - 1;
          }

          return new Date(...arguments);
        },

        /**
         * Returns the year of a date
         *
         * @method YEAR
         * @param date the input date
         * @returns {number}
         * @see {@link MONTH},{@link DAY}
         * @example
         * YEAR(DATE(2020, 1, 1)) // 2020
         */
        YEAR(d) {
          d = asDate(d);
          return d ? d.getFullYear() : null;
        },

        /**
         * Returns the month of a date (1-12)
         *
         * @method MONTH
         * @param date the input date
         * @returns {number}
         * @see {@link YEAR},{@link DAY}
         * @example
         * MONTH(DATE(2020, 6, 1)) // 6
         */
        MONTH(d) {
          d = asDate(d);
          return d ? d.getMonth() + 1 : null;
        },

        /**
         * Returns the day of a date (1-31)
         *
         * @method DAY
         * @param date the input date
         * @returns {number}
         * @see {@link WEEKDAY},{@link YEAR},{@link MONTH},{@link DAY}
         * @example
         * DAY(DATE(2020, 6, 1)) // 1
         */
        DAY(d) {
          d = asDate(d);
          return d ? d.getDate() : null;
        },

        /**
         * Returns the weekday of a date (0 = Sunday, 1 = Monday, etc)
         *
         * @method WEEKDAY
         * @param date the input date
         * @returns {number}
         * @see {@link DAY}
         * @example
         * WEEKDAY(DATE(2020, 5, 10)) // 0
         */
        WEEKDAY(d) {
          d = asDate(d);
          return d ? d.getDay() : null;
        },

        /**
         * Returns the hours of a date (0-23)
         *
         * @method HOURS
         * @param date the input date
         * @returns {number}
         * @see {@link DAY},{@link MINUTES},{@link SECONDS}
         * @example
         * HOURS(time)
         */
        HOURS(d) {
          d = asDate(d);
          return d ? d.getHours() : null;
        },

        /**
         * Returns the minutes of a date (0-59)
         *
         * @method MINUTES
         * @param date the input date
         * @returns {number}
         * @see {@link HOURS},{@link SECONDS}
         * @example
         * MINUTES(time)
         */
        MINUTES(d) {
          d = asDate(d);
          return d ? d.getMinutes() : null;
        },

        /**
         * Returns the seconds of a date (0-59)
         *
         * @method SECONDS
         * @param date the input date
         * @returns {number}
         * @see {@link HOURS},{@link MINUTES}
         * @example
         * SECONDS(time)
         */
        SECONDS(d) {
          d = asDate(d);
          return d ? d.getSeconds() : null;
        },

        /**
         * Computes the  number of days between two dates
         *
         * @method DATEDIFF
         * @param date the input date 1
         * @param date the input date to substract from
         * @returns {number}
         * @see {@link TIMEDIFF}
         * @example
         * DATEDIFF(date1, date2)
         */
        DATEDIFF(d1, d2) {
          d1 = asDate(d1);
          d2 = asDate(d2);
          return d1 && d2 ? (d2.getTime() - d1.getTime()) / 864e5 : null;
        },

        /**
         * Computes the  number of seconds between two dates
         *
         * @method TIMEDIFF
         * @param date the input date 1
         * @param date the input date to substract from
         * @returns {number}
         * @see {@link DATEDIFF}
         * @example
         * TIMEDIFF(date1, date2)
         */
        TIMEDIFF(d1, d2) {
          d1 = asDate(d1);
          d2 = asDate(d2);
          return d1 && d2 ? (d2.getTime() - d1.getTime()) / 1000 : null;
        }

      };
      this.unaryOps.LOWER = this.functions.LOWER;
      this.unaryOps.UPPER = this.functions.UPPER;
      this.unaryOps.PROPER = this.functions.PROPER;
      this.unaryOps.TITLE = this.functions.TITLE;
      this.unaryOps.TRIM = this.functions.TRIM;
      this.unaryOps.YEAR = this.functions.YEAR;
      this.unaryOps.MONTH = this.functions.MONTH;
      this.unaryOps.DAY = this.functions.DAY;
      this.unaryOps.WEEKDAY = this.functions.WEEKDAY;
      this.unaryOps.HOURS = this.functions.HOURS;
      this.unaryOps.MINUTES = this.functions.MINUTES;
      this.unaryOps.SECONDS = this.functions.SECONDS;
      this.consts = {
        E: Math.E,
        PI: Math.PI,
        TRUE: true,
        FALSE: false,
        NA: Number.NaN,
        NULL: Number.NaN
      };
    }

    Parser.prototype.parse = function (expr) {
      var instr = [];
      var parserState = new ParserState(this, new TokenStream(this, expr), {
        allowMemberAccess: true,
        restrictMemberAccess: RESTRICT_MEMBER_ACCESS
      });
      parserState.parseExpression(instr);
      parserState.expect(TEOF, 'EOF');
      return new Expression(instr, this);
    };

    Parser.prototype.evaluate = function (expr, variables) {
      return this.parse(expr).evaluate(variables);
    };

    var sharedParser = new Parser();

    Parser.parse = function (expr) {
      return sharedParser.parse(expr);
    };

    Parser.evaluate = function (expr, variables) {
      return sharedParser.parse(expr).evaluate(variables);
    };

    Parser.keywords = ['ABS', 'ACOS', 'ACOSH', 'and', 'ASIN', 'ASINH', 'ATAN', 'ATAN2', 'ATANH', 'CBRT', 'CEIL', 'CONCAT', 'COS', 'COSH', 'DATEDIFF', 'DAY', 'E', 'EVERY', 'EXP', 'EXPM1', 'FIND', 'FLOOR', 'HOURS', 'IF', 'in', 'INDEXOF', 'ISNULL', 'JOIN', 'LENGTH', 'LN', 'LOG', 'LOG10', 'LOG1P', 'LOG2', 'LOWER', 'MAP', 'MAX', 'MEAN', 'MEDIAN', 'MIN', 'MINUTES', 'MONTH', 'NOT', 'NOT', 'or', 'PI', 'PLUCK', 'POW', 'PROPER', 'RANDOM', 'RANGE', 'REPLACE', 'REPLACE_REGEX', 'ROUND', 'SECONDS', 'SIGN', 'SIN', 'SINH', 'SLICE', 'SOME', 'SORT', 'SPLIT', 'SQRT', 'SUBSTR', 'SUM', 'TAN', 'TANH', 'TIMEDIFF', 'TITLE', 'TRIM', 'TRUNC', 'UPPER', 'WEEKDAY', 'YEAR'];
    var optionNameMap = {
      '+': 'add',
      '-': 'subtract',
      '*': 'multiply',
      '/': 'divide',
      '%': 'remainder',
      '^': 'power',
      '!': 'factorial',
      '<': 'comparison',
      '>': 'comparison',
      '<=': 'comparison',
      '>=': 'comparison',
      '==': 'comparison',
      '!=': 'comparison',
      '||': 'concatenate',
      AND: 'logical',
      OR: 'logical',
      NOT: 'logical',
      IN: 'logical',
      '?': 'conditional',
      ':': 'conditional',
      '=': 'assignment',
      '[': 'array',
      '()=': 'fndef'
    };

    function getOptionName(op) {
      return Object.prototype.hasOwnProperty.call(optionNameMap, op) ? optionNameMap[op] : op;
    }

    Parser.prototype.isOperatorEnabled = function (op) {
      var optionName = getOptionName(op);
      var operators = this.options.operators || {};
      return !(optionName in operators) || !!operators[optionName];
    };

    const TPL_REG = /\{\{(.+?)\}\}/g;
    /*
     * returns a function that evaluates template strings
     * using `expr-eval`.
     */

    function templateParser(template) {
      const expressions = {};
      const parser = new Parser();
      template.replace(TPL_REG, (s, formula) => {
        formula = formula.trim();

        if (formula && !expressions[formula]) {
          expressions[formula] = parser.parse(formula);
        }
      });
      return context => template.replace(TPL_REG, (s, formula) => {
        const result = formula.trim() ? expressions[formula.trim()].evaluate(context) : '';
        return result === null ? '' : result;
      });
    }

    const ALLOWED_TAGS = ['a', 'abbr', 'address', 'b', 'big', 'blockquote', 'br', 'caption', 'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'details', 'dfn', 'div', 'dl', 'dt', 'em', 'figure', 'font', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'hgroup', 'i', 'img', 'ins', 'kbd', 'li', 'mark', 'meter', 'ol', 'p', 'pre', 'q', 's', 'small', 'span', 'strike', 'strong', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'th', 'thead', 'tfoot', 'tr', 'tt', 'u', 'ul', 'wbr'];
    /*
     * returns a function that evaluates template strings
     * using `expr-eval`.
     */

    function htmlTemplate(template) {
      const evaluateTemplate = templateParser(template);
      return context => purifyHtml(evaluateTemplate(context), ALLOWED_TAGS);
    }

    /*
     * returns the min/max range of a set of columns
     */

    function minMax(columns) {
      const minmax = [Number.MAX_VALUE, -Number.MAX_VALUE];
      columns.forEach(column => {
        minmax[0] = Math.min(minmax[0], column.range()[0]);
        minmax[1] = Math.max(minmax[1], column.range()[1]);
      });
      return minmax;
    }
    /*
     * returns a new column with all column names as values
     */

    function columnNameColumn(columns) {
      const names = columns.map(col => col.title());
      return Column('', names);
    }
    function name(obj) {
      return isFunction$4(obj.name) ? obj.name() : isString(obj.name) ? obj.name : obj;
    }
    function getMaxChartHeight() {
      if (window.innerHeight === 0) return 0;
      var maxH = window.innerHeight - getNonChartHeight();
      return Math.max(maxH, 0);
    }
    function nearest(array, value) {
      let minDiff = Number.MAX_VALUE;
      let minDiffVal;
      array.forEach(v => {
        var d = Math.abs(v - value);

        if (d < minDiff) {
          minDiff = d;
          minDiffVal = v;
        }
      });
      return minDiffVal;
    }
    function metricSuffix(locale) {
      switch (locale.substr(0, 2).toLowerCase()) {
        case 'de':
          return {
            3: ' Tsd.',
            6: ' Mio.',
            9: ' Mrd.',
            12: ' Bio.'
          };

        case 'fr':
          return {
            3: ' mil',
            6: ' Mio',
            9: ' Mrd'
          };

        case 'es':
          return {
            3: ' Mil',
            6: ' millón'
          };

        default:
          return {
            3: 'k',
            6: 'M',
            9: ' bil'
          };
      }
    }
    function magnitudeRange(minmax) {
      return Math.round(Math.log(minmax[1]) / Math.LN10) - Math.round(Math.log(minmax[0]) / Math.LN10);
    }
    function logTicks(min, max) {
      const e0 = Math.round(Math.log(min) / Math.LN10);
      const e1 = Math.round(Math.log(max) / Math.LN10);
      return range(e0, e1).map(exp => Math.pow(10, exp));
    }
    function height(element) {
      const h = parseFloat(getComputedStyle(element, null).height.replace('px', ''));
      return isNaN(h) ? 0 : h;
    }
    function width(element) {
      const w = parseFloat(getComputedStyle(element, null).width.replace('px', ''));
      return isNaN(w) ? 0 : w;
    }
    function addClass(element, className) {
      if (element) element.classList.add(className);
    }
    function removeClass(element, className) {
      if (element) element.classList.remove(className);
    }
    function remove(elementOrSelector) {
      const element = typeof elementOrSelector === 'string' ? document.querySelector(elementOrSelector) : elementOrSelector;
      if (element) element.parentElement.removeChild(element);
    }
    function domReady(callback) {
      if (/complete|interactive|loaded/.test(document.readyState)) {
        // dom is already loaded
        callback();
      } else {
        // wait for dom to load
        window.addEventListener('DOMContentLoaded', () => {
          callback();
        });
      }
    }

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        purifyHtml: purifyHtml,
        significantDimension: significantDimension,
        tailLength: tailLength,
        round: round,
        smartRound: smartRound,
        equalish: equalish,
        clone: clone_1,
        delimited: delimited$1,
        getNonChartHeight: getNonChartHeight,
        outerHeight: outerHeight,
        htmlTemplate: htmlTemplate,
        templateParser: templateParser,
        minMax: minMax,
        columnNameColumn: columnNameColumn,
        name: name,
        getMaxChartHeight: getMaxChartHeight,
        nearest: nearest,
        metricSuffix: metricSuffix,
        magnitudeRange: magnitudeRange,
        logTicks: logTicks,
        height: height,
        width: width,
        addClass: addClass,
        removeClass: removeClass,
        remove: remove,
        domReady: domReady
    });

    /** Detect free variable `global` from Node.js. */

    var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal$1;

    var freeGlobal = _freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$8 = freeGlobal || freeSelf || Function('return this')();

    var _root = root$8;

    var root$7 = _root;

    /** Built-in value references. */
    var Symbol$4 = root$7.Symbol;

    var _Symbol = Symbol$4;

    var Symbol$3 = _Symbol;

    /** Used for built-in method references. */
    var objectProto$c = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$c.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1(value) {
      var isOwn = hasOwnProperty$9.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag$1;

    /** Used for built-in method references. */

    var objectProto$b = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$b.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString$1;

    var Symbol$2 = _Symbol,
        getRawTag = _getRawTag,
        objectToString = _objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$5(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    var _baseGetTag = baseGetTag$5;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */

    function overArg$2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg$2;

    var overArg$1 = _overArg;

    /** Built-in value references. */
    var getPrototype$1 = overArg$1(Object.getPrototypeOf, Object);

    var _getPrototype = getPrototype$1;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */

    function isObjectLike$5(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike$5;

    var baseGetTag$4 = _baseGetTag,
        getPrototype = _getPrototype,
        isObjectLike$4 = isObjectLike_1;

    /** `Object#toString` result references. */
    var objectTag$3 = '[object Object]';

    /** Used for built-in method references. */
    var funcProto$2 = Function.prototype,
        objectProto$a = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$2 = funcProto$2.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString$2.call(Object);

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike$4(value) || baseGetTag$4(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$8.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString$2.call(Ctor) == objectCtorString;
    }

    var isPlainObject_1 = isPlainObject;

    function get(object) {
      let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      let _default = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!key) return object;
      const keys = Array.isArray(key) ? key : key.split('.'); // It is impractical to try to replicate signature types in implementation
      // eslint-disable-next-line @typescript-eslint/no-explicit-any

      let pt = object;

      for (let i = 0; i < keys.length; i++) {
        if (pt === null || pt === undefined) break; // break out of the loop
        // move one more level in

        pt = pt[keys[i]];
      }

      return pt === undefined || pt === null ? _default : pt;
    }

    var get_1 = get;

    const isArray$4 = value => Array.isArray(value);

    var set = function set(object, key, value) {
      const keys = isArray$4(key) ? [...key] : key.split('.');

      if (!keys.length) {
        throw new Error('Key should not be empty');
      } // `pop` will never return undefined, because `key` does not contain `undefined` values,
      // and we've just checked that `key` has elements.
      // However, TS does not narrow `key` type from "array of non-empty values" to
      // to "array of non-empty values with at least one value",
      // so `pop` always has `undefined` in its return type definition.
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion


      const lastKey = keys.pop(); // It is impractical to try to replicate signature types in implementation
      // eslint-disable-next-line @typescript-eslint/no-explicit-any

      let pt = object; // resolve property until the parent dict

      keys.forEach(key => {
        if (pt[key] === undefined || pt[key] === null) {
          pt[key] = {};
        }

        pt = pt[key];
      }); // check if new value is set

      if (JSON.stringify(pt[lastKey]) !== JSON.stringify(value)) {
        pt[lastKey] = value;
        return true;
      }

      return false;
    };

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */

    function listCacheClear$1() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear$1;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */

    function eq$2(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq$2;

    var eq$1 = eq_1;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf$4(array, key) {
      var length = array.length;
      while (length--) {
        if (eq$1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf$4;

    var assocIndexOf$3 = _assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete$1(key) {
      var data = this.__data__,
          index = assocIndexOf$3(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete$1;

    var assocIndexOf$2 = _assocIndexOf;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet$1(key) {
      var data = this.__data__,
          index = assocIndexOf$2(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet$1;

    var assocIndexOf$1 = _assocIndexOf;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas$1(key) {
      return assocIndexOf$1(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas$1;

    var assocIndexOf = _assocIndexOf;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet$1(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet$1;

    var listCacheClear = _listCacheClear,
        listCacheDelete = _listCacheDelete,
        listCacheGet = _listCacheGet,
        listCacheHas = _listCacheHas,
        listCacheSet = _listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache$4(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache$4.prototype.clear = listCacheClear;
    ListCache$4.prototype['delete'] = listCacheDelete;
    ListCache$4.prototype.get = listCacheGet;
    ListCache$4.prototype.has = listCacheHas;
    ListCache$4.prototype.set = listCacheSet;

    var _ListCache = ListCache$4;

    var ListCache$3 = _ListCache;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear$1() {
      this.__data__ = new ListCache$3;
      this.size = 0;
    }

    var _stackClear = stackClear$1;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */

    function stackDelete$1(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete$1;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */

    function stackGet$1(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet$1;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */

    function stackHas$1(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas$1;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */

    function isObject$2(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject$2;

    var baseGetTag$3 = _baseGetTag,
        isObject$1 = isObject_1;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$1 = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$2(value) {
      if (!isObject$1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag$3(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction$2;

    var root$6 = _root;

    /** Used to detect overreaching core-js shims. */
    var coreJsData$1 = root$6['__core-js_shared__'];

    var _coreJsData = coreJsData$1;

    var coreJsData = _coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked$1(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked$1;

    /** Used for built-in method references. */

    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource$2(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource$2;

    var isFunction$1 = isFunction_1,
        isMasked = _isMasked,
        isObject = isObject_1,
        toSource$1 = _toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$9 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative$1(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource$1(value));
    }

    var _baseIsNative = baseIsNative$1;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */

    function getValue$1(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue$1;

    var baseIsNative = _baseIsNative,
        getValue = _getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative$6(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative$6;

    var getNative$5 = _getNative,
        root$5 = _root;

    /* Built-in method references that are verified to be native. */
    var Map$4 = getNative$5(root$5, 'Map');

    var _Map = Map$4;

    var getNative$4 = _getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate$4 = getNative$4(Object, 'create');

    var _nativeCreate = nativeCreate$4;

    var nativeCreate$3 = _nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear$1() {
      this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear$1;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */

    function hashDelete$1(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete$1;

    var nativeCreate$2 = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet$1(key) {
      var data = this.__data__;
      if (nativeCreate$2) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet$1;

    var nativeCreate$1 = _nativeCreate;

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas$1(key) {
      var data = this.__data__;
      return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
    }

    var _hashHas = hashHas$1;

    var nativeCreate = _nativeCreate;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet$1(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet$1;

    var hashClear = _hashClear,
        hashDelete = _hashDelete,
        hashGet = _hashGet,
        hashHas = _hashHas,
        hashSet = _hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash$1(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash$1.prototype.clear = hashClear;
    Hash$1.prototype['delete'] = hashDelete;
    Hash$1.prototype.get = hashGet;
    Hash$1.prototype.has = hashHas;
    Hash$1.prototype.set = hashSet;

    var _Hash = Hash$1;

    var Hash = _Hash,
        ListCache$2 = _ListCache,
        Map$3 = _Map;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear$1() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map$3 || ListCache$2),
        'string': new Hash
      };
    }

    var _mapCacheClear = mapCacheClear$1;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */

    function isKeyable$1(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable$1;

    var isKeyable = _isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData$4(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData$4;

    var getMapData$3 = _getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete$1(key) {
      var result = getMapData$3(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete$1;

    var getMapData$2 = _getMapData;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet$1(key) {
      return getMapData$2(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet$1;

    var getMapData$1 = _getMapData;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas$1(key) {
      return getMapData$1(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas$1;

    var getMapData = _getMapData;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet$1(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet$1;

    var mapCacheClear = _mapCacheClear,
        mapCacheDelete = _mapCacheDelete,
        mapCacheGet = _mapCacheGet,
        mapCacheHas = _mapCacheHas,
        mapCacheSet = _mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache$2(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache$2.prototype.clear = mapCacheClear;
    MapCache$2.prototype['delete'] = mapCacheDelete;
    MapCache$2.prototype.get = mapCacheGet;
    MapCache$2.prototype.has = mapCacheHas;
    MapCache$2.prototype.set = mapCacheSet;

    var _MapCache = MapCache$2;

    var ListCache$1 = _ListCache,
        Map$2 = _Map,
        MapCache$1 = _MapCache;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet$1(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache$1) {
        var pairs = data.__data__;
        if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache$1(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet$1;

    var ListCache = _ListCache,
        stackClear = _stackClear,
        stackDelete = _stackDelete,
        stackGet = _stackGet,
        stackHas = _stackHas,
        stackSet = _stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack$1(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack$1.prototype.clear = stackClear;
    Stack$1.prototype['delete'] = stackDelete;
    Stack$1.prototype.get = stackGet;
    Stack$1.prototype.has = stackHas;
    Stack$1.prototype.set = stackSet;

    var _Stack = Stack$1;

    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd$1(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    var _setCacheAdd = setCacheAdd$1;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */

    function setCacheHas$1(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas$1;

    var MapCache = _MapCache,
        setCacheAdd = _setCacheAdd,
        setCacheHas = _setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache$1(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
    SetCache$1.prototype.has = setCacheHas;

    var _SetCache = SetCache$1;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */

    function arraySome$1(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome$1;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */

    function cacheHas$1(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas$1;

    var SetCache = _SetCache,
        arraySome = _arraySome,
        cacheHas = _cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays$2;

    var root$4 = _root;

    /** Built-in value references. */
    var Uint8Array$2 = root$4.Uint8Array;

    var _Uint8Array = Uint8Array$2;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */

    function mapToArray$1(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray$1;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */

    function setToArray$1(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray$1;

    var Symbol$1 = _Symbol,
        Uint8Array$1 = _Uint8Array,
        eq = eq_1,
        equalArrays$1 = _equalArrays,
        mapToArray = _mapToArray,
        setToArray = _setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$2:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag$1:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
            return false;
          }
          return true;

        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag$1:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag$1:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$2:
          var convert = mapToArray;

        case setTag$2:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag$1;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */

    function arrayPush$1(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush$1;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray$3 = Array.isArray;

    var isArray_1 = isArray$3;

    var arrayPush = _arrayPush,
        isArray$2 = isArray_1;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys$1;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */

    function arrayFilter$1(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter$1;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */

    function stubArray$1() {
      return [];
    }

    var stubArray_1 = stubArray$1;

    var arrayFilter = _arrayFilter,
        stubArray = stubArray_1;

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable$1.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols$1;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */

    function baseTimes$1(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes$1;

    var baseGetTag$2 = _baseGetTag,
        isObjectLike$3 = isObjectLike_1;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments$1(value) {
      return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
    }

    var _baseIsArguments = baseIsArguments$1;

    var baseIsArguments = _baseIsArguments,
        isObjectLike$2 = isObjectLike_1;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments$1 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike$2(value) && hasOwnProperty$4.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    var isArguments_1 = isArguments$1;

    var isBuffer$2 = {exports: {}};

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */

    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    (function (module, exports) {
    	var root = _root,
    	    stubFalse = stubFalse_1;

    	/** Detect free variable `exports`. */
    	var freeExports = exports && !exports.nodeType && exports;

    	/** Detect free variable `module`. */
    	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    	/** Detect the popular CommonJS extension `module.exports`. */
    	var moduleExports = freeModule && freeModule.exports === freeExports;

    	/** Built-in value references. */
    	var Buffer = moduleExports ? root.Buffer : undefined;

    	/* Built-in method references for those with the same name as other `lodash` methods. */
    	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    	/**
    	 * Checks if `value` is a buffer.
    	 *
    	 * @static
    	 * @memberOf _
    	 * @since 4.3.0
    	 * @category Lang
    	 * @param {*} value The value to check.
    	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
    	 * @example
    	 *
    	 * _.isBuffer(new Buffer(2));
    	 * // => true
    	 *
    	 * _.isBuffer(new Uint8Array(2));
    	 * // => false
    	 */
    	var isBuffer = nativeIsBuffer || stubFalse;

    	module.exports = isBuffer;
    } (isBuffer$2, isBuffer$2.exports));

    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex$1(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex$1;

    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength$2(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    var isLength_1 = isLength$2;

    var baseGetTag$1 = _baseGetTag,
        isLength$1 = isLength_1,
        isObjectLike$1 = isObjectLike_1;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        mapTag$1 = '[object Map]',
        numberTag = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag = '[object String]',
        weakMapTag$1 = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag$1] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag$1] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag$1] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray$1(value) {
      return isObjectLike$1(value) &&
        isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray$1;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */

    function baseUnary$1(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary$1;

    var _nodeUtil = {exports: {}};

    (function (module, exports) {
    	var freeGlobal = _freeGlobal;

    	/** Detect free variable `exports`. */
    	var freeExports = exports && !exports.nodeType && exports;

    	/** Detect free variable `module`. */
    	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    	/** Detect the popular CommonJS extension `module.exports`. */
    	var moduleExports = freeModule && freeModule.exports === freeExports;

    	/** Detect free variable `process` from Node.js. */
    	var freeProcess = moduleExports && freeGlobal.process;

    	/** Used to access faster Node.js helpers. */
    	var nodeUtil = (function() {
    	  try {
    	    // Use `util.types` for Node.js 10+.
    	    var types = freeModule && freeModule.require && freeModule.require('util').types;

    	    if (types) {
    	      return types;
    	    }

    	    // Legacy `process.binding('util')` for Node.js < 10.
    	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
    	  } catch (e) {}
    	}());

    	module.exports = nodeUtil;
    } (_nodeUtil, _nodeUtil.exports));

    var baseIsTypedArray = _baseIsTypedArray,
        baseUnary = _baseUnary,
        nodeUtil = _nodeUtil.exports;

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    var isTypedArray_1 = isTypedArray$2;

    var baseTimes = _baseTimes,
        isArguments = isArguments_1,
        isArray$1 = isArray_1,
        isBuffer$1 = isBuffer$2.exports,
        isIndex = _isIndex,
        isTypedArray$1 = isTypedArray_1;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys$1(value, inherited) {
      var isArr = isArray$1(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer$1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$3.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys$1;

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype$1(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$3;

      return value === proto;
    }

    var _isPrototype = isPrototype$1;

    var overArg = _overArg;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys$1 = overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys$1;

    var isPrototype = _isPrototype,
        nativeKeys = _nativeKeys;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys$1(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys$1;

    var isFunction = isFunction_1,
        isLength = isLength_1;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike$1(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    var isArrayLike_1 = isArrayLike$1;

    var arrayLikeKeys = _arrayLikeKeys,
        baseKeys = _baseKeys,
        isArrayLike = isArrayLike_1;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys$1(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    var keys_1 = keys$1;

    var baseGetAllKeys = _baseGetAllKeys,
        getSymbols = _getSymbols,
        keys = keys_1;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys$1(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    var _getAllKeys = getAllKeys$1;

    var getAllKeys = _getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects$1;

    var getNative$3 = _getNative,
        root$3 = _root;

    /* Built-in method references that are verified to be native. */
    var DataView$2 = getNative$3(root$3, 'DataView');

    var _DataView = DataView$2;

    var getNative$2 = _getNative,
        root$2 = _root;

    /* Built-in method references that are verified to be native. */
    var Promise$2 = getNative$2(root$2, 'Promise');

    var _Promise = Promise$2;

    var getNative$1 = _getNative,
        root$1 = _root;

    /* Built-in method references that are verified to be native. */
    var Set$2 = getNative$1(root$1, 'Set');

    var _Set = Set$2;

    var getNative = _getNative,
        root = _root;

    /* Built-in method references that are verified to be native. */
    var WeakMap$1 = getNative(root, 'WeakMap');

    var _WeakMap = WeakMap$1;

    var DataView$1 = _DataView,
        Map$1 = _Map,
        Promise$1 = _Promise,
        Set$1 = _Set,
        WeakMap = _WeakMap,
        baseGetTag = _baseGetTag,
        toSource = _toSource;

    /** `Object#toString` result references. */
    var mapTag = '[object Map]',
        objectTag$1 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag = '[object Set]',
        weakMapTag = '[object WeakMap]';

    var dataViewTag = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView$1),
        mapCtorString = toSource(Map$1),
        promiseCtorString = toSource(Promise$1),
        setCtorString = toSource(Set$1),
        weakMapCtorString = toSource(WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag$1 = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag) ||
        (Map$1 && getTag$1(new Map$1) != mapTag) ||
        (Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag) ||
        (Set$1 && getTag$1(new Set$1) != setTag) ||
        (WeakMap && getTag$1(new WeakMap) != weakMapTag)) {
      getTag$1 = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag$1 ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    var _getTag = getTag$1;

    var Stack = _Stack,
        equalArrays = _equalArrays,
        equalByTag = _equalByTag,
        equalObjects = _equalObjects,
        getTag = _getTag,
        isArray = isArray_1,
        isBuffer = isBuffer$2.exports,
        isTypedArray = isTypedArray_1;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep$1;

    var baseIsEqualDeep = _baseIsEqualDeep,
        isObjectLike = isObjectLike_1;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual$1(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
    }

    var _baseIsEqual = baseIsEqual$1;

    var baseIsEqual = _baseIsEqual;

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    var isEqual_1 = isEqual;

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    const isEqual_js_1 = __importDefault(isEqual_1);

    const isPlainObject_js_1 = __importDefault(isPlainObject_1);
    /**
     * @param {object} source - the source object
     * @param {object} target - the target object
     * @param {Set|null} allowedKeys - Set
     *
     * @returns {object} - the merge patch
     */
    // It is impractical to try to replicate signature types in implementation
    // eslint-disable-next-line @typescript-eslint/no-explicit-any


    function diffKeys(source, target) {
      let allowedKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      const patch = {};
      Object.keys(target).forEach(targetKey => {
        if (!(0, isEqual_js_1.default)(target[targetKey], source[targetKey])) {
          if (allowedKeys && !allowedKeys.has(targetKey)) return;

          if ((0, isPlainObject_js_1.default)(target[targetKey]) && (0, isPlainObject_js_1.default)(source[targetKey])) {
            // iterate one level down
            const childPatch = diffKeys(source[targetKey], target[targetKey]);

            if (Object.keys(childPatch).length) {
              patch[targetKey] = childPatch;
            }
          } else {
            patch[targetKey] = target[targetKey];
          }
        }
      }); // also look for removed keys and set them null

      Object.keys(source).forEach(sourceKey => {
        if (allowedKeys && !allowedKeys.has(sourceKey)) return;

        if (target[sourceKey] === undefined) {
          patch[sourceKey] = null;
        }
      });
      return patch;
    }

    var objectDiff = function objectDiff(source, target) {
      let allowedKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return diffKeys(source, target, allowedKeys ? new Set(allowedKeys) : null);
    };

    var postEvent = function postEvent(chartId, isIframe) {
      const host = isIframe ? window.parent : window;
      return function (event, data) {
        if (host && host.postMessage) {
          const evt = {
            source: 'datawrapper',
            chartId,
            type: event,
            data
          };
          host.postMessage(evt, '*');
        }
      };
    };

    /*
     * simple event callbacks, mimicing the $.Callbacks API
     */
    function events () {
      const list = [];
      return {
        fire() {
          for (var i = list.length - 1; i >= 0; i--) {
            list[i].apply(this, arguments);
          }
        },

        add(callback) {
          list.push(callback);
        }

      };
    }

    function reorderColumns (chart, dataset) {
      var order = chart.getMetadata('data.column-order', []);

      if (order.length && order.length === dataset.numColumns()) {
        dataset.columnOrder(order);
      }

      return dataset;
    }

    function applyChanges(chart, dataset) {
      const changes = chart.getMetadata('data.changes', []);
      const transpose = chart.getMetadata('data.transpose', false);
      const numRows = dataset.numRows();
      changes.forEach(change => {
        const row = !transpose ? change.row : change.column;
        const column = !transpose ? change.column : change.row;

        if (dataset.hasColumn(column)) {
          change.ignored = false;

          if (row === 0) {
            if (change.previous && change.previous !== 'undefined') {
              const oldTitle = dataset.column(column).title();

              if (oldTitle !== change.previous) {
                // change.ignored = true; // TODO Something is buggy about this, let's revisit later.
                return;
              }
            }

            dataset.column(column).title(change.value);
          } else if (row <= numRows) {
            if (change.previous && change.previous !== 'undefined') {
              const curValue = dataset.column(column).raw(row - 1);

              if (curValue !== change.previous) {
                // change.ignored = true; // TODO Something is buggy about this, let's revisit later.
                return;
              }
            }

            dataset.column(column).raw(row - 1, change.value);
          }
        }
      }); // overwrite column types

      var columnFormats = chart.getMetadata('data.column-format', {});
      each(columnFormats, (columnFormat, key) => {
        if (columnFormat.type && dataset.hasColumn(key) && columnFormat.type !== 'auto') {
          dataset.column(key).type(columnFormat.type);
        }

        if (columnFormat['input-format'] && dataset.hasColumn(key)) {
          dataset.column(key).type(true).format(columnFormat['input-format']);
        }
      });
      return dataset;
    }

    var columnNameToVariable = function columnNameToVariable(name) {
      return name.toString().toLowerCase().replace(/\s+/g, '_') // Replace spaces with _
      .replace(/[^\w-]+/g, '') // Remove all non-word chars
      .replace(/-/g, '_') // Replace multiple - with single -
      .replace(/__+/g, '_') // Replace multiple - with single -
      .replace(/^_+/, '') // Trim - from start of text
      .replace(/_+$/, '') // Trim - from end of text
      .replace(/^(\d)/, '_$1') // If first char is a number, prefix with _
      .replace(/^(and|or|in|true|false)$/, '$1_'); // avoid reserved keywords
    };

    function toISOStringSafe(date) {
      try {
        return date.toISOString();
      } catch (e) {
        if (e instanceof RangeError) {
          return date.toString();
        }

        throw e;
      }
    }

    function addComputedColumns(chart, dataset) {
      let virtualColumns = chart.getMetadata('describe.computed-columns', {});

      if (!Array.isArray(virtualColumns)) {
        // convert to array
        virtualColumns = Object.keys(virtualColumns).reduce((acc, cur) => {
          acc.push({
            name: cur,
            formula: virtualColumns[cur]
          });
          return acc;
        }, []);
      }

      const data = applyChanges(chart, dataset).list();
      const columnNameToVar = {};
      const colAggregates = {};
      const parser = new Parser();
      dataset.eachColumn(function (col) {
        if (col.isComputed) return;
        columnNameToVar[col.name()] = columnNameToVariable(col.name());

        if (col.type() === 'number') {
          const [min, max] = col.range();
          colAggregates[col.name()] = {
            min,
            max,
            sum: col.sum(),
            mean: col.mean(),
            median: col.median()
          };
        } else if (col.type() === 'date') {
          const [min, max] = col.range();
          colAggregates[col.name()] = {
            min,
            max
          };
        }
      }); // initialize meta objects for each computed column

      const vNamesToVar = virtualColumns.reduce((acc, val, idx) => {
        const key = columnNameToVariable(val.name);
        return acc.set(key, {
          name: val.name,
          index: dataset.numColumns() + idx,
          key,
          formula: val.formula,
          visited: 0,
          computed: false,
          dependsOn: []
        });
      }, new Map()); // parse formulas to detect cross-column dependencies

      virtualColumns.forEach(_ref => {
        let {
          formula,
          name
        } = _ref;
        const col = vNamesToVar.get(columnNameToVariable(name));

        if (formula.trim()) {
          try {
            col.expr = parser.parse(formula.trim());
            col.expr.variables().forEach(v => {
              v = v.split('__')[0];

              if (vNamesToVar.has(v)) {
                col.dependsOn.push(vNamesToVar.get(v));
              }
            });
          } catch (e) {
            col.error = e.message; // console.error('err', e);
          }
        } else {
          col.expr = {
            evaluate() {
              return '';
            },

            variables() {
              return [];
            }

          };
        }
      }); // sort computed columns in order of their dependency graph
      // circular dependencies are not allowed and will result in
      // errors

      const computedColumns = [];
      let curIter = 0;

      while (vNamesToVar.size) {
        if (curIter > 1000) break;
        vNamesToVar.forEach(col => {
          curIter++;

          try {
            visit(col, []);
          } catch (e) {
            if (e.message.startsWith('circular-dependency')) {
              col.error = e.message; // col.computed = true;

              vNamesToVar.delete(col.key);
              computedColumns.push(col);
            } else {
              throw e;
            }
          }
        });
      } // compute in order of dependencies


      computedColumns.forEach(col => {
        if (col.error) {
          const errorCol = Column(col.name, data.map(() => 'null'));
          errorCol.isComputed = true;
          errorCol.formula = col.formula;
          errorCol.errors = [{
            message: col.error,
            row: 'all'
          }];
          col.column = errorCol;
        } else {
          col.column = addComputedColumn(col);
        }
      }); // add to dataset in original order

      computedColumns.sort((a, b) => a.index - b.index).forEach(_ref2 => {
        let {
          column
        } = _ref2;
        return dataset.add(column);
      });
      return dataset;

      function visit(col, stack) {
        if (col.computed) return;
        stack.push(col.name);

        for (let i = 0; i < stack.length - 2; i++) {
          if (col.name === stack[i]) {
            throw new Error('circular-dependency: ' + stack.join(' ‣ '));
          }
        }

        col.curIter = curIter;
        let allComputed = true;

        for (let i = 0; i < col.dependsOn.length; i++) {
          allComputed = allComputed && col.dependsOn[i].computed;
        }

        if (allComputed) {
          // no dependencies, we can compute this now
          col.computed = true;
          computedColumns.push(col);
          vNamesToVar.delete(col.key);
        } else {
          if (stack.length < 10) {
            col.dependsOn.forEach(c => {
              visit(c, stack.slice(0));
            });
          }
        }
      }

      function addComputedColumn(_ref3) {
        let {
          formula,
          name,
          expr,
          error,
          index
        } = _ref3;
        const errors = [];

        if (error) {
          errors.push({
            row: 'all',
            message: error
          });
        } // create a map of changes for this column


        const changes = chart.getMetadata('data.changes', []).filter(change => change.column === index && change.row > 0).reduce((acc, cur) => {
          const old = acc.get(cur.row - 1);

          if (old) {
            // overwrite previous value
            cur.previous = old.previous;
          }

          acc.set(cur.row - 1, cur);
          return acc;
        }, new Map());
        const values = data.map(function (row, index) {
          const context = {
            ROWNUMBER: index
          };
          each(row, function (val, key) {
            if (!columnNameToVar[key]) return;
            context[columnNameToVar[key]] = val;

            if (colAggregates[key]) {
              Object.keys(colAggregates[key]).forEach(aggr => {
                context[`${columnNameToVar[key]}__${aggr}`] = colAggregates[key][aggr];
              });
            }
          });
          let value;

          try {
            value = expr.evaluate(context);

            if (typeof value === 'function') {
              errors.push({
                message: 'formula returned function',
                row: index
              });
              value = null;
            }
          } catch (error) {
            errors.push({
              message: error.message,
              row: index
            });
            value = null;
          }

          if (changes.has(index)) {
            const change = changes.get(index);

            if (change.previous === undefined || change.previous == value) {
              // we have a change and it's still valid
              return change.value;
            }
          }

          return value;
        });
        columnNameToVar[name] = columnNameToVariable(name); // apply values to rows so they can be used in formulas

        values.forEach((val, i) => {
          data[i][name] = val;
        });
        var virtualColumn = Column(name, values.map(function (v) {
          if (isBoolean(v)) return v ? 'yes' : 'no';
          if (isDate(v)) return toISOStringSafe(v);
          if (isNumber(v)) return String(v);
          if (isNull(v)) return null;
          return String(v);
        })); // aggregate values

        if (virtualColumn.type() === 'number') {
          const [min, max] = virtualColumn.range();
          colAggregates[name] = {
            min,
            max,
            sum: virtualColumn.sum(),
            mean: virtualColumn.mean(),
            median: virtualColumn.median()
          };
        } else if (virtualColumn.type() === 'date') {
          const [min, max] = virtualColumn.range();
          colAggregates[name] = {
            min,
            max
          };
        }

        virtualColumn.isComputed = true;
        virtualColumn.errors = errors;
        virtualColumn.formula = formula;
        return virtualColumn;
      }
    }

    /**
     * Chart
     * @module dw.chart
     */

    function chart (attributes) {
      // private methods and properties
      let dataset;
      let theme;
      let metricPrefix;
      let locale;
      let flags = {};
      let visualization;
      const changeCallbacks = events();
      const datasetChangeCallbacks = events();
      const _assets = {};
      let _translations = {};

      let _ds; // public interface


      const chart = {
        /**
         * @function chart.get
         */
        get(key, _default) {
          return get_1(attributes, key, _default);
        },

        getMetadata(key, _default) {
          return get_1(attributes, `metadata.${key}`, _default);
        },

        set(key, value) {
          if (set(attributes, key, value)) {
            changeCallbacks.fire(chart, key, value);
          }

          return this;
        },

        setMetadata(key, value) {
          return chart.set(`metadata.${key}`, value);
        },

        getElementBounds(element) {
          const rootBounds = visualization.target().getBoundingClientRect();
          const elementBounds = element.getBoundingClientRect();
          return {
            top: elementBounds.top - rootBounds.top,
            right: elementBounds.right - rootBounds.left,
            bottom: elementBounds.bottom - rootBounds.top,
            left: elementBounds.left - rootBounds.left,
            width: elementBounds.width,
            height: elementBounds.height
          };
        },

        // loads the dataset and returns a deferred
        load(csv, externalData) {
          const dsopts = {
            chartId: chart.get('id'),
            firstRowIsHeader: chart.get('metadata.data.horizontal-header', true),
            transpose: chart.get('metadata.data.transpose', false)
          };
          if ((csv || csv === '') && !externalData) dsopts.csv = csv;else dsopts.url = externalData || 'data.csv';
          const datasource = chart.get('metadata.data.json') ? json(dsopts) : delimited(dsopts);
          return datasource.dataset().then(ds => {
            this.dataset(ds);
            datasetChangeCallbacks.fire(chart, ds);
            return ds;
          });
        },

        /**
         * Getter/setter for the dw.dataset class. This method
         * can also be used to "reset" the current dataset by passing
         * true as argument. This will re-apply changes, column sorting
         * and computed columns to the existing dataset.
         *
         * @param {dw.dataset|true}
         *
         * @returns dataset
         */
        dataset(ds) {
          if (arguments.length) {
            if (ds !== true) _ds = ds;
            dataset = chart.get('metadata.data.json') ? _ds : reorderColumns(chart, applyChanges(chart, addComputedColumns(chart, _ds)));
            if (ds === true) return dataset;
            return chart;
          }

          return dataset;
        },

        /**
         * This helper method is used by the chart editor to inject
         * a dataset which has computed columns, changes and column
         * ordering already applied.
         *
         * @param {dw.dataset} ds
         */
        setDataset(ds) {
          dataset = ds;
        },

        // sets or gets the theme
        theme(_theme) {
          if (arguments.length) {
            theme = _theme;
            return chart;
          }

          return theme || {};
        },

        // sets or gets the visualization
        vis(_vis) {
          if (arguments.length) {
            visualization = _vis;
            visualization.chart(chart);
            return chart;
          }

          return visualization;
        },

        // returns true if the user has set any highlights
        hasHighlight() {
          var hl = chart.get('metadata.visualize.highlighted-series');
          return isArray$5(hl) && hl.length > 0;
        },

        isHighlighted(obj) {
          if (isUndefined(obj) === undefined) return false;
          const hl = chart.get('metadata.visualize.highlighted-series');
          const objName = name(obj);
          return !isArray$5(hl) || hl.length === 0 || indexOf(hl, objName) >= 0;
        },

        locale(_locale, callback) {
          if (arguments.length) {
            locale = _locale.replace('_', '-');
            if (!locale) locale = 'en-US';
            if (typeof callback === 'function') callback();
            return chart;
          }

          return locale;
        },

        metricPrefix(_metricPrefix) {
          if (arguments.length) {
            metricPrefix = _metricPrefix;
            return chart;
          }

          return metricPrefix;
        },

        inEditor: () => {
          try {
            return window.parent !== window && window.parent.dw && window.parent.dw.backend && window.parent.dw.backend.hooks;
          } catch (ex) {
            return false;
          }
        },

        createPostEvent() {
          const chartId = chart.get('id');
          const {
            isIframe
          } = flags;
          return postEvent(chartId, isIframe);
        },

        // sets or gets the flags
        flags(_flags) {
          if (arguments.length) {
            flags = _flags;
            return chart;
          }

          return flags;
        },

        render(outerContainer) {
          if (!visualization || !theme || !dataset) {
            throw new Error('cannot render the chart!');
          }

          const isIframe = flags.isIframe;
          const container = chart.vis().target();
          visualization.chart(chart); // compute chart dimensions

          const w = width(container);
          const h = isIframe ? getMaxChartHeight() : chart.getMetadata('publish.chart-height') || 400;
          const heightMode = chart.getHeightMode(); // only render if iframe has valid dimensions

          if (heightMode === 'fixed' ? w <= 0 : w <= 0 || h <= 0) {
            console.warn('Aborting chart rendering due to invalid container dimensions');
            window.clearInterval(this.__resizingInterval);
            this.__resizingInterval = setInterval(postMessage, 1000);
            postMessage();
            return;
          } // set chart mode class


          [container, outerContainer].forEach(el => {
            el.classList.toggle('vis-height-fit', heightMode === 'fit');
            el.classList.toggle('vis-height-fixed', heightMode === 'fixed');
          }); // set mobile class

          const breakpoint = get_1(theme, `vis.${chart.type}.mobileBreakpoint`, 450);
          outerContainer.classList.toggle('is-mobile', outerContainer.clientWidth <= breakpoint); // really needed?

          outerContainer.classList.add('vis-' + visualization.id);
          visualization.reset(container);
          visualization.size(w, h);

          visualization.__init();

          visualization.render(container);

          if (isIframe) {
            window.clearInterval(this.__resizingInterval);
            this.__resizingInterval = setInterval(postMessage, 1000);
            postMessage();
          }

          function postMessage() {
            if (flags && flags.fitchart) return;
            let desiredHeight;

            if (chart.getHeightMode() === 'fit') {
              if (chart.inEditor() || !chart.getMetadata('publish.chart-height')) return;
              desiredHeight = getNonChartHeight() + chart.getMetadata('publish.chart-height');
            } else {
              desiredHeight = outerHeight(document.querySelector('html'), true);
            }

            if (Math.round(window.innerHeight) === Math.round(desiredHeight)) {
              // no need to request a height change here
              return;
            }

            const {
              previewId
            } = flags; // datawrapper responsive embed

            window.parent.postMessage({
              'datawrapper-height': {
                [chart.get().id]: desiredHeight,
                ...(previewId ? {
                  previewId
                } : {})
              }
            }, '*'); // Google AMP

            window.parent.postMessage({
              sentinel: 'amp',
              type: 'embed-size',
              height: desiredHeight
            }, '*'); // Medium

            window.parent.postMessage(JSON.stringify({
              src: location.href,
              context: 'iframe.resize',
              height: desiredHeight
            }), '*');

            if (typeof window.datawrapperHeightCallback === 'function') {
              window.datawrapperHeightCallback(desiredHeight);
            }
          }
        },

        getHeightMode() {
          const themeFitChart = get_1(visualization.theme(), 'vis.d3-pies.fitchart', false) && ['d3-pies', 'd3-donuts', 'd3-multiple-pies', 'd3-multiple-donuts'].indexOf(visualization.meta.id) > -1;
          const urlParams = new URLSearchParams(window.location.search);
          const urlFitChart = !!urlParams.get('fitchart');
          return themeFitChart || urlFitChart || visualization.meta.height !== 'fixed' ? 'fit' : 'fixed';
        },

        attributes(attrs) {
          if (arguments.length) {
            const diff = objectDiff(attributes, attrs);
            attributes = attrs; // fire onChange callbacks

            getNestedObjectKeys(diff).forEach(key => {
              changeCallbacks.fire(chart, key, get_1(attrs, key));
            });
            return chart;
          }

          return attributes;
        },

        // Legacy event-handling (TODO: Remove/replace?):
        onChange: changeCallbacks.add,
        onDatasetChange: datasetChangeCallbacks.add,

        dataCellChanged(column, row) {
          const changes = chart.get('metadata.data.changes', []);
          const transpose = chart.get('metadata.data.transpose', false);
          let changed = false;
          const order = dataset.columnOrder();
          column = order[column];
          changes.forEach(change => {
            let r = 'row';
            let c = 'column';

            if (transpose) {
              r = 'column';
              c = 'row';
            }

            if (column === change[c] && change[r] === row) {
              changed = true;
            }
          });
          return changed;
        },

        asset(id, asset) {
          if (arguments.length === 1) {
            return _assets[id];
          }

          _assets[id] = asset;
        },

        translations(values) {
          if (arguments.length === 0) {
            return _translations;
          }

          _translations = values;
          return this;
        },

        translate(key) {
          if (!_translations[key]) return 'MISSING: ' + key;
          var translation = _translations[key];

          if (typeof translation === 'string' && arguments.length > 1) {
            // replace $0, $1 etc with remaining arguments
            translation = translation.replace(/\$(\d)/g, (m, i) => {
              i = 1 + Number(i);
              if (arguments[i] === undefined) return m;
              return arguments[i];
            });
          }

          return translation;
        }

      };
      return chart;
    }
    /**
     * returns list of keys defined in an object
     *
     * @param {object} object
     * @returns {string[]} list of keys
     */

    function getNestedObjectKeys(object) {
      const candidates = Object.keys(object);
      const keys = [];
      candidates.forEach(key => {
        if (!isPlainObject_1(object[key])) keys.push(key);else {
          getNestedObjectKeys(object[key]).forEach(subkey => {
            keys.push(`${key}.${subkey}`);
          });
        }
      });
      return keys;
    }

    var numeral$1 = {exports: {}};

    /*! @preserve
     * numeral.js
     * version : 2.0.6
     * author : Adam Draper
     * license : MIT
     * http://adamwdraper.github.com/Numeral-js/
     */

    (function (module) {
    	(function (global, factory) {
    	    if (module.exports) {
    	        module.exports = factory();
    	    } else {
    	        global.numeral = factory();
    	    }
    	}(commonjsGlobal, function () {
    	    /************************************
    	        Variables
    	    ************************************/

    	    var numeral,
    	        _,
    	        VERSION = '2.0.6',
    	        formats = {},
    	        locales = {},
    	        defaults = {
    	            currentLocale: 'en',
    	            zeroFormat: null,
    	            nullFormat: null,
    	            defaultFormat: '0,0',
    	            scalePercentBy100: true
    	        },
    	        options = {
    	            currentLocale: defaults.currentLocale,
    	            zeroFormat: defaults.zeroFormat,
    	            nullFormat: defaults.nullFormat,
    	            defaultFormat: defaults.defaultFormat,
    	            scalePercentBy100: defaults.scalePercentBy100
    	        };


    	    /************************************
    	        Constructors
    	    ************************************/

    	    // Numeral prototype object
    	    function Numeral(input, number) {
    	        this._input = input;

    	        this._value = number;
    	    }

    	    numeral = function(input) {
    	        var value,
    	            kind,
    	            unformatFunction,
    	            regexp;

    	        if (numeral.isNumeral(input)) {
    	            value = input.value();
    	        } else if (input === 0 || typeof input === 'undefined') {
    	            value = 0;
    	        } else if (input === null || _.isNaN(input)) {
    	            value = null;
    	        } else if (typeof input === 'string') {
    	            if (options.zeroFormat && input === options.zeroFormat) {
    	                value = 0;
    	            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {
    	                value = null;
    	            } else {
    	                for (kind in formats) {
    	                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;

    	                    if (regexp && input.match(regexp)) {
    	                        unformatFunction = formats[kind].unformat;

    	                        break;
    	                    }
    	                }

    	                unformatFunction = unformatFunction || numeral._.stringToNumber;

    	                value = unformatFunction(input);
    	            }
    	        } else {
    	            value = Number(input)|| null;
    	        }

    	        return new Numeral(input, value);
    	    };

    	    // version number
    	    numeral.version = VERSION;

    	    // compare numeral object
    	    numeral.isNumeral = function(obj) {
    	        return obj instanceof Numeral;
    	    };

    	    // helper functions
    	    numeral._ = _ = {
    	        // formats numbers separators, decimals places, signs, abbreviations
    	        numberToFormat: function(value, format, roundingFunction) {
    	            var locale = locales[numeral.options.currentLocale],
    	                negP = false,
    	                optDec = false,
    	                leadingCount = 0,
    	                abbr = '',
    	                trillion = 1000000000000,
    	                billion = 1000000000,
    	                million = 1000000,
    	                thousand = 1000,
    	                decimal = '',
    	                neg = false,
    	                abbrForce, // force abbreviation
    	                abs,
    	                int,
    	                precision,
    	                signed,
    	                thousands,
    	                output;

    	            // make sure we never format a null value
    	            value = value || 0;

    	            abs = Math.abs(value);

    	            // see if we should use parentheses for negative number or if we should prefix with a sign
    	            // if both are present we default to parentheses
    	            if (numeral._.includes(format, '(')) {
    	                negP = true;
    	                format = format.replace(/[\(|\)]/g, '');
    	            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
    	                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
    	                format = format.replace(/[\+|\-]/g, '');
    	            }

    	            // see if abbreviation is wanted
    	            if (numeral._.includes(format, 'a')) {
    	                abbrForce = format.match(/a(k|m|b|t)?/);

    	                abbrForce = abbrForce ? abbrForce[1] : false;

    	                // check for space before abbreviation
    	                if (numeral._.includes(format, ' a')) {
    	                    abbr = ' ';
    	                }

    	                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');

    	                if (abs >= trillion && !abbrForce || abbrForce === 't') {
    	                    // trillion
    	                    abbr += locale.abbreviations.trillion;
    	                    value = value / trillion;
    	                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {
    	                    // billion
    	                    abbr += locale.abbreviations.billion;
    	                    value = value / billion;
    	                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {
    	                    // million
    	                    abbr += locale.abbreviations.million;
    	                    value = value / million;
    	                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {
    	                    // thousand
    	                    abbr += locale.abbreviations.thousand;
    	                    value = value / thousand;
    	                }
    	            }

    	            // check for optional decimals
    	            if (numeral._.includes(format, '[.]')) {
    	                optDec = true;
    	                format = format.replace('[.]', '.');
    	            }

    	            // break number and format
    	            int = value.toString().split('.')[0];
    	            precision = format.split('.')[1];
    	            thousands = format.indexOf(',');
    	            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;

    	            if (precision) {
    	                if (numeral._.includes(precision, '[')) {
    	                    precision = precision.replace(']', '');
    	                    precision = precision.split('[');
    	                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
    	                } else {
    	                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
    	                }

    	                int = decimal.split('.')[0];

    	                if (numeral._.includes(decimal, '.')) {
    	                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
    	                } else {
    	                    decimal = '';
    	                }

    	                if (optDec && Number(decimal.slice(1)) === 0) {
    	                    decimal = '';
    	                }
    	            } else {
    	                int = numeral._.toFixed(value, 0, roundingFunction);
    	            }

    	            // check abbreviation again after rounding
    	            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
    	                int = String(Number(int) / 1000);

    	                switch (abbr) {
    	                    case locale.abbreviations.thousand:
    	                        abbr = locale.abbreviations.million;
    	                        break;
    	                    case locale.abbreviations.million:
    	                        abbr = locale.abbreviations.billion;
    	                        break;
    	                    case locale.abbreviations.billion:
    	                        abbr = locale.abbreviations.trillion;
    	                        break;
    	                }
    	            }


    	            // format number
    	            if (numeral._.includes(int, '-')) {
    	                int = int.slice(1);
    	                neg = true;
    	            }

    	            if (int.length < leadingCount) {
    	                for (var i = leadingCount - int.length; i > 0; i--) {
    	                    int = '0' + int;
    	                }
    	            }

    	            if (thousands > -1) {
    	                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
    	            }

    	            if (format.indexOf('.') === 0) {
    	                int = '';
    	            }

    	            output = int + decimal + (abbr ? abbr : '');

    	            if (negP) {
    	                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
    	            } else {
    	                if (signed >= 0) {
    	                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
    	                } else if (neg) {
    	                    output = '-' + output;
    	                }
    	            }

    	            return output;
    	        },
    	        // unformats numbers separators, decimals places, signs, abbreviations
    	        stringToNumber: function(string) {
    	            var locale = locales[options.currentLocale],
    	                stringOriginal = string,
    	                abbreviations = {
    	                    thousand: 3,
    	                    million: 6,
    	                    billion: 9,
    	                    trillion: 12
    	                },
    	                abbreviation,
    	                value,
    	                regexp;

    	            if (options.zeroFormat && string === options.zeroFormat) {
    	                value = 0;
    	            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {
    	                value = null;
    	            } else {
    	                value = 1;

    	                if (locale.delimiters.decimal !== '.') {
    	                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
    	                }

    	                for (abbreviation in abbreviations) {
    	                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');

    	                    if (stringOriginal.match(regexp)) {
    	                        value *= Math.pow(10, abbreviations[abbreviation]);
    	                        break;
    	                    }
    	                }

    	                // check for negative number
    	                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;

    	                // remove non numbers
    	                string = string.replace(/[^0-9\.]+/g, '');

    	                value *= Number(string);
    	            }

    	            return value;
    	        },
    	        isNaN: function(value) {
    	            return typeof value === 'number' && isNaN(value);
    	        },
    	        includes: function(string, search) {
    	            return string.indexOf(search) !== -1;
    	        },
    	        insert: function(string, subString, start) {
    	            return string.slice(0, start) + subString + string.slice(start);
    	        },
    	        reduce: function(array, callback /*, initialValue*/) {
    	            if (this === null) {
    	                throw new TypeError('Array.prototype.reduce called on null or undefined');
    	            }

    	            if (typeof callback !== 'function') {
    	                throw new TypeError(callback + ' is not a function');
    	            }

    	            var t = Object(array),
    	                len = t.length >>> 0,
    	                k = 0,
    	                value;

    	            if (arguments.length === 3) {
    	                value = arguments[2];
    	            } else {
    	                while (k < len && !(k in t)) {
    	                    k++;
    	                }

    	                if (k >= len) {
    	                    throw new TypeError('Reduce of empty array with no initial value');
    	                }

    	                value = t[k++];
    	            }
    	            for (; k < len; k++) {
    	                if (k in t) {
    	                    value = callback(value, t[k], k, t);
    	                }
    	            }
    	            return value;
    	        },
    	        /**
    	         * Computes the multiplier necessary to make x >= 1,
    	         * effectively eliminating miscalculations caused by
    	         * finite precision.
    	         */
    	        multiplier: function (x) {
    	            var parts = x.toString().split('.');

    	            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
    	        },
    	        /**
    	         * Given a variable number of arguments, returns the maximum
    	         * multiplier that must be used to normalize an operation involving
    	         * all of them.
    	         */
    	        correctionFactor: function () {
    	            var args = Array.prototype.slice.call(arguments);

    	            return args.reduce(function(accum, next) {
    	                var mn = _.multiplier(next);
    	                return accum > mn ? accum : mn;
    	            }, 1);
    	        },
    	        /**
    	         * Implementation of toFixed() that treats floats more like decimals
    	         *
    	         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
    	         * problems for accounting- and finance-related software.
    	         */
    	        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
    	            var splitValue = value.toString().split('.'),
    	                minDecimals = maxDecimals - (optionals || 0),
    	                boundedPrecision,
    	                optionalsRegExp,
    	                power,
    	                output;

    	            // Use the smallest precision value possible to avoid errors from floating point representation
    	            if (splitValue.length === 2) {
    	              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
    	            } else {
    	              boundedPrecision = minDecimals;
    	            }

    	            power = Math.pow(10, boundedPrecision);

    	            // Multiply up by precision, round accurately, then divide and use native toFixed():
    	            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);

    	            if (optionals > maxDecimals - boundedPrecision) {
    	                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
    	                output = output.replace(optionalsRegExp, '');
    	            }

    	            return output;
    	        }
    	    };

    	    // avaliable options
    	    numeral.options = options;

    	    // avaliable formats
    	    numeral.formats = formats;

    	    // avaliable formats
    	    numeral.locales = locales;

    	    // This function sets the current locale.  If
    	    // no arguments are passed in, it will simply return the current global
    	    // locale key.
    	    numeral.locale = function(key) {
    	        if (key) {
    	            options.currentLocale = key.toLowerCase();
    	        }

    	        return options.currentLocale;
    	    };

    	    // This function provides access to the loaded locale data.  If
    	    // no arguments are passed in, it will simply return the current
    	    // global locale object.
    	    numeral.localeData = function(key) {
    	        if (!key) {
    	            return locales[options.currentLocale];
    	        }

    	        key = key.toLowerCase();

    	        if (!locales[key]) {
    	            throw new Error('Unknown locale : ' + key);
    	        }

    	        return locales[key];
    	    };

    	    numeral.reset = function() {
    	        for (var property in defaults) {
    	            options[property] = defaults[property];
    	        }
    	    };

    	    numeral.zeroFormat = function(format) {
    	        options.zeroFormat = typeof(format) === 'string' ? format : null;
    	    };

    	    numeral.nullFormat = function (format) {
    	        options.nullFormat = typeof(format) === 'string' ? format : null;
    	    };

    	    numeral.defaultFormat = function(format) {
    	        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';
    	    };

    	    numeral.register = function(type, name, format) {
    	        name = name.toLowerCase();

    	        if (this[type + 's'][name]) {
    	            throw new TypeError(name + ' ' + type + ' already registered.');
    	        }

    	        this[type + 's'][name] = format;

    	        return format;
    	    };


    	    numeral.validate = function(val, culture) {
    	        var _decimalSep,
    	            _thousandSep,
    	            _currSymbol,
    	            _valArray,
    	            _abbrObj,
    	            _thousandRegEx,
    	            localeData,
    	            temp;

    	        //coerce val to string
    	        if (typeof val !== 'string') {
    	            val += '';

    	            if (console.warn) {
    	                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
    	            }
    	        }

    	        //trim whitespaces from either sides
    	        val = val.trim();

    	        //if val is just digits return true
    	        if (!!val.match(/^\d+$/)) {
    	            return true;
    	        }

    	        //if val is empty return false
    	        if (val === '') {
    	            return false;
    	        }

    	        //get the decimal and thousands separator from numeral.localeData
    	        try {
    	            //check if the culture is understood by numeral. if not, default it to current locale
    	            localeData = numeral.localeData(culture);
    	        } catch (e) {
    	            localeData = numeral.localeData(numeral.locale());
    	        }

    	        //setup the delimiters and currency symbol based on culture/locale
    	        _currSymbol = localeData.currency.symbol;
    	        _abbrObj = localeData.abbreviations;
    	        _decimalSep = localeData.delimiters.decimal;
    	        if (localeData.delimiters.thousands === '.') {
    	            _thousandSep = '\\.';
    	        } else {
    	            _thousandSep = localeData.delimiters.thousands;
    	        }

    	        // validating currency symbol
    	        temp = val.match(/^[^\d]+/);
    	        if (temp !== null) {
    	            val = val.substr(1);
    	            if (temp[0] !== _currSymbol) {
    	                return false;
    	            }
    	        }

    	        //validating abbreviation symbol
    	        temp = val.match(/[^\d]+$/);
    	        if (temp !== null) {
    	            val = val.slice(0, -1);
    	            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
    	                return false;
    	            }
    	        }

    	        _thousandRegEx = new RegExp(_thousandSep + '{2}');

    	        if (!val.match(/[^\d.,]/g)) {
    	            _valArray = val.split(_decimalSep);
    	            if (_valArray.length > 2) {
    	                return false;
    	            } else {
    	                if (_valArray.length < 2) {
    	                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
    	                } else {
    	                    if (_valArray[0].length === 1) {
    	                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
    	                    } else {
    	                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
    	                    }
    	                }
    	            }
    	        }

    	        return false;
    	    };


    	    /************************************
    	        Numeral Prototype
    	    ************************************/

    	    numeral.fn = Numeral.prototype = {
    	        clone: function() {
    	            return numeral(this);
    	        },
    	        format: function(inputString, roundingFunction) {
    	            var value = this._value,
    	                format = inputString || options.defaultFormat,
    	                kind,
    	                output,
    	                formatFunction;

    	            // make sure we have a roundingFunction
    	            roundingFunction = roundingFunction || Math.round;

    	            // format based on value
    	            if (value === 0 && options.zeroFormat !== null) {
    	                output = options.zeroFormat;
    	            } else if (value === null && options.nullFormat !== null) {
    	                output = options.nullFormat;
    	            } else {
    	                for (kind in formats) {
    	                    if (format.match(formats[kind].regexps.format)) {
    	                        formatFunction = formats[kind].format;

    	                        break;
    	                    }
    	                }

    	                formatFunction = formatFunction || numeral._.numberToFormat;

    	                output = formatFunction(value, format, roundingFunction);
    	            }

    	            return output;
    	        },
    	        value: function() {
    	            return this._value;
    	        },
    	        input: function() {
    	            return this._input;
    	        },
    	        set: function(value) {
    	            this._value = Number(value);

    	            return this;
    	        },
    	        add: function(value) {
    	            var corrFactor = _.correctionFactor.call(null, this._value, value);

    	            function cback(accum, curr, currI, O) {
    	                return accum + Math.round(corrFactor * curr);
    	            }

    	            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;

    	            return this;
    	        },
    	        subtract: function(value) {
    	            var corrFactor = _.correctionFactor.call(null, this._value, value);

    	            function cback(accum, curr, currI, O) {
    	                return accum - Math.round(corrFactor * curr);
    	            }

    	            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;

    	            return this;
    	        },
    	        multiply: function(value) {
    	            function cback(accum, curr, currI, O) {
    	                var corrFactor = _.correctionFactor(accum, curr);
    	                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
    	            }

    	            this._value = _.reduce([this._value, value], cback, 1);

    	            return this;
    	        },
    	        divide: function(value) {
    	            function cback(accum, curr, currI, O) {
    	                var corrFactor = _.correctionFactor(accum, curr);
    	                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
    	            }

    	            this._value = _.reduce([this._value, value], cback);

    	            return this;
    	        },
    	        difference: function(value) {
    	            return Math.abs(numeral(this._value).subtract(value).value());
    	        }
    	    };

    	    /************************************
    	        Default Locale && Format
    	    ************************************/

    	    numeral.register('locale', 'en', {
    	        delimiters: {
    	            thousands: ',',
    	            decimal: '.'
    	        },
    	        abbreviations: {
    	            thousand: 'k',
    	            million: 'm',
    	            billion: 'b',
    	            trillion: 't'
    	        },
    	        ordinal: function(number) {
    	            var b = number % 10;
    	            return (~~(number % 100 / 10) === 1) ? 'th' :
    	                (b === 1) ? 'st' :
    	                (b === 2) ? 'nd' :
    	                (b === 3) ? 'rd' : 'th';
    	        },
    	        currency: {
    	            symbol: '$'
    	        }
    	    });

    	    

    	(function() {
    	        numeral.register('format', 'bps', {
    	            regexps: {
    	                format: /(BPS)/,
    	                unformat: /(BPS)/
    	            },
    	            format: function(value, format, roundingFunction) {
    	                var space = numeral._.includes(format, ' BPS') ? ' ' : '',
    	                    output;

    	                value = value * 10000;

    	                // check for space before BPS
    	                format = format.replace(/\s?BPS/, '');

    	                output = numeral._.numberToFormat(value, format, roundingFunction);

    	                if (numeral._.includes(output, ')')) {
    	                    output = output.split('');

    	                    output.splice(-1, 0, space + 'BPS');

    	                    output = output.join('');
    	                } else {
    	                    output = output + space + 'BPS';
    	                }

    	                return output;
    	            },
    	            unformat: function(string) {
    	                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
    	            }
    	        });
    	})();


    	(function() {
    	        var decimal = {
    	            base: 1000,
    	            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    	        },
    	        binary = {
    	            base: 1024,
    	            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
    	        };

    	    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {
    	            return decimal.suffixes.indexOf(item) < 0;
    	        }));
    	        var unformatRegex = allSuffixes.join('|');
    	        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
    	        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';

    	    numeral.register('format', 'bytes', {
    	        regexps: {
    	            format: /([0\s]i?b)/,
    	            unformat: new RegExp(unformatRegex)
    	        },
    	        format: function(value, format, roundingFunction) {
    	            var output,
    	                bytes = numeral._.includes(format, 'ib') ? binary : decimal,
    	                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
    	                power,
    	                min,
    	                max;

    	            // check for space before
    	            format = format.replace(/\s?i?b/, '');

    	            for (power = 0; power <= bytes.suffixes.length; power++) {
    	                min = Math.pow(bytes.base, power);
    	                max = Math.pow(bytes.base, power + 1);

    	                if (value === null || value === 0 || value >= min && value < max) {
    	                    suffix += bytes.suffixes[power];

    	                    if (min > 0) {
    	                        value = value / min;
    	                    }

    	                    break;
    	                }
    	            }

    	            output = numeral._.numberToFormat(value, format, roundingFunction);

    	            return output + suffix;
    	        },
    	        unformat: function(string) {
    	            var value = numeral._.stringToNumber(string),
    	                power,
    	                bytesMultiplier;

    	            if (value) {
    	                for (power = decimal.suffixes.length - 1; power >= 0; power--) {
    	                    if (numeral._.includes(string, decimal.suffixes[power])) {
    	                        bytesMultiplier = Math.pow(decimal.base, power);

    	                        break;
    	                    }

    	                    if (numeral._.includes(string, binary.suffixes[power])) {
    	                        bytesMultiplier = Math.pow(binary.base, power);

    	                        break;
    	                    }
    	                }

    	                value *= (bytesMultiplier || 1);
    	            }

    	            return value;
    	        }
    	    });
    	})();


    	(function() {
    	        numeral.register('format', 'currency', {
    	        regexps: {
    	            format: /(\$)/
    	        },
    	        format: function(value, format, roundingFunction) {
    	            var locale = numeral.locales[numeral.options.currentLocale],
    	                symbols = {
    	                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
    	                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
    	                },
    	                output,
    	                symbol,
    	                i;

    	            // strip format of spaces and $
    	            format = format.replace(/\s?\$\s?/, '');

    	            // format the number
    	            output = numeral._.numberToFormat(value, format, roundingFunction);

    	            // update the before and after based on value
    	            if (value >= 0) {
    	                symbols.before = symbols.before.replace(/[\-\(]/, '');
    	                symbols.after = symbols.after.replace(/[\-\)]/, '');
    	            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
    	                symbols.before = '-' + symbols.before;
    	            }

    	            // loop through each before symbol
    	            for (i = 0; i < symbols.before.length; i++) {
    	                symbol = symbols.before[i];

    	                switch (symbol) {
    	                    case '$':
    	                        output = numeral._.insert(output, locale.currency.symbol, i);
    	                        break;
    	                    case ' ':
    	                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
    	                        break;
    	                }
    	            }

    	            // loop through each after symbol
    	            for (i = symbols.after.length - 1; i >= 0; i--) {
    	                symbol = symbols.after[i];

    	                switch (symbol) {
    	                    case '$':
    	                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
    	                        break;
    	                    case ' ':
    	                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
    	                        break;
    	                }
    	            }


    	            return output;
    	        }
    	    });
    	})();


    	(function() {
    	        numeral.register('format', 'exponential', {
    	        regexps: {
    	            format: /(e\+|e-)/,
    	            unformat: /(e\+|e-)/
    	        },
    	        format: function(value, format, roundingFunction) {
    	            var output,
    	                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',
    	                parts = exponential.split('e');

    	            format = format.replace(/e[\+|\-]{1}0/, '');

    	            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);

    	            return output + 'e' + parts[1];
    	        },
    	        unformat: function(string) {
    	            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),
    	                value = Number(parts[0]),
    	                power = Number(parts[1]);

    	            power = numeral._.includes(string, 'e-') ? power *= -1 : power;

    	            function cback(accum, curr, currI, O) {
    	                var corrFactor = numeral._.correctionFactor(accum, curr),
    	                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);
    	                return num;
    	            }

    	            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
    	        }
    	    });
    	})();


    	(function() {
    	        numeral.register('format', 'ordinal', {
    	        regexps: {
    	            format: /(o)/
    	        },
    	        format: function(value, format, roundingFunction) {
    	            var locale = numeral.locales[numeral.options.currentLocale],
    	                output,
    	                ordinal = numeral._.includes(format, ' o') ? ' ' : '';

    	            // check for space before
    	            format = format.replace(/\s?o/, '');

    	            ordinal += locale.ordinal(value);

    	            output = numeral._.numberToFormat(value, format, roundingFunction);

    	            return output + ordinal;
    	        }
    	    });
    	})();


    	(function() {
    	        numeral.register('format', 'percentage', {
    	        regexps: {
    	            format: /(%)/,
    	            unformat: /(%)/
    	        },
    	        format: function(value, format, roundingFunction) {
    	            var space = numeral._.includes(format, ' %') ? ' ' : '',
    	                output;

    	            if (numeral.options.scalePercentBy100) {
    	                value = value * 100;
    	            }

    	            // check for space before %
    	            format = format.replace(/\s?\%/, '');

    	            output = numeral._.numberToFormat(value, format, roundingFunction);

    	            if (numeral._.includes(output, ')')) {
    	                output = output.split('');

    	                output.splice(-1, 0, space + '%');

    	                output = output.join('');
    	            } else {
    	                output = output + space + '%';
    	            }

    	            return output;
    	        },
    	        unformat: function(string) {
    	            var number = numeral._.stringToNumber(string);
    	            if (numeral.options.scalePercentBy100) {
    	                return number * 0.01;
    	            }
    	            return number;
    	        }
    	    });
    	})();


    	(function() {
    	        numeral.register('format', 'time', {
    	        regexps: {
    	            format: /(:)/,
    	            unformat: /(:)/
    	        },
    	        format: function(value, format, roundingFunction) {
    	            var hours = Math.floor(value / 60 / 60),
    	                minutes = Math.floor((value - (hours * 60 * 60)) / 60),
    	                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));

    	            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    	        },
    	        unformat: function(string) {
    	            var timeArray = string.split(':'),
    	                seconds = 0;

    	            // turn hours and minutes into seconds and add them all up
    	            if (timeArray.length === 3) {
    	                // hours
    	                seconds = seconds + (Number(timeArray[0]) * 60 * 60);
    	                // minutes
    	                seconds = seconds + (Number(timeArray[1]) * 60);
    	                // seconds
    	                seconds = seconds + Number(timeArray[2]);
    	            } else if (timeArray.length === 2) {
    	                // minutes
    	                seconds = seconds + (Number(timeArray[0]) * 60);
    	                // seconds
    	                seconds = seconds + Number(timeArray[1]);
    	            }
    	            return Number(seconds);
    	        }
    	    });
    	})();

    	return numeral;
    	}));
    } (numeral$1));

    var numeral = numeral$1.exports;

    /**
     * Assign dataset columns to visualization axes. Non-optional columns
     * will automatically be assigned based on a matching column type and
     * column name (if the vis axis defined a regex).
     *
     * Optional axes can define a `overrideOptionalKey` which will turn
     * it into a non-optional axis in case the specified metadata key
     * contains a truthy value.
     *
     * @param {Dataset} dataset - the parsed dataset
     * @param {object} visAxes - axis definitions from visualization
     * @param {object} userAxes - user preferences for axis assignments
     *                            (from chart.metadata.axis)
     * @param {object} overrideKeys - map of all axes overrideOptionalKeys
     *                                and the current metadata values
     * @returns {object}
     */

    function populateVisAxes(_ref) {
      let {
        dataset,
        visAxes,
        userAxes,
        overrideKeys
      } = _ref;
      userAxes = userAxes || {};
      overrideKeys = overrideKeys || {};
      const usedColumns = {};
      const axes = {};
      const axesAsColumns = {}; // get user preference

      each(visAxes, (o, key) => {
        if (userAxes[key]) {
          let columns = userAxes[key];

          if (o.optional && o.overrideOptionalKey && !overrideKeys[o.overrideOptionalKey]) {
            return;
          }

          if (columnExists(columns) && checkColumn(o, columns, true) && !!o.multiple === isArray$5(columns)) {
            axes[key] = o.multiple && !isArray$5(columns) ? [columns] : columns; // mark columns as used

            if (!isArray$5(columns)) columns = [columns];
            each(columns, function (column) {
              usedColumns[column] = true;
            });
          }
        }
      });
      var checked = [];
      each(visAxes, axisDef => {
        if (axisDef.optional) {
          // chart settings may override this
          if (axisDef.overrideOptionalKey && overrideKeys[axisDef.overrideOptionalKey]) {
            // now the axis is mandatory
            axisDef.optional = false;
          }
        }
      }); // auto-populate remaining axes

      each(visAxes, (axisDef, key) => {
        function remainingRequiredColumns(accepts) {
          // returns how many required columns there are for the remaining axes
          // either an integer or "multiple" if there's another multi-column axis coming up
          function equalAccepts(a1, a2) {
            if (typeof a1 === 'undefined' && typeof a2 !== 'undefined') return false;
            if (typeof a2 === 'undefined' && typeof a1 !== 'undefined') return false;
            if (a1.length !== a2.length) return false;

            for (let i = 0; i < a1.length; i++) {
              if (a2.indexOf(a1[i]) === -1) return false;
            }

            return true;
          }

          let res = 0;
          each(visAxes, function (axisDef, key) {
            if (checked.indexOf(key) > -1) return;
            if (!equalAccepts(axisDef.accepts, accepts)) return;
            if (typeof res === 'string') return;
            if (axisDef.optional) return;

            if (axisDef.multiple) {
              res = 'multiple';
              return;
            }

            res += 1;
          });
          return res;
        }

        function remainingAvailableColumns(dataset) {
          let count = 0;
          dataset.eachColumn(c => {
            if (checkColumn(axisDef, c)) {
              count++;
            }
          });
          return count;
        }

        checked.push(key);
        if (axes[key]) return; // user has defined this axis already

        if (!axisDef.optional) {
          // we only populate mandatory axes
          if (!axisDef.multiple) {
            const accepted = filter(dataset.columns(), c => checkColumn(axisDef, c));
            let firstMatch;

            if (axisDef.preferred) {
              // axis defined a regex for testing column names
              const regex = new RegExp(axisDef.preferred, 'i');
              firstMatch = find(accepted, function (col) {
                return regex.test(col.name()) || col.title() !== col.name() && regex.test(col.title());
              });
            } // simply use first colulmn accepted by axis


            if (!firstMatch) firstMatch = accepted[0];

            if (firstMatch) {
              usedColumns[firstMatch.name()] = true; // mark column as used

              axes[key] = firstMatch.name();
            } else {
              // try to auto-populate missing text column
              if (indexOf(axisDef.accepts, 'text') >= 0) {
                // try using the first text column in the dataset instead
                const acceptedAllowUsed = filter(dataset.columns(), function (col) {
                  return indexOf(axisDef.accepts, col.type()) >= 0;
                });

                if (acceptedAllowUsed.length) {
                  axes[key] = acceptedAllowUsed[0].name();
                } else {
                  // no other text column in dataset, so genetate one with A,B,C,D...
                  const col = Column(key, map(range(dataset.numRows()), function (i) {
                    return (i > 25 ? String.fromCharCode(64 + i / 26) : '') + String.fromCharCode(65 + i % 26);
                  }), 'text');
                  dataset.add(col);
                  usedColumns[col.name()] = true;
                  axes[key] = col.name();
                }
              }
            }
          } else {
            const required = remainingRequiredColumns(axisDef.accepts);
            let available = remainingAvailableColumns(dataset); // fill axis with all accepted columns

            axes[key] = [];
            dataset.eachColumn(function (c) {
              if (required === 'multiple' && axes[key].length) return;else if (available <= required) return;

              if (checkColumn(axisDef, c)) {
                usedColumns[c.name()] = true;
                axes[key].push(c.name());
                available--;
              }
            });
          }
        } else {
          axes[key] = false;
        }
      });
      each(axes, (columns, key) => {
        if (!isArray$5(columns)) {
          axesAsColumns[key] = columns !== false ? dataset.column(columns) : null;
        } else {
          axesAsColumns[key] = [];
          each(columns, function (column, i) {
            axesAsColumns[key][i] = column !== false ? dataset.column(column) : null;
          });
        }
      });
      return {
        axes,
        axesAsColumns,
        usedColumns
      };

      function columnExists(columns) {
        if (!isArray$5(columns)) columns = [columns];

        for (var i = 0; i < columns.length; i++) {
          if (!dataset.hasColumn(columns[i])) return false;
        }

        return true;
      }

      function checkColumn(axisDef, columns, allowMultipleUse) {
        if (!isArray$5(columns)) columns = [columns];
        columns = columns.map(el => typeof el === 'string' ? dataset.column(el) : el);

        for (var i = 0; i < columns.length; i++) {
          if (!allowMultipleUse && usedColumns[columns[i].name()] || indexOf(axisDef.accepts, columns[i].type()) === -1) {
            return false;
          }
        }

        return true;
      }
    }

    function filterDatasetColumns (chart, dataset) {
      if (!dataset.filterColumns) return dataset;
      const columnFormat = chart.getMetadata('data.column-format', {});
      const ignore = Object.fromEntries(Object.entries(columnFormat).map(_ref => {
        let [key, format] = _ref;
        return [key, !!format.ignore];
      }));
      dataset.filterColumns(ignore);
      return dataset;
    }

    /* globals dw */

    const base = function () {}.prototype;

    extend(base, {
      // called before rendering
      __init() {
        this.__renderedDfd = new Promise(resolve => {
          this.__renderedResolve = resolve;
        });
        this.__rendered = false;
        this.__colors = {};
        this.__callbacks = {};

        if (window.parent && window.parent.postMessage) {
          window.parent.postMessage('datawrapper:vis:init', '*');
        }

        return this;
      },

      render(el) {
        el.innerHTML = 'implement me!';
      },

      theme(theme) {
        if (!arguments.length) {
          if (typeof this.__theme === 'string') return dw.theme(this.__theme);
          return this.__theme;
        }

        this.__theme = theme;
        return this;
      },

      libraries(libraries) {
        if (!arguments.length) {
          return this.__libraries || {};
        }

        this.__libraries = libraries;
        return this;
      },

      target(target) {
        if (!arguments.length) {
          return this.__target;
        }

        this.__target = target;
        return this;
      },

      size(width, height) {
        const me = this;
        if (!arguments.length) return [me.__w, me.__h];
        me.__w = width;
        me.__h = height;
        return me;
      },

      /**
       * short-cut for this.chart.get('metadata.visualize.*')
       */
      get(str, _default) {
        return get_1(this.chart().get(), 'metadata.visualize' + (str ? '.' + str : ''), _default);
      },

      chart(chart) {
        var me = this;
        if (!arguments.length) return me.__chart;
        me.dataset = chart.dataset();
        me.theme(chart.theme());
        me.__chart = chart; // reset visualization cache to make sure
        // auto-populated columns get re-created

        me.__axisCache = undefined;
        filterDatasetColumns(chart, me.dataset); // set locale

        const {
          numeral
        } = me.libraries();

        if (numeral && chart.locales && chart.locales.numeral) {
          try {
            numeral.register('locale', 'dw', chart.locales.numeral);
          } catch (e) {
            if (e instanceof TypeError) ; else {
              throw e;
            }
          }

          numeral.locale('dw');
        }

        return me;
      },

      axes(returnAsColumns, noCache) {
        const me = this;
        const userAxes = get_1(me.chart().get(), 'metadata.axes', {});
        const visAxes = clone_1(me.meta.axes);
        const overrideKeys = Object.fromEntries(Object.entries(visAxes).filter(_ref => {
          let [, axis] = _ref;
          return axis.optional && axis.overrideOptionalKey;
        }).map(_ref2 => {
          let [, axis] = _ref2;
          return [axis.overrideOptionalKey, me.chart().getMetadata(axis.overrideOptionalKey, false)];
        }));

        if (!noCache && me.__axisCache && isEqual$1(me.__axisCache.userAxes, userAxes) && isEqual$1(me.__axisCache.overrideKeys, overrideKeys) && me.__axisCache.transpose === me.chart().getMetadata('data.transpose')) {
          return me.__axisCache[returnAsColumns ? 'axesAsColumns' : 'axes'];
        }

        const dataset = me.chart().dataset();
        const {
          axes,
          axesAsColumns
        } = populateVisAxes({
          dataset,
          userAxes,
          visAxes,
          overrideKeys
        });
        me.__axisCache = {
          axes: axes,
          axesAsColumns: axesAsColumns,
          userAxes: clone_1(userAxes),
          overrideKeys,
          transpose: me.chart().getMetadata('data.transpose')
        };
        return me.__axisCache[returnAsColumns ? 'axesAsColumns' : 'axes'];
      },

      keys() {
        const axesDef = this.axes();

        if (axesDef.labels) {
          const lblCol = this.dataset.column(axesDef.labels);
          const keys = [];
          lblCol.each(val => {
            keys.push(String(val));
          });
          return keys;
        }

        return [];
      },

      keyLabel(key) {
        return key;
      },

      /*
       * called by the core whenever the chart is re-drawn
       * without reloading the page
       */
      reset() {
        this.clear();
        const el = this.target();
        el.innerHTML = '';
        remove('.chart .filter-ui');
        remove('.chart .legend');
      },

      clear() {},

      renderingComplete() {
        if (window.parent && window.parent.postMessage) {
          setTimeout(function () {
            window.parent.postMessage('datawrapper:vis:rendered', '*');
          }, 200);
        }

        this.__renderedResolve();

        this.__rendered = true;
        this.postRendering();
      },

      postRendering() {},

      rendered() {
        return this.__renderedDfd;
      },

      /*
       * smart rendering means that a visualization is able to
       * re-render itself without having to instantiate it again
       */
      supportsSmartRendering() {
        return false;
      },

      colorMode(cm) {
        if (!arguments.length) {
          return this.__colorMode;
        }

        this.__colorMode = cm;
      },

      colorMap(cm) {
        var _this = this;

        if (!arguments.length) {
          return function () {
            let color = arguments.length <= 0 ? undefined : arguments[0];
            const applyDarkModeMap = _this.__darkMode && _this.__darkModeColorMap;
            _this.__colors[color] = 1;

            if (_this.__colorMap) {
              if (applyDarkModeMap) color = _this.__darkModeColorMap(...arguments);
              return _this.__colorMap(color);
            } else if (applyDarkModeMap) {
              color = _this.__darkModeColorMap(...arguments);
            }

            return color;
          };
        }

        this.__colorMap = cm;
      },

      initDarkMode(cb, cm) {
        this.__onDarkModeChange = cb;
        this.__darkModeColorMap = cm;
      },

      /**
       * set or get dark mode state of vis
       */
      darkMode(dm) {
        // can't initialize in __init because that sets it back to false on each render
        if (this.__darkMode === undefined) this.__darkMode = false;
        if (!arguments.length) return this.__darkMode;
        if (!this.__onDarkModeChange) return;
        this.__darkMode = dm;

        this.__onDarkModeChange(dm);
      },

      colorsUsed() {
        return Object.keys(this.__colors);
      },

      /**
       * register an event listener for custom vis events
       */
      on(eventType, callback) {
        if (!this.__callbacks[eventType]) {
          this.__callbacks[eventType] = [];
        }

        this.__callbacks[eventType].push(callback);
      },

      /**
       * fire a custom vis event
       */
      fire(eventType, data) {
        if (this.__callbacks && this.__callbacks[eventType]) {
          this.__callbacks[eventType].forEach(function (cb) {
            if (typeof cb === 'function') cb(data);
          });
        }
      }

    });

    const __vis = {};

    function visualization(id, target) {
      if (!__vis[id]) {
        console.warn('unknown visualization type: ' + id);
        const known = Object.keys(__vis);
        if (known.length > 0) console.warn('try one of these instead: ' + known.join(', '));
        return false;
      }

      function getParents(vis) {
        const parents = [];

        while (vis.parentVis !== 'base') {
          vis = __vis[vis.parentVis];
          parents.push({
            id: vis.parentVis,
            vis
          });
        }

        return parents.reverse();
      }

      const vis = clone$1(base);
      const parents = getParents(__vis[id]);
      parents.push({
        id,
        vis: __vis[id]
      });
      parents.forEach(el => {
        Object.assign(vis, typeof el.vis.init === 'function' ? el.vis.init({
          target
        }) : el.vis.init, {
          id
        });
      });
      vis.libraries(visualization.libraries);

      if (target) {
        vis.target(target);
      }

      return vis;
    }

    visualization.register = function (id) {
      let parentVis, init;

      if (arguments.length === 2) {
        parentVis = 'base';
        init = arguments[1];
      } else if (arguments.length === 3) {
        parentVis = arguments[1];
        init = arguments[2];
      }

      __vis[id] = {
        parentVis,
        init
      };
    };

    visualization.has = function (id) {
      return __vis[id] !== undefined;
    };

    visualization.libraries = {
      numeral
    };
    visualization.base = base;

    const __themes = {};

    function theme(id) {
      return __themes[id];
    }

    theme.register = function (id, props) {
      __themes[id] = props;
    };

    const __blocks = {};

    function block(id) {
      return __blocks[id];
    }

    block.register = function (id, lib) {
      __blocks[id] = lib;
    };

    block.has = function (id) {
      return __blocks[id] !== undefined;
    };

    let __notifications = [];

    function notify(notification) {
      notification.remove = () => {
        __notifications = __notifications.filter(d => d !== notification);
        window.parent.dw.backend.fire('notifications.change', __notifications);
      };

      __notifications.push(notification);

      try {
        window.parent.dw.backend.fire('notifications.change', __notifications);
        return notification.remove;
      } catch (ex) {
        /* not in editor, do nothing */
      }
    }

    /* eslint-env node */
    Column.types = columnTypes; // dw.start.js

    const dw$1 = {
      version: 'chart-core@8.47.0',
      dataset: Dataset,
      column: Column,
      datasource: {
        delimited,
        json
      },
      utils,
      chart,
      visualization,
      theme,
      block,
      notify
    };

    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = dw$1;
      }

      exports.dw = dw$1;
    } else {
      window.dw = dw$1;
    }

    return dw$1;

})();
//# sourceMappingURL=dw-2.0.min.js.map
